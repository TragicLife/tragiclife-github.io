{"meta":{"title":"薛鸿杰的博客","subtitle":null,"description":null,"author":"薛鸿杰","url":"https://xuehongjie.github.io"},"pages":[{"title":"","date":"2018-12-02T07:00:58.836Z","updated":"2018-12-02T07:00:58.836Z","comments":false,"path":"tags/index.html","permalink":"https://xuehongjie.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-05T14:13:25.229Z","updated":"2018-12-05T14:13:25.229Z","comments":false,"path":"categories/index.html","permalink":"https://xuehongjie.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"typescript-类型断言与类型守卫","slug":"front-end/typescript/assert","date":"2021-03-31T00:09:40.000Z","updated":"2021-03-30T16:15:25.791Z","comments":true,"path":"front-end/typescript/assert/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/assert/","excerpt":"","text":"类型断言在 TS 中获取或者设置对象值的属性时，经常会遇到不必要的警告或者报错，如下代码 12const user = &#123;&#125;;user.name = 'test'; // 报错，类型“&#123;&#125;”上不存在属性“name” 这个时候可以利用断言来解决该报错 123456interface User &#123; name: string;&#125;const user = &#123;&#125; as User;user.name = 'test'; 类型断言不要滥用,在万不得已的情况下使用要谨慎,强制把某类型断言会造成 TypeScript 丧失代码提示的能力 双重断言","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-泛型","slug":"front-end/typescript/generic","date":"2021-03-30T00:24:03.000Z","updated":"2021-03-30T16:08:15.344Z","comments":true,"path":"front-end/typescript/generic/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/generic/","excerpt":"","text":"泛型初始泛型它是一个特殊的变量，这个变量代表传入的类型，然后再返回这个变量，只用于表示类型而不是值。 123456789// 一般方式function fn(a: number): number &#123; return a;&#125;// 泛型的方式function fn&lt;T&gt;(a: T): T &#123; return a;&#125; 多个参数类型可以一次定义多个类型参数 1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([1, 'One']); 泛型变量12345// 这里泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性function getArrLen&lt;T&gt;(arr: Array&lt;T&gt;) &#123; console.log((arr as Array&lt;any&gt;).length); return arr;&#125; 泛型接口泛型还可以作用于接口。 123456interface Fn&lt;T&gt; &#123; (para: T): T;&#125;// 当想传入一个 number 作为参数的时候，可以这么声明const fn: Fn&lt;number&gt; = (para) =&gt; para; 泛型类泛型除了可以在接口中使用，还能在类中使用，既可以作用于类本身，也可以作用于类的成员函数。 12345678910// 假设一个栈的数据结构class Stack&lt;T&gt; &#123; private arr: T[] = []; push(item: T) &#123; this.arr.push(item); &#125; pop() &#123; this.arr.pop(); &#125;&#125; 泛型约束可以用 &lt;T extend xx&gt; 的方式约束泛型 12345678910111213141516// 定义类型type Params = number | string;// 声明 stack ，约束类型为 Params 的类型，即 number 和 stringclass Stack&lt;T extends Params&gt; &#123; private arr: T[] = []; push(item: T) &#123; this.arr.push(item); &#125; pop() &#123; this.arr.pop(); &#125;&#125;const s1 = new Stack&lt;number&gt;();const s2 = new Stack&lt;boolean&gt;(); // 报错，提示类型“boolean”不满足约束“Params” 泛型约束与索引类型1234// 在类型 \"&#123;&#125;\" 上找不到具有类型为 \"string\" 的参数的索引签名。function getVal(obj: object, key: string) &#123; return obj[key];&#125; 改用泛型约束第一个参数的类型 1234// 依然报上面的错，key 是不是存在于 obj 是无法确定的function getVal&lt;T extends object&gt;(obj: T, key: string) &#123; return obj[key];&#125; 采用索引类型 keyof T 对 key 进行约束，生成一个联合类型 123function getVal&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123; return obj[key];&#125; 接下来使用声明的这个方法 1234567const a = &#123; name: 'xiaomuzhu', id: 1,&#125;;getVal(a, 'name');getVal(a, 'name2'); // 报错，类型“\"name2\"”的参数不能赋给类型“\"name\" | \"id\"”的参数 使用多重类型进行泛型约束首先定义两个接口用于泛型约束 1234567interface FirstInterface &#123; doSomething(): number;&#125;interface SecondInterface &#123; doSomethingElse(): string;&#125; 通过子接口实现多重泛型约束12// 定义一个子接口，继承上面2个接口interface ChildInterafce extends FirstInterface, SecondInterface &#123;&#125; 利用交叉类型来进行多类型约束12345678class Multiple&lt;T extends FirstInterface &amp; SecondInterface&gt; &#123; private genericProp: T; use() &#123; this.genericProp.doSomething(); this.genericProp.doSomethingElse(); &#125;&#125; 示例是在非 「–strictPropertyInitialization」或者「–strict」下测试的 泛型与 new声明一个泛型拥有构造函数 123function factory&lt;T&gt;(Type: T): T &#123; return new Type(); // 报错，此表达式不可构造，类型 \"&#123;&#125;\" 没有构造签名&#125; 利用 new 来实现，设置 Type 的类型为 {new(): T} 来表示次泛型是可被构造的，被实例化后的类型是泛型 123function factory&lt;T&gt;(Type: &#123; new (): T &#125;): T &#123; return new Type();&#125; 总结设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是： 接口 类的实例成员 类的方法 函数参数 函数返回值","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-function","slug":"front-end/typescript/function","date":"2021-03-28T23:44:03.000Z","updated":"2021-03-30T15:09:38.321Z","comments":true,"path":"front-end/typescript/function/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/function/","excerpt":"","text":"函数定义函数类型12345// 类型推断为 number， 隐式推断const add = (a: number, b: number): number =&gt; a + b;// 显式定义const add: (a: number, b: number) =&gt; number = (a: number, b: number) =&gt; a + b; 参数详解可选参数只需要在参数后面加上 ? ，即代表参数可能不存在 12// 参数 b 有 number 或 undefined 两种可能const add = (a: number, b?: number) =&gt; a + (b || 0); 默认参数与 JavaScript 相同，在参数后面赋值即可。 1const add = (a: number, b = 1) =&gt; a + b; 剩余参数与 JavaScript 类似，使用 ... 来表示剩余参数 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce((a, b) =&gt; a + b, a); 重载 (Overload)函数名相同，传入参数个数不同。 123456789101112131415161718192021222324252627282930// 重载interface Direction &#123; top: number; bottom?: number; left?: number; right?: number;&#125;function assigned(all: number): Direction;function assigned(topAndBottom: number, leftAndRight: number): Direction;function assigned(top: number, right: number, bottom: number, left: number): Direction;function assigned(a: number, b?: number, c?: number, d?: number) &#123; if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) &#123; b = c = d = a; &#125; else if (c === undefined &amp;&amp; d === undefined) &#123; c = a; d = b; &#125; return &#123; top: a, right: b, bottom: c, left: d, &#125;;&#125;assigned(1);assigned(1, 2);assigned(1, 2, 3); // 没有需要 3 参数的重载，但存在需要 2 或 4 参数的重载。assigned(1, 2, 3, 4);","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-class","slug":"front-end/typescript/class","date":"2021-03-27T22:15:40.000Z","updated":"2021-03-30T15:09:30.839Z","comments":true,"path":"front-end/typescript/class/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/class/","excerpt":"","text":"类(class)在 ES6 之后，JavaScript 拥有了 class 关键字，虽然其本质还是构造函数，但是开发者已经可以比较舒服地使用 class 了 抽象类作为其它派生类的基类，一般不会被实例化，不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字用于定义抽象类和抽象类内部的抽象方法。 12345678abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log('move'); &#125;&#125;let ani = new Animal(); // 不能直接实例化抽象类，会报错 需要创建一个子类，继承基类(抽象类)，然后实例化子类。若基类中含有抽象方法，则子类需要实现该抽象方法。 12345678class Cat extends Animal &#123; makeSound() &#123; console.log('cat sound'); &#125;&#125;const cat = new Cat();cat.makeSound(); 访问限定符限制变量/方法的访问权限。 public默认的访问限定符，用此限定符修饰的成员是可以被外部访问的。 12345678class Car &#123; public run() &#123; console.log('car run'); &#125;&#125;const car = new Car();car.run(); private如果成员被设置为 private，则成员只能在类的内部访问。 12345678class Car &#123; private run() &#123; console.log('car run'); &#125;&#125;const car = new Car();car.run(); // 属性“run”为私有属性，只能在类“Car”中访问 protected如果成员被设置为 protected，则成员只能在类的内部及子类中访问。 123456789101112131415class Car &#123; protected run() &#123; console.log('car run'); &#125;&#125;class BW extends Car &#123; init() &#123; this.run(); &#125;&#125;const bw = new BW();bw.init();bw.run(); // 属性“run”受保护，只能在类“Car”及其子类中访问 可以当做接口使用假设有这么一个类，需要申明类型，且需要申明默认值，这时候 class 作为接口的好处就体现出来了。 12345678// 用一个 class 起到了接口和设置默认值的作业class Props &#123; public children: Array&lt;object&gt; = []; public prop1: string = 'test'; public prop2: number = 1;&#125;const defaultProps = new Props(); class 作为接口的好处：方便统一管理，减少代码量","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-interface","slug":"front-end/typescript/interface","date":"2021-03-26T00:30:14.000Z","updated":"2021-03-30T15:10:04.471Z","comments":true,"path":"front-end/typescript/interface/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/interface/","excerpt":"","text":"接口(interface)为值的类型命名和为代码或第三方代码定义契约 如何使用接口12345678// 会报错const getName = (user) =&gt; user.name;// 需要通过接口定义 user 的结构interface User &#123; name: string;&#125;const getName = (user: User) =&gt; user.name; 可选属性在处理数据的时候，某一项是可选的，这时候需要通过 ? 来描述这种属性 123456interface User &#123; name: string; age?: number;&#125;const getAge = (user: User) =&gt; user.age; // 代码会提示 age 可能是 undefiend 只读属性当某个值确定以后就不允许修改了，这时可以通过 readonly 来指定该属性 1234567interface User &#123; readonly isMale: boolean;&#125;const user: User = &#123; isMale: true,&#125;;user.isMale = false; // 提示 isMale 是只读属性，不允许修改 函数类型直接在 interface 内部描述123interface User &#123; say: (words: string) =&gt; string;&#125; 先使用接口描述函数，然后再在 User 中描述1234567interface Say &#123; (words: string): string;&#125;interface User &#123; say: Say;&#125; 属性检查对象字面量当被赋值给变量或作为参数传递的时候，会被特殊对待而且经过“额外属性检查”。 12345678910111213interface Config &#123; width?: number;&#125;function CalculateAreas(config: Config): &#123; area: number &#125; &#123; let square = 100; if (config.width) &#123; square = config.width * config.width; &#125; return &#123; area: square &#125;;&#125;let mySquare = CalculateAreas(&#123; widdth: 5 &#125;); // 错误提示：类型“&#123; widdth: number; &#125;”的参数不能赋给类型“Config”的参数。 报错的解决方案： 使用类型断言 1let mySquare = CalculateAreas(&#123; widdth: 5 &#125; as Config); 添加签名索引 1234interface Config &#123; width?: number; [key: string]: any;&#125; 将值赋值给另一个变量，并且定义为 any 类型 12let options: any = &#123; widdth: 5 &#125;;let mySquare = CalculateAreas(options); 转为 any 类型方法不到必要的时候不建议使用 可索引类型可索引类型描述了对象索引的类型，还有相应的索引返回值类型。 123456789101112131415161718// 假设用户信息如下const user = &#123; name: 'test', email: &#123; qq: 'test@qq.com', outlook: 'test@outlook.com', &#125;,&#125;;// 通过索引类型解决interface Email &#123; [name: string]: string;&#125;interface User &#123; name: string; email: Email;&#125; 继承接口拥有与被继承的接口相同属性，且在这个基础上增加自己的属性 123456789// 继承单个接口interface VIPUser extends User &#123; broadcast: () =&gt; void;&#125;// 继承多个接口interface VIPUser extends User, SupperUser &#123; broadcast: () =&gt; void;&#125;","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-枚举","slug":"front-end/typescript/enumeration","date":"2021-03-25T23:13:05.000Z","updated":"2021-03-30T15:09:20.946Z","comments":true,"path":"front-end/typescript/enumeration/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/enumeration/","excerpt":"","text":"枚举数字枚举默认值是从 0 开始，依次累加 123456789101112131415// 默认从 0 开始enum Num &#123; Zero, One, Two,&#125;console.log(Num.Zero, Num.One, Num.Two); // 0 1 2// 某个值指定了具体的数值，则其后面的值会根据指定值依次累加enum Num &#123; Zero, Six = 6, Seven,&#125;console.log(Num.Zero, Num.Six, Num.Seven); // 0 6 7 字符串枚举声明字符串枚举时，每个 key 都必须指定相应的值，不声明则会报错 12345enum Num &#123; Zero = '0', One = '1',&#125;console.log(Num.Zero, Num['One']); // 0 1 异构枚举多种类型混合使用 12345enum BooleanEnum &#123; No = 0, Yes = 'yes',&#125;console.log(BooleanEnum.No); // 0 反向映射可通过枚举值来获取枚举名字 1234567enum Num &#123; Zero, One, Two,&#125;console.log(Num.Zero, Num[1]); // 0 One 枚举的本质1234567891011121314// 编译前enum Num &#123; Zero, One, Two,&#125;// 编译后，类似一个 JavaScript 对象var Num;(function (Num) &#123; Num[(Num['Zero'] = 0)] = 'Zero'; Num[(Num['One'] = 1)] = 'One'; Num[(Num['Two'] = 2)] = 'Two';&#125;)(Num || (Num = &#123;&#125;)); 常量枚举123456789// 编译前const enum Num &#123; Zero, One,&#125;const a = Num.Zero;// 编译后，Num声明没有了var a = 0; /* Zero */ 如果想要保留枚举声明，则需要在编译的时候加上 --preserveConstEnums，或者是声明 enum 的时候不带 const 枚举成员类型123456789101112enum Num &#123; Zero, One, Two,&#125;type c = 0;declare let b: c;b = 1; // 不能将类型“1”分配给类型“0”b = Num.Zero; // ok 联合类型123456789101112131415enum Num &#123; Zero, One, Two,&#125;declare let a: Num;enum Animal &#123; Dog, Cat,&#125;a = Num.Zero; // oka = Animal.Dog; // 不能将类型“Animal.Dog”分配给类型“Num” 枚举合并12345678910// 名称相同的枚举会进行合并enum Num &#123; Zero, Onw, Two,&#125;enum Num &#123; Six = 6,&#125;console.log(Num.Six); // 6 为枚举添加静态方法利用 namespace 命名空间添加 1234567891011121314151617181920212223242526272829enum Month &#123; January, February, March, April, May, June, July, August, September, October, November, December,&#125;namespace Month &#123; export function isSummer(month: Month) &#123; switch (month) &#123; case Month.June: case Month.July: case Month.August: return true; default: return false; &#125; &#125;&#125;console.log(Month.isSummer(Month.January)); // false","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-类型","slug":"front-end/typescript/type","date":"2021-03-23T23:10:05.000Z","updated":"2021-03-30T15:11:00.126Z","comments":true,"path":"front-end/typescript/type/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/type/","excerpt":"","text":"类型TypeScript 的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。 布尔类型 boolean12// 用boolean表示布尔类型let flag: boolean = false; 数字类型 number12345// 二进制、十进制、十六进制都可以用 number表示let binaryNumber: number = 0b10;let decimalNumber: number = 2;let octalNumber: number = 0o20;let hexNumber: number = 0xf0; 字符串 string1let str: string = &apos;test&apos;; 空值 void12// 表示没有任何类型，只有 null 和 undefined 可以赋值给 voidlet a: void = undefined Null 和 Undefined12let a: undefined = undefined;let b: null = null; Symbol使用 Symbol 的时候，需要给 tsconfig.json 文件中的 lib 设置 es6 编译辅助库 1let s: symbol = Symbol(1) BigInt需要在 tsconfig.json 文件中的 lib 配置 esnext 123const max: = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991nconst max1 = max + 1n BigInt 转化过的值相加需要在数字后面带 n, 如: BigInt(4) + 1n any123// 在编程过程中不确定一个值的类型时，可以用 any 来指定let a: any = 1;a = &apos;test;&apos; unknown与 any 类似，区别是：unknown 在被明确为某个类型之前无法实例化、函数执行 123456789101112let a: unknown;a.test; // 错误提示let fn: unknown;fn(); // 错误提示// 缩小类型范围let fn: unknown;if (typeof fn === &apos;function&apos;) &#123; fn();&#125; never表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 12345678// 常见的场景// 抛出异常的函数永远不会有返回值function error(message: string): never &#123; throw new Error(message);&#125;// 空数组，而且永远是空的const empty: never[] = [] 数组12345// 泛型的定义方式let list: Array&lt;string&gt; = [&apos;1&apos;];// 直接在元素类型后面加上 []let list: string[] = [&apos;1&apos;] 元组 Tuple元组类型与数组类型非常相似，表示一个已知元素数量和类型的数组，各元素的类型可以不相同。 123456789// 赋值的数量必须与声明的数量一致，且类型也必须相同let tuple: [number, string] = [1, &apos;2&apos;];// 继承数组interface Tuple extends Array&lt;string | number&gt; &#123; 0: string; 1: number; length: 2;&#125; 此外，还有一个个元组越界问题，比如 Typescript 允许向元组中使用数组的 push 方法插入新元素: 123const tuple: [string, number] = [&apos;a&apos;, 1];tuple.push(2); // ok，可添加，但不可访问console.log(tuple); // [&quot;a&quot;, 1, 2] -&gt; 正常打印出来 但是当我们访问新加入的元素时，会报错: 1console.log(tuple[2]); // Tuple type &apos;[string, number]&apos; of length &apos;2&apos; has no element at index &apos;2&apos; Object除基本数据类型之外的类型 123456789let obj: object;enum Shape &#123; circle = 1,&#125;obj = Shape;obj = ['a'];obj = ['a', 1];obj = &#123;&#125;;","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-简介","slug":"front-end/typescript/introduction","date":"2021-03-22T22:43:10.000Z","updated":"2021-03-28T13:21:17.699Z","comments":true,"path":"front-end/typescript/introduction/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/introduction/","excerpt":"","text":"简介TypeScript 是 JavaScript 的超集，它涵盖 ES6、ES7 等新语法特性。它同时也是一门静态弱类型语言，因为要兼容 JavaScript,因此 TypeScript 几乎不限制 JavaScript 中原有的隐式类型转换。 静态语言：在编译时期报错；动态语言：在运行时期报错 优势 规避大量低级错误，避免时间浪费，省时 减少多人协作项目的成本，大型项目友好，省力 良好代码提示，不用反复文件跳转或者翻文档，省心 创建项目123456789// 1. 新建代码目录// 2. 初始化项目npm init// 3. 安装typescriptnpm install typescript -D// 4. 初始化typescript配置文件，目录下会多一个 tsconfig.json 文件tsc --init 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// tsconfig.json文件&#123; \"compilerOptions\": &#123; /* Basic Options */ // \"incremental\": true, /* Enable incremental compilation */ \"target\": \"es5\", /* 指定 EcmaScript 目标版本，Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */ \"module\": \"commonjs\", /* 指定使用模块，Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ \"lib\": [\"es6\", \"dom\", \"esnext\"], /* 指定要包含在编译中的库文件, Specify library files to be included in the compilation. */ // \"allowJs\": true, /* Allow javascript files to be compiled. */ // \"checkJs\": true, /* Report errors in .js files. */ // \"jsx\": \"preserve\", /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */ // \"declaration\": true, /* 生成相应的.d.ts文件, Generates corresponding '.d.ts' file. */ // \"declarationMap\": true, /* Generates a sourcemap for each corresponding '.d.ts' file. */ // \"sourceMap\": true, /* 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件, Generates corresponding '.map' file. */ // \"outFile\": \"./\", /* Concatenate and emit output to single file. */ // \"outDir\": \"./\", /* Redirect output structure to the directory. */ // \"rootDir\": \"./\", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // \"composite\": true, /* Enable project compilation */ // \"tsBuildInfoFile\": \"./\", /* Specify file to store incremental compilation information */ // \"removeComments\": true, /* 删除编译后的所有的注释, Do not emit comments to output. */ // \"noEmit\": true, /* Do not emit outputs. */ // \"importHelpers\": true, /* 从 tslib 导入辅助工具函数, Import emit helpers from 'tslib'. */ // \"downlevelIteration\": true, /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */ // \"isolatedModules\": true, /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */ /* Strict Type-Checking Options */ \"strict\": true, /* 启用所有严格类型检查选项, Enable all strict type-checking options. */ // \"noImplicitAny\": true, /* 在表达式和声明上有隐含的 any类型时报错, Raise error on expressions and declarations with an implied 'any' type. */ // \"strictNullChecks\": true, /* Enable strict null checks. */ // \"strictFunctionTypes\": true, /* Enable strict checking of function types. */ // \"strictBindCallApply\": true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ // \"strictPropertyInitialization\": true, /* Enable strict checking of property initialization in classes. */ // \"noImplicitThis\": true, /* Raise error on 'this' expressions with an implied 'any' type. */ // \"alwaysStrict\": true, /* 以严格模式检查模块，并在每个文件里加入 'use strict', Parse in strict mode and emit \"use strict\" for each source file. */ /* Additional Checks */ // \"noUnusedLocals\": true, /* Report errors on unused locals. */ // \"noUnusedParameters\": true, /* Report errors on unused parameters. */ // \"noImplicitReturns\": true, /* 不是函数的所有返回路径都有返回值时报错, Report error when not all code paths in function return a value. */ // \"noFallthroughCasesInSwitch\": true, /* Report errors for fallthrough cases in switch statement. */ /* Module Resolution Options */ // \"moduleResolution\": \"node\", /* 模块解析策略，Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */ // \"baseUrl\": \"./\", /* Base directory to resolve non-absolute module names. */ // \"paths\": &#123;&#125;, /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */ // \"rootDirs\": [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // \"typeRoots\": [], /* List of folders to include type definitions from. */ // \"types\": [], /* Type declaration files to be included in compilation. */ // \"allowSyntheticDefaultImports\": true, /* 允许从没有设置默认导出的模块中默认导入, Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ \"esModuleInterop\": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ // \"preserveSymlinks\": true, /* Do not resolve the real path of symlinks. */ // \"allowUmdGlobalAccess\": true, /* Allow accessing UMD globals from modules. */ /* Source Map Options */ // \"sourceRoot\": \"\", /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // \"mapRoot\": \"\", /* Specify the location where debugger should locate map files instead of generated locations. */ // \"inlineSourceMap\": true, /* Emit a single file with source maps instead of having a separate file. */ // \"inlineSources\": true, /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */ /* Experimental Options */ // \"experimentalDecorators\": true, /* 启用实验性的ES装饰器, Enables experimental support for ES7 decorators. */ // \"emitDecoratorMetadata\": true, /* Enables experimental support for emitting type metadata for decorators. */ /* Advanced Options */ \"forceConsistentCasingInFileNames\": true /* Disallow inconsistently-cased references to the same file. */ &#125;, // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 \"include\": [ \"./src/**/**.ts\" ], \"exclude\": [ \"node_modules\", \"dist\", \"**/*.test.ts\", ]&#125; 提示找不到 console 库时，需要在 lib 中引入 dom","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"typescript-类型","slug":"front-end/typescript/basic","date":"2021-03-22T00:43:10.000Z","updated":"2021-03-28T13:20:59.288Z","comments":true,"path":"front-end/typescript/basic/","link":"","permalink":"https://xuehongjie.github.io/front-end/typescript/basic/","excerpt":"","text":"简介TypeScript 是 JavaScript 的超集，它涵盖 ES6、ES7 等新语法特性。它同时也是一门静态弱类型语言，因为要兼容 JavaScript,因此 TypeScript 几乎不限制 JavaScript 中原有的隐式类型转换。 静态语言：在编译时期报错；动态语言：在运行时期报错 优势 规避大量低级错误，避免时间浪费，省时 减少多人协作项目的成本，大型项目友好，省力 良好代码提示，不用反复文件跳转或者翻文档，省心 创建项目123456789// 1. 新建代码目录// 2. 初始化项目npm init// 3. 安装typescriptnpm install typescript -D// 4. 初始化typescript配置文件，目录下会多一个 tsconfig.json 文件tsc --init 基础类型TypeScript 的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint。 boolean number string void, 只有 null 和 undefined 可以赋值给 void","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xuehongjie.github.io/tags/typescript/"}]},{"title":"玩转Git-基础篇","slug":"front-end/geektime/git/basic","date":"2020-10-22T22:08:19.000Z","updated":"2020-12-01T16:58:27.651Z","comments":true,"path":"front-end/geektime/git/basic/","link":"","permalink":"https://xuehongjie.github.io/front-end/geektime/git/basic/","excerpt":"","text":"官网安装 git Git 的特点 最优的存储能力 非凡的性能 开源的 很容易做备份 支持离线操作 很容易定制工作流程 最小配置配置 user 信息12git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot; config 的三个作用域 --local：只对某个仓库有效 --global：对当前用户所以仓库有效 --system：对系统所有登录的用户有效 显示 config 的配置123git config --list --localgit config --list --globalgit config --list --system 创建 git 仓库 把已有的项目代码纳入 git 管理 12cd 代码目录git init 新建的项目直接用 git 管理 cd 代码目录 git init project cd project git log日志一行展示git log --oneline 展示最近 4 条日志git log -n4 查看所有分支的git log --all 提交流程 提交流程 添加到暂存区12345// 添加单个、多个文件git add 文件路径/文件名// 添加被git管理的所有文件git add -u","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"Git","slug":"Git","permalink":"https://xuehongjie.github.io/tags/Git/"}]},{"title":"玩转webpack-webpack构建配置","slug":"front-end/geektime/webpack/building-configurationn","date":"2020-04-06T10:20:23.000Z","updated":"2020-04-19T07:23:57.289Z","comments":true,"path":"front-end/geektime/webpack/building-configurationn/","link":"","permalink":"https://xuehongjie.github.io/front-end/geektime/webpack/building-configurationn/","excerpt":"","text":"构建配置可选方案 通过多个配置文件管理不同环境的构建，webpack --config 参数进行控制 将构建配置设计成一个库，比如：hjs-webpack、Neutrino、webpack-blocks 抽成一个工具进行管理，比如：create-react-app, kyt, nwb 将所有的配置放在一个文件，通过 --env 参数控制分支选择 构建配置包设计通过多个配置文件管理不同环境的 webpack 配置 基础配置：webpack.base.js 开发环境：webpack.dev.js 生产环境：webpack.prod.js SSR 环境：webpack.ssr.js ·规范：Git commit 日志、README、ESLint 规范、Semver 规范·质量：冒烟测试、单元测试、测试覆盖率和 CI·SSR 环境：webpack.ssr.js npm version patch // 更新小版本，bug 修复 提交格式要求 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type 代表某次提交的类型，比如是修复一个 bug 还是增加一个新的 featuretype 可选值： feat","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"webpack","slug":"webpack","permalink":"https://xuehongjie.github.io/tags/webpack/"},{"name":"极客时间","slug":"极客时间","permalink":"https://xuehongjie.github.io/tags/极客时间/"}]},{"title":"玩转webpack-webpack进阶用法","slug":"front-end/geektime/webpack/advance","date":"2020-04-01T22:50:11.000Z","updated":"2020-04-05T16:36:09.559Z","comments":true,"path":"front-end/geektime/webpack/advance/","link":"","permalink":"https://xuehongjie.github.io/front-end/geektime/webpack/advance/","excerpt":"","text":"当前构建时的问题每次构建的时候不会清理目录，造成构建的输出目录 output 文件越来越多 通过 npm scripts 清理构建目录 rm -rf ./dist &amp;&amp; webpack rimraf ./dist &amp;&amp; webpack 使用 clean-webpack-plugin，默认会删除 output 指定的输出目录 123456789const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);// 编译时出现CleanWebpackPlugin is not a constructor错误，则使用下面的引用方式const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;); // 新版本用法module.exports = &#123; plugins: [ new CleanWebpackPlugin(), ]&#125; 样式自动补齐前缀使用 autoprefixer 插件 123456789101112131415161718192021222324module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;, &#123; loader: &apos;postcss-loader&apos;, options: &#123; plugins: () =&gt; &#123; require(&apos;autoprefixer&apos;)(&#123; browsers: [&apos;last 2 version&apos;, &apos;&gt;1%&apos;, &apos;iOS 7&apos;] &#125;) &#125; &#125; &#125; ] &#125; ] &#125;&#125; px 转 rem使⽤用 px2rem-loader，配合手淘的 lib-flexible 123456789101112131415161718module.exports = &#123; module: &#123; rules: [&#123; test: /\\.less$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;, &#123; loader: &quot;px2rem-loader&quot;, options: &#123; remUnit: 75, remPrecision: 8 &#125; &#125;] &#125;] &#125;&#125;; 资源内联资源内联的意义： ⻚面框架的初始化脚本 上报相关打点 css 内联避免⻚面闪动 ⼩图片或者字体内联 (url-loader) HTML 和 JS 内联通过 raw-loader 进行内联 12345// 内联html&lt;script&gt;$&#123;require(&apos; raw-loader!babel-loader!. /meta.html&apos;)&#125;&lt;/script&gt;// 内联js&lt;script&gt;$&#123;require(&apos;raw-loader!babel-loader!../node_modules/lib-flexible&apos;)&#125;&lt;/script&gt; CSS 内联 借助 style-loader 使用 html-inline-css-webpack-plugin 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ &#123; loader: &apos;style-loader&apos;, options: &#123; insertAt: &apos;top&apos;, // 样式插入到&lt;head&gt; singleton: true, //将所有的style标签合并成一个 &#125;, &#125;, &apos;css-loader&apos;, &apos;sass-loader&apos;, ], &#125;, ], &#125;,&#125;; 多页面打包利用 glob.sync 动态获取 entry 和设置 html-webpack-plugin 的数量，解决手动增加 entry 的问题 123456789101112131415161718192021222324252627282930313233const path = require(&apos;path&apos;);const glob = require(&apos;glob&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const entry = &#123;&#125;;const htmlPlugin = [];// 获取所有页面入口const fileList = glob.sync(path.join(__dirname, &apos;./src/*/index.js&apos;));fileList.forEach((file) =&gt; &#123; const match = file.match(/src\\/(.*)\\/index.js/); const fileName = match &amp;&amp; match[1]; entry[fileName] = file; htmlPlugin.push( new HtmlWebpackPlugin(&#123; template: `./src/$&#123;fileName&#125;/index.html`, filename: `$&#123;fileName&#125;.html`, chunks: [fileName], inject: true, &#125;) );&#125;);module.exports = &#123; entry, output: &#123; filename: &apos;[name].js&apos;, // 通过占位符确保文件名称的唯一 path: __dirname + &apos;/dist&apos;, // 输出的目录 &#125;, mode: &apos;production&apos;, plugins: htmlPlugin,&#125;; 使用 source map作用：通过 source map 定位到源代码 开发环境开启，线上环境关闭 source map 关键字 eval: 使用 eval 包裹模块代码 cheap: 不包含列列信息 inline: 将.map 作为 DataURI 嵌⼊，不单独⽣成.map ⽂文件 module:包含 loader 的 sourcemap source map 类型 source map类型 文件拆分基础库分离使用 html-webpack-externals-plugin 1234567891011121314151617181920const HtmlWebpackExternalsPlugin = require(&apos;html-webpack-externals-plugin&apos;);module.exports = &#123; plugins: [ new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; module: &apos;vue&apos;, entry: &apos;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&apos;, global: &apos;Vue&apos; &#125;, &#123; module: &apos;jquery&apos;, entry: &apos;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&apos;, global: &apos;jQuery&apos; &#125; ] &#125;) ]&#125; 使用 SplitChunksPlugin 分离Webpack4 内置的，用于替代 CommonsChunkPlugin 插件 1234567891011121314151617181920212223module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &apos;async&apos;, minSize: 30000, // 最小大小，即当抽取的公共模块的大小，大于minSize所设置的值，才起作用 maxSize: 0, minChunks: 1, // 最少引入次数，即当块的数量大于等于minChunks时，才起作用 maxAsyncRequests: 5, // 浏览器同时请求的次数 maxInitialRequests: 3, automaticNameDelimiter: &apos;~&apos;, name: true, // 缓存组，抽取公共模块 cacheGroups: &#123; vendors: &#123; name: &apos;vendors&apos;, test: /[\\\\/]node_modules[\\\\/]/, // 匹配规则，说明要匹配的项 priority: -10, // 优先级，决定执行顺序 minSize: 0, &#125;, &#125;, &#125;, &#125;,&#125;; chunks 参数说明： async 异步引⼊入的库进⾏行行分离(默认) initial 同步引⼊入的库进⾏行行分离 all 所有引⼊入的库进⾏行行分离(推荐) tree shaking(摇树优化)1 个模块可能有多个方法，只要其中的某个⽅法使⽤到了，则整个⽂件都会被打到 bundle ⾥面去，tree shaking 就是只把⽤到的⽅法打⼊ bundle ，没⽤到的⽅法会在 uglify 阶段被擦除掉。 如何使用： webpack 默认支持，在 .babelrc ⾥设置 modules: false 即可 production mode 的情况下默认开启 要求：必须是 ES6 的语法，CJS 的⽅式不支持 模块转换分析 被 webpack 转换后的模块会带上⼀层包裹 import 会被转换成 __webpack_require 模块机制 打包出来的是一个 IIFE (匿匿名闭包) modules 是一个数组，每⼀项是一个模块初始化函数 __webpack_require ⽤用来加载模块，返回 module.exports 通过 WEBPACK_REQUIRE_METHOD(0) 启动程序 scope hoisting原理将所有模块的代码按照引用顺序放在⼀个函数作⽤域⾥，然后适当的重命名⼀些变量以防⽌变量名冲突 使用 mode 为 production 默认开启 在 plugins 添加 new webpack.optimize.ModuleConcatenationPlugin()使用 懒加载 JS 脚本 CommonJS：require.ensure ES6：动态 import（⽬前还没有原⽣支持，需要 babel 转换） 12345678910// 安装babel插件npm install @babel/plugin-syntax-dynamic-import// 在.babelrc文件中设置&quot;plugins&quot;: [ &quot;@babel/plugin-syntax-dynamic-import&quot;]// 使用，webpack通过jsonp的方式加载import(&apos;引入的模块&apos;) ESLint行业⾥面优秀的 ESLint 规范实践 Airbnb: eslint-config-airbnb、 eslint-config-airbnb-base 腾讯： alloyteam 团队 eslint-config-alloy(https://github.com/AlloyTeam/eslint-config-alloy) ivweb 团队：eslint-config-ivweb(https://github.com/feflow/eslint-config-ivweb) 集成使用 webpack 与 CI/CD 集成 12345678910111213141516// 本地开发阶段增加 precommit 钩⼦// 安装huskynpm install husky --save-dev// 增加 npm script，通过 lint-staged 增量检查修改的⽂件&quot;scripts&quot;: &#123; &quot;precommit&quot;: &quot;lint-staged&quot;&#125;,&quot;lint-staged&quot;: &#123; &quot;linters&quot;: &#123; &quot;*.&#123;js,scss&#125;&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ] &#125;&#125;, webpack 与 ESLint 集成 12345678910111213// 安装依赖babel-eslint、eslint、eslint-loader、eslint-plugin-import// 使用eslint-loader，在构建时检查JS规范module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;], &#125;, ], &#125;,&#125;; 打包库和组件如何将库暴露出去12345678910111213module.exports = &#123; mode: &apos;production&apos;, entry: &#123; &apos;large-number&apos;: &apos;./src/index.js&apos;, &apos;large-number.min&apos;: &apos;./src/index.js&apos;, &#125;, output: &#123; filename: &apos;[name].js&apos;, library: &apos;largeNumber&apos;, // 指定库的全局变量量 libraryExport: &apos;default&apos;, libraryTarget: &apos;umd&apos;, // ⽀支持库引⼊入的⽅方式 &#125;,&#125;; 指定对.min 压缩12345678910module.exports = &#123; optimization: &#123; minimize: true, minimizer: [ new TerserPlugin(&#123; include: /\\.min\\.js$/, &#125;), ], &#125;,&#125; 设置入口文件123456// 根据package.json文件中main设置的文件编写如下代码if (process.env.NODE_ENV === &apos;production&apos;) &#123; module.exports = require(&apos;./dist/large-number.min.js&apos;);&#125; else &#123; module.exports = require(&apos;./dist/large-number.js&apos;);&#125; SSR所有模板等资源都存储在服务端，一个 HTML 返回所有数据 优势 减少白屏时间 对于 SEO 友好 存在的问题与解决方案 浏览器的全局变量 (Node.js 中没有 document, window) 组件适配：将不兼容的组件根据打包环境进⾏适配 123if(typeof window === &apos;undefined&apos;) &#123; global.window = &#123;&#125;;&#125; 请求适配：将 fetch 或者 ajax 发送请求的写法改成 isomorphic-fetch 或者 axios 样式问题 (Node.js 无法解析 css) 方案一：服务端打包通过 ignore-loader 忽略掉 CSS 的解析 方案二：将 style-loader 替换成 isomorphic-style-loader 解决样式不显示问题和首屏数据使⽤打包出来的浏览器端 html 为模板，设置占位符，动态插入组件 12345678910// index.html&lt;div id=&quot;root&quot;&gt;&lt;!--HTML_PLACEHOLDER--&gt;&lt;/div&gt;&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;// node服务中，替换模板和数据const renderMarkup = (str) =&gt; &#123; const dataStr = JSON.stringify(data); return template.replace(&apos;&lt;!--HTML_PLACEHOLDER--&gt;&apos;, str) .replace(&apos;&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;&apos;, `&lt;script&gt;window.__initial_data=$&#123;dataStr&#125;&lt;/script&gt;`);&#125; 日志信息统计信息 stats stats 属性值 描述 errors-only 只在发生错误时输出 minimal 只在发生错误或有新的编译时输出 none 没有输出 normal 标准输出 verbose 全部输出 优化命令行的构建日志使用 friendly-errors-webpack-plugin 1234567const FriendlyErrorsWebpackPlugin = require(&apos;friendly-errors-webpack-plugin&apos;);module.exports = &#123; plugins: [ new FriendlyErrorsWebpackPlugin(), ], stats: &apos;error-only&apos;&#125; 构建如何判断构建是否成功每次构建完成后输入 echo \\$?获取错误码，0 为成功 需要在 git/linux 命令中执行 构建异常和中断处理webpack4 之前的版本构建失败不会抛出错误码 (error code)Node.js 中的 process.exit 规范 0 表示成功完成，回调函数中，err 为 null ⾮ 0 表示执⾏失败，回调函数中，err 不为 null，err.code 就是传给 exit 的数字 如何主动捕获并处理构建错误compiler 在每次构建结束后会触发 done 这个 hook,process.exit 主动处理理构建报错 1234567891011121314151617module.exports = &#123; plugins: [ function () &#123; // webpack4的写法，webpack3需要写成this.plugin(&apos;done&apos;) this.hooks.done.tap(&apos;done&apos;, (stats) =&gt; &#123; if ( stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf(&apos;--watch&apos;) == -1 ) &#123; console.log(&apos;build error&apos;); process.exit(1); &#125; &#125;); &#125;, ]&#125;","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"webpack","slug":"webpack","permalink":"https://xuehongjie.github.io/tags/webpack/"},{"name":"极客时间","slug":"极客时间","permalink":"https://xuehongjie.github.io/tags/极客时间/"}]},{"title":"玩转webpack-webpack基础用法","slug":"front-end/geektime/webpack/basic","date":"2020-03-28T13:01:10.000Z","updated":"2020-04-04T12:58:31.906Z","comments":true,"path":"front-end/geektime/webpack/basic/","link":"","permalink":"https://xuehongjie.github.io/front-end/geektime/webpack/basic/","excerpt":"","text":"Entry用来指定 webpack 的打包入口 单入口 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125; 多入口 123456module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, adminApp: &apos;./src/adminApp.js&apos; &#125;&#125; Output用来告诉 webpack 如何将编译后的文件输出到磁盘 123456module.exports = &#123; output: &#123; filename: &apos;[name].js&apos;, // 通过占位符确保文件名称的唯一 path: __dirname + &apos;/dist&apos;, // 输出的目录 &#125;&#125; Loaders本身是一个函数，接受源文件作为参数，返回转换的结果 常见的 Loaders 名称 描述 babel-loader 转换 ES6、ES7 等 JS 新特性语法 css-loader 支持 .css 文件的加载和解析 less-loader 将 less 文件转换成 css ts-loader 将 TS 转换成 JS file-loader 将图片、字体等打包 raw-loader 将文件以字符串的形式导入 thread-loader 多线程打包 JS 和 CSS 写法12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.txt$/, // 指定匹配规则 use: &apos;raw-loader&apos; // 指定使用的loader名称 &#125; ] &#125;,&#125; Plugins用于 bundle 文件的优化，资源管理和环境变量注入作用于整个构建过程 常见的 Plugins 名称 描述 CommonsChunkPlugin 将 chunks 相同的模块代码提取成公共 js CleanWebpackPlugin 清理构建目录 ExtractTextWebpackPlugin 将 CSS 从 bundle 文件里提取成一个独立的 CSS 文件 CopyWebpackPlugin 将文件或者文件拷贝到构建的输出目录 HtmlWebpackPlugin 创建 html 文件去承载输出的 bundle UglifyjsWebpackPlugin 压缩 JS ZipWebpackPlugin 将打包出的资源生成一个 zip 包 用法12345678910module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, chunks: [&apos;index&apos;], inject: true, &#125;) ]&#125; Mode用来指定当前的构建环境，可选值：production、development、none 设置 mode 可以使用 webpack 内置的函数，默认值为 production 选项 描述 development 设置 process.env.NODE_ENV的值为 development。 production 设置 process.env.NODE_ENV的值为 production。 none 不开启任何优化选项 development 开启 NamedChunksPluin 和 NamedModulesplugin。production 开启 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleContactenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin 解析 ES6 和 React JSX使用babel-loader，label 的配置文件是 .babelrc 12345678910111213141516171819202122// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: &apos;babel-loader&apos; &#125; ] &#125;&#125;// 安装@babel/core、@babel/preset-env和@babel/proposal-class-properties// .babelrc&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, // 增加ES6的babel preset配置 ], &quot;plugins&quot;: [ &quot;@babel/proposal-class-properties&quot; ]&#125; 解析 CSS使用 css-loader 用于加载 .css 文件，并且转换成 commonjs 对象使用 style-loader 将样式通过 &lt;style&gt; 标签插入到 head 中 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;&#125; 解析 Less 和 Sassless-loader / sass-loader 用于将 less / sass 转换成 css 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos; ] &#125; ] &#125;&#125; 资源解析：解析图片、字体1234567891011121314151617181920212223242526272829module.exports = &#123; module: &#123; rules: [ // file-loader 处理图片和字体 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos;, ] &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos;, ] &#125;, // url-loader 处理图片和字体，可以设置较小资源自动转换为base64 &#123; test: /\\.(png|svg|jpg|gif)$/, use: [&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 10240 &#125; &#125;] &#125;, ] &#125;&#125; 文件监听监听文件发生变化时，自动重新构建出新的文件 webpack 开启监听模式： 启动 webpack 命令时，带上 --watch参数 123456// package.json&#123; &quot;scripts&quot;: &#123; &quot;watch&quot;: &quot;webpack --watch&quot; &#125;&#125; 缺陷：需要手动刷新浏览器 在配置 webpack.config.js 中设置 watch 为 true 文件监听的原理：轮询判断文件的最后编辑时间是否变化如果某个文件发生了变化，并不会立刻告诉监听者，而是缓存起来，等待 aggregateTimeout 12345678910111213module.exports = &#123; // 默认false，不开启 watch: true, // 监听相关配置 watchOptions: &#123; // 默认为空，不监听的文件或文件夹，支持正则 ignored: /node_modules/, // 默认300，监听到文件变化后，执行编译的间隔时间 aggregateTimeout: 300, // 默认1000，每秒进行文件轮询检测的次数 poll: 1000, &#125;&#125; 热更新webpack-dev-server借助 webpack 的 HotModuleReplacementPlugin 插件 特点： 不刷新浏览器 不输出文件，存放在内存中 123456789101112131415161718// package.json&#123; &quot;script&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open&quot; &#125;&#125;// webpack.config.jsmodule.exports = &#123; mode: &apos;development&apos;, plugins: [ new webpack.HotModuleReplacementPlugin() ], devServer: &#123; contentBase: &apos;./dist&apos;, hot: true &#125;&#125; webpack-dev-middleware将 webpack 输出的文件传输给服务器 特点：适用于灵活的定制场景 123456789101112131415const express = require(&apos;express&apos;);const webpack = require(&apos;webpack&apos;);const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;);const app = express();const config = require(&apos;./webpack.config.js&apos;);const compiler = webpack(config);app.use(webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath,&#125;));app.listen(3000, function() &#123; console.log(&apos;Example app listening on port 3000\\n&apos;);&#125;) 热更新原理 文件指纹打包后输出的文件名后缀 hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改 chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值 contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变 123456789101112131415161718192021222324252627282930313233343536const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; ourput: &#123; filename: &apos;[name][chunkhash:8].js&apos;, path: __dirname + &apos;/dist&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos; ] &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &#123; loader: &apos;file-loader&apos;, options: &#123; name: &apos;img/[name][hash:8].[ext]&apos; &#125; &#125; ] &#125; ] &#125;, plugins: [ // 将css抽取成独立文件的插件 new MiniCssExtractPlugin(&#123; filename: &apos;[name][contenthash:8].css&apos; &#125;) ]&#125; 占位符名称 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件的相对路径 [folder] 文件所在的文件夹 [contenthash] 文件的内容 hash，默认时 md5 生成 [hash] 文件的内容 hash，默认时 md5 生成 [emoji] 一个随机的指代文件内容的 emoji 代码压缩JS 文件的压缩内置了 uglifyjs-webpack-plugin CSS 文件压缩使用 optimize-css-assets-webpack-plugin，同时使用 cssnano 12345678module.exports = &#123; plugins: [ new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /\\.css$/, cssProcessor: require(&apos;cssnano&apos;), // css处理器 &#125;) ]&#125; HTML 文件压缩修改 html-webpack-plugin，设置压缩参数 1234567891011121314module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; html5: true, collapseWhitespace: true, preseveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false, &#125; &#125;) ]&#125;","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"webpack","slug":"webpack","permalink":"https://xuehongjie.github.io/tags/webpack/"},{"name":"极客时间","slug":"极客时间","permalink":"https://xuehongjie.github.io/tags/极客时间/"}]},{"title":"玩转webpack-webpack简介","slug":"front-end/geektime/webpack/introdution","date":"2020-03-28T11:10:54.000Z","updated":"2020-03-28T15:24:24.425Z","comments":true,"path":"front-end/geektime/webpack/introdution/","link":"","permalink":"https://xuehongjie.github.io/front-end/geektime/webpack/introdution/","excerpt":"","text":"初识 webpack配置文件名称webpack 默认配置文件：webpack.config.js 可以通过 webpack --config 指定配置文件 webpack 配置组成1234567891011121314151617181920module.exports = &#123; entry: &apos;./src/index.js&apos;, // 打包的入口文件，webpack4的默认值./src/index.js output: &apos;./dist/main.js&apos;&apos;, // 打包的输出 ，webpack4的默认值./dist/main.js mode: &apos;production&apos;, // 环境 // loader配置 module: &#123; rules: [ &#123; test: /\\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, // 插件配置 plugins: [ new HtmlwebpackPlugin(&#123; template: &apos;./src/index.html&apos;, &#125;) ]&#125; 安装 webpack安装 nvmnvm git 地址 通过 curl安装curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 通过 wget 安装wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 安装 Node.js 和 NPM nvm install v10.15.3 检查是否安装成功：node -v，npm -v 创建空目录和 package.json mkdir my-project cd my-project npm init -y 安装 webpack 和 webpack-cli npm install webpack webpack-cli --save-dev 检查是否安装成功：./node_modules/.bin/webpack -v","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"webpack","slug":"webpack","permalink":"https://xuehongjie.github.io/tags/webpack/"},{"name":"极客时间","slug":"极客时间","permalink":"https://xuehongjie.github.io/tags/极客时间/"}]},{"title":"Chrome调试技巧-network","slug":"front-end/other/chrome-skill/network","date":"2020-01-10T20:20:25.000Z","updated":"2020-03-08T16:35:18.444Z","comments":true,"path":"front-end/other/chrome-skill/network/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/chrome-skill/network/","excerpt":"","text":"隐藏请求的时间轴 隐藏请求时间轴 过滤请求 过滤请求 例如输入method:或者mime-type:如果想要显示所有可能的关键字，在空白的输入框按下 [ctrl] + [space] 自定义请求表 自定义请求表 重新发送XHR请求右击请求，选择replay XHR 给XHR/fetch 加断点打开source面板 请求增加断点","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://xuehongjie.github.io/tags/chrome/"}]},{"title":"Chrome调试技巧-console","slug":"front-end/other/chrome-skill/console","date":"2020-01-08T20:56:20.000Z","updated":"2020-03-07T14:36:10.206Z","comments":true,"path":"front-end/other/chrome-skill/console/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/chrome-skill/console/","excerpt":"","text":"$0 - $4Elements面板中当前选中的DOM，$1为上一次的选中，以此类推一直到$4 $和$$ $：和document.querySelector相同 $$：和document.querySelectorAll相同 $_上次执行结果的引用 异步的consoleconsole默认被async包裹 查看Storage系统的占用数和空闲数await navigator.storage.estimate() 查看设备的电池信息await navigator.getBattery() 查看设备的媒体能力12let query = &#123;type: &apos;file&apos;, audio: &#123;contentType: &apos;audio/ogg&apos;&#125;&#125;await navigator.mediaCapabilities.decodingInfo(query) 条件断点 右击行号，选择 Add conditional breakpoint...(添加条件断点) 或者右击一个已经设置的断点并且选择 Edit breakpoint(编辑断点) 然后输入一个执行结果为 true 或者 false 的表达式，符合条件则进入断点，如i === 3。 queryObjects对象查询1234567891011121314151617class Person &#123; constructor(name, role) &#123; this.name = name; this.role = role; &#125;&#125;const john = new Person(&apos;John&apos;, &apos;dad&apos;);let kids = [ new Person(&apos;Mary&apos;, &apos;kid&apos;), new Person(&apos;Luke&apos;, &apos;kid&apos;),]new Person(&apos;Lucius&apos;, &apos;uncle&apos;); // 不可用，没有变量缓存下来console.log(&apos;How many people are do we have?&apos;)console.log(queryObjects(Person)) console的骚操作console.assert当我们传入的第一个参数为假时，console.assert打印跟在这个参数后面的值。12let a = 1console.assert(a === 2, &apos;no equal&apos;); // Assertion failed: no equal NodeJS 版本 ≤ 10.0，console.assert 可能会中断后面代码的执行 console.table12将数组/对象以表格的形式打印出来，第二个参数表示过滤要打印出来的列console.table($$(&apos;li&apos;), [&apos;title&apos;]) console.dir123456let obj = &#123; a: 1, b: 2, c: 3,&#125;console.dir(obj) console.dir 给输出内容加上时间戳ctrl + p → 输入&gt; timestamps，选择Show timestamps，要关闭则选择Hide timestamps 命令面板 timestamps 监听执行时间 console.time(name)：开启一个计时器 console.timeEnd(name)：结束计时器并打印结果 name为计时器的名称 123456console.time(&apos;first&apos;);// 1秒后打印出执行的时间setTimeout(() =&gt; &#123; console.timeEnd(&apos;first&apos;); // first: 1000.477783203125ms&#125;, 1000); 给console.log加样式console.log(&quot;%c红色字体！&quot;,&quot;color: red; font-size: 20px&quot;); 修改console.log样式 实时表达式 打开实时表达式 表达式监听变化","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://xuehongjie.github.io/tags/chrome/"}]},{"title":"Chrome调试技巧-通用","slug":"front-end/other/chrome-skill/common","date":"2020-01-05T22:06:28.000Z","updated":"2020-03-08T09:40:00.522Z","comments":true,"path":"front-end/other/chrome-skill/common/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/chrome-skill/common/","excerpt":"","text":"copy 和 savecopy这是一个全局的方法，可以通过如copy(location)的方式将loation对象拷贝到粘贴板中 拷贝location对象 Store as global将console打印的数据存储为一个全局变量，在要存储的数据上右键打开菜单面板，选择Store as global variable 第一次使用会自动创建temp1，第二次创建temp2，以此类推 保存堆栈信息在控制台右键打开菜单面板，选择save as存储为文件 复制HTML切换至Elements页签，选中要复制的元素 点击元素边上的省略号 → copy → copy element → 复制成功 ctrl + c → 复制成功 控制台快捷键切换控制台位置ctrl + shift + D 切换控制台面板 ctrl + [和ctrl + ] ctrl + 1到ctrl + 9，该快捷键默认被禁用，可以通过DevTools → Settings → Prefernces → Appearance → Enable Ctrl + 1-9 shortcut to switch panels打开 命令面板ctrl + shift + p打开命令面板 截屏打开命令面板 DOM元素，Capture node screenshot 全屏Capture full size screenshot 主题切换 切换到亮主题 switch to light theme 切换到暗主题 switch to dark theme 代码块 代码块 新建点击new snippet新建代码块 执行ctrl + p，输入!代码块名称运行代码块","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://xuehongjie.github.io/tags/chrome/"}]},{"title":"uni-app踩坑日记","slug":"front-end/framework/uni-app","date":"2019-05-15T22:30:20.000Z","updated":"2020-03-01T16:05:50.675Z","comments":true,"path":"front-end/framework/uni-app/","link":"","permalink":"https://xuehongjie.github.io/front-end/framework/uni-app/","excerpt":"","text":"官网 设置别名 设置tsconfig.json文件中的paths字段12345678&quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;./src/*&quot; ], &quot;ajax/*&quot;: [ &quot;./src/ajax/*&quot; ]&#125; 组件onLoad不生效使用created代替 自定义导航栏设置pages.json文件中的路由&quot;navigationStyle&quot;: &quot;custom&quot; 修改自定义组件的样式修改方法同vue，使用深度选择器/deep/或者&gt;&gt;&gt;，1234567891011121314151617181920212223242526272829303132333435// child&lt;view class=&quot;child-class&quot;&gt; child&lt;/view&gt;// parent&lt;view class=&quot;container&quot;&gt; &lt;component-a class=&quot;parent-class&quot;&gt;&lt;/component-a&gt;&lt;/view&gt;// 编译后的小程序代码，uni-app编译后会自动给子组件套多一层&lt;view class=&quot;parent-class&quot;&gt; &lt;view class=&quot;child-class&quot;&gt;&lt;/view&gt;&lt;/view&gt;// 方法一.parent-class &#123; /deep/ .child-class &#123; color: red; &#125;&#125;// 方法二/deep/ .child-class &#123; color: red;&#125;// 新版uni-app可以通过该方式修改组件样式，旧版本待验证/deep/ &#123; .container &#123; .child-class &#123; color: red; &#125; &#125;&#125; 引入第三方组件不可修改其样式 二次封装的组件通过deep修改 嵌套了2层以上的组件利用deep修改不生效，需要在第一个父级页面通过deep修改其样式，否则不生效(旧版) 记录 自定义组件在props中不允许定义data wx.getMenuButtonBoundingClientRect的bottom为顶部到胶囊按钮下边距的距离(right同bottom) $emit第二次参数无法传入多个，只有第一个有值 可以使用$set触发视图的刷新 元素的margin设置负值展示会不对，尽量使用padding来代替 问题编译后uni-app样式和组件都不生效因为之前在package.json中加了cross-env文件，将其删除，然后删除node_modules和package-lock.json文件，然后重新使用npm install进行安装。 使用cnpm安装启动后会报错 Element implicitly has an ‘any’ type because expression of type ‘any’ can’t be used to index type设置strict为false12345&#123; &quot;compilerOptions&quot;: &#123; &quot;strict&quot;: false, &#125;&#125; 在组件中&lt;slot :list=&quot;listData&quot;&gt;&lt;/slot&gt;传值报Path must be a string. Received true 修改为slot，不使用作用域插槽，2.1.5暂时不支持作用域插槽 小程序下，使用:class=&quot;{disabled: !arr.length}不触发变化123456// 在computed定义值来替换arr.lengthcomputed: &#123; disabled() &#123; return !this.arr.length &#125;&#125; 非H5端在style中使用方法不生效1234567// 不生效&lt;view :style=&quot;getStyle&quot;&gt;&lt;/view&gt;&lt;view v-for=&quot;item in list&quot; :style=&quot;getStyle(item)&quot;&gt;&lt;/view&gt;// 生效&lt;view :style=&quot;[getStyle]&quot;&gt;&lt;/view&gt;&lt;view v-for=&quot;item in list&quot; :style=&quot;[getStyle(item)]&quot;&gt;&lt;/view&gt; 获取用户信息的弹窗点击允许不触发回调12345678910111213// 第一次直接使用uni.getUserInfo触发授权弹窗获取用户信息时会直接触发fail回调uni.getUserInfo(&#123; provider: &apos;weixin&apos;, success: (ret) =&gt; &#123; console.log(&apos;success&apos;) &#125;, fail: () =&gt; &#123; console.log(&apos;fail&apos;) &#125;&#125;)// 使用标签触发授权弹窗，点击允许后会触发getUserInfo方法&lt;button open-type=&quot;getUserInfo&quot; @getuserinfo=&quot;getUserInfo&quot;&gt;&lt;/button&gt; 用户信息和手机号码信息获取间隔超过5分钟后台登录接口会报错(没有在获取手机号码的页面获取用户信息)123// 获取手机号码后还需要获取用户信息// 触发获取手机授权回调后，先调用uni.login获取code，再调用uni.getUserInfo获取用户信息&lt;button open-type=&quot;getPhoneNumber&quot; @getphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt; button设置disabled后h5会冒泡自定义禁用样式，在点击事件中判断是否触发操作1234567&lt;button :disabled=&quot;disabled&quot; @tap.stop=&quot;handler&quot;&gt;按钮&lt;/button&gt;function handler() &#123; if (this.disabled) &#123; return &#125;&#125; 使用mixins不生效小程序中，mixin的components、onShow不生效 小程序记录 textarea在IOS下会有内边距问题（官方暂时没有提供解决方案） 生成小程序码12345678fly.post(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=$&#123;accessToken&#125;`, &#123; scene: &apos;123456&apos;, page: &apos;pages/home/case-detail&apos;,&#125;, &#123; responseType: &apos;arraybuffer&apos;,&#125;).then(res =&gt; &#123; return `data:image/jpg;base64,$&#123;uni.arrayBufferToBase64(res.data)&#125;`&#125;) 问题errcode: 41030，errmsg: “invalid page hint: [TwYBKA0094c393]”小程序需要发布后才能使用其他路径生成小程序码","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuehongjie.github.io/tags/vue/"},{"name":"小程序","slug":"小程序","permalink":"https://xuehongjie.github.io/tags/小程序/"}]},{"title":"设计模式","slug":"front-end/js/design-pattern","date":"2019-03-05T10:49:34.000Z","updated":"2019-03-10T07:27:42.178Z","comments":true,"path":"front-end/js/design-pattern/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/design-pattern/","excerpt":"","text":"原则 开闭原则：对扩展开放，对修改关闭 里氏转换原则：子类继承父类，单独调完全可以运行 依赖倒转原则：引用一个对象，如果这个对象有底层类型，直接引用底层 接口格力原则：每一个接口应该是一种角色 合成/聚合复用原则：新的对象应使用一些已有的对象，使之成为新对象的一部分 迪米特原则：一个对象应对其他对象有尽可能少的了解 单例模式保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了在返回。 作用 模块间通信 系统中某个类的对象只能存在一个 保护自己的属性和方法 注意事项 注意this的使用 闭包容易造成内存泄漏，不需要的赶快干掉 注意new的成本 示例1234567891011121314151617var Single = function( name )&#123; this.name = name;&#125;;Single.prototype.getName = function()&#123; alert ( this.name );&#125;;Single.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Single( name ); &#125; return instance; &#125;&#125;)(); 构造函数模式用于创建特定类型的对象。不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。 作用 用于创建特定类型的对象 第一次声明的时候给对象赋值 自己声明构造函数，赋予属性和方法 注意事项 声明函数的时候处理业务逻辑 区分和单例的区别，配合单例实现初始化 构造函数建议大写字母开头 注意new的成本 示例12345678function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;&#125; 建造者模式将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说用户只需要指定需要建造的类型就可以得到它们，不需要知道具体的建造过程和细节。 作用 分步创建一个复杂的对象 解耦封装过程和具体创建的组件 无需关心组件如何组装 注意事项 一定要一个稳定的算法进行支持 加工工艺是暴露的 示例123456789101112131415161718192021222324252627282930313233343536function Fangzi()&#123; this.woshi = &quot;&quot;; this.keting = &quot;&quot;; this.chufang = &quot;&quot;;&#125;function Baogongtou()&#123; this.gaifangzi = function(gongren)&#123; gongren.jian_woshi(); gongren.jian_keting(); gongren.jian_chufang(); &#125;&#125;function Gongren()&#123; this.jian_woshi = function()&#123; console.log(&quot;卧室我盖好了&quot;); &#125; this.jian_keting = function()&#123; console.log(&quot;客厅建好了&quot;); &#125; this.jian_chufang = function()&#123; console.log(&quot;厨房建好了&quot;); &#125; this.jiaogong = function()&#123; var _fangzi = new Fangzi(); _fangzi.woshi = &quot;ok&quot;; _fangzi.keting = &quot;ok&quot;; _fangzi.chufang = &quot;ok&quot;; return _fangzi; &#125;&#125;var gongren = new Gongren();var baogongtou = new Baogongtou();baogongtou.gaifangzi(gongren);//主人要房子var myfangzi = gongren.jiaogong();console.log(myfangzi); 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型(抽象工厂)。 简单工厂：直接处理。 抽象工厂：只留接口，不作处理。 作用1.对象的构建十分复杂。2.需要依赖具体的环境创建不同实例。3.处理大量具有相同属性的小对象。 注意事项1.不能滥用工厂，有时候仅仅是给代码增加复杂度。 示例12345678910111213141516171819202122232425262728293031323334353637// 简单工厂var XMLHttpFactory = function() &#123;&#125;XMLHttpFactory.createXMLHttp = function() &#123; var XMLHttp = null; if(window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest() &#125; else if(window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;) &#125; return XMLHttp&#125;var ajaxHandler = function() &#123; var XMLHttp = XMLHttpFactory.createXMLHttp()&#125;// 抽象工厂var XMLHttpFactory = function() &#123;&#125;XMLHttpFactory.prototype = &#123; createFactory: function() &#123; throw new Error(&apos;This is a abstract class&apos;) &#125;&#125;var XHRHandler = function() &#123; XMLHttpFactory.call(this)&#125;XHRHandler.prototype = new XMLHttpFactory()XHRHandler.prototype.constructor = XHRHandlerXHRHandler.prototype.createFactory = function() &#123; var XMLHttp = null; if(window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest() &#125; else if(window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;) &#125; return XMLHttp&#125; 外观模式为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。 作用 在设计初期，应该要有意识地将不同的两个层分离， 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观F可以提供一个简单的接口，减少他们之间的依赖 在维护一个遗留的大型系统时，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互 注意事项外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性 观察者模式又称为发布订阅模式(Publish/Subscribe)，它定义了一种一对多的关系，让多个观察者对象同事监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 作用 支持简单的广播通信，自动通知所有已经订阅过的对象 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用 注意事项监听要在触发之前","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"}]},{"title":"极客重学前端的记录","slug":"front-end/other/relearning-front-end","date":"2019-03-02T23:11:31.000Z","updated":"2019-03-10T16:12:05.578Z","comments":true,"path":"front-end/other/relearning-front-end/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/relearning-front-end/","excerpt":"","text":"JavaScript数据类型 Undefined Null Boolean String 最大长度2^53 - 1 Number 1231 / -0 // -InfinityMath.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON // truetypeof new Number(&apos;3&apos;) // object Symbol 1234567891011121314自定义iterator行为 var o = new Object o[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125; &#125;; for(var v of o) console.log(v); // 0 1 2 3 ... 9 Object 类型转换 类型转换 装箱转换 把基本类型转换为对应的对象，new Number(‘3’)Symbol无法使用new来调用，但是可以利用装箱机制来得到一个Symbol对象12345678910// 利用call方法强迫产生装箱let symbolObject = (function()&#123; return this; &#125;).call(Symbol(&apos;a&apos;));// 使用内置Object显示调用装箱let symbolObject = Object(Symbol(&apos;a&apos;))console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //trueconsole.log(Object.prototype.toString.call(symbolObject)); //[object Symbol] 装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，应避免对基本类型做装箱转换 拆箱转换 把对象类型转换为基本类型拆箱转换会尝试调用valueOf和toString来获得拆箱后的基本类型。如果valueOf和toString都不存在，或者没有返回基本类型，则会产生类型错误TypeError。12345678910111213141516var o = &#123; valueOf : () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;&#125;o * 2// valueOf// toString// TypeError// ES6之后，允许对象通过显式指定toPrimitive Symbol来覆盖原有的行为o[Symbol.toPrimitive] = () =&gt; &#123;console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;&#125;console.log(o + &quot;&quot;)// toPrimitive// hello 对象的两类属性 数据属性 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 访问器(getter/setter)属性 getter：函数或 undefined，在取属性值时被调用。 setter：函数或 undefined，在设置属性值时被调用。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 设置/获取对象的属性12345678910111213var o = &#123; a: 1 &#125;;Object.defineProperty(o, &quot;b&quot;, &#123; value: 2, writable: false, enumerable: false, configurable: true&#125;);//a 和 b 都是数据属性，但特征值变化了Object.getOwnPropertyDescriptor(o,&quot;a&quot;); // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o,&quot;b&quot;); // &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;o.b = 3;console.log(o.b); // 2 操纵原型的API Object.create根据指定的原型创建新对象，原型可以是 null Object.getPrototypeOf获得一个对象的原型 Object.setPrototypeOf设置一个对象的原型 new的过程 以构造器的 prototype 属性（注意与私有字段 [[prototype]]的区分）为原型，创建新对象； 将this和调用参数传给构造器，执行； 如果构造器返回的是对象，则返回，否则返回第一步创建的对象 获取类型 12345678910111213141516171819202122var o = new Object;var n = new Number;var s = new String;var b = new Boolean;var d = new Date;var arg = function()&#123; return arguments &#125;();var r = new RegExp;var f = new Function;var arr = new Array;var e = new Error;console.log([o, n, s, b, d, arg, r, f, arr, e].map(v =&gt; Object.prototype.toString.call(v)));0: &quot;[object Object]&quot;1: &quot;[object Number]&quot;2: &quot;[object String]&quot;3: &quot;[object Boolean]&quot;4: &quot;[object Date]&quot;5: &quot;[object Arguments]&quot;6: &quot;[object RegExp]&quot;7: &quot;[object Function]&quot;8: &quot;[object Array]&quot;9: &quot;[object Error]&quot; 修改数据类型 12var o = &#123; [Symbol.toStringTag]: &quot;MyObject&quot; &#125;console.log(o + &quot;&quot;); // [object MyObject] 对象分类 宿主对象：由JavaScript宿主环境提供的对象 内置对象：由JavaScript语言提供的对象 固有对象：随着JavaScript运行时创建而自动创建的对象实例 原生对象：可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象 普通对象：由{}语法、Object构造器或者class关键字定义类创建的对象，它能够被原型继承 原生对象 利用构造器实现私有变量123456789function cls()&#123; this.a = 100; return &#123; getValue:() =&gt; this.a &#125;&#125;var o = new cls;o.getValue(); //100//a 在外面永远无法访问到 CSSat规则 @charset @import @media @page @counter-style @keyframes @fontface @supports @namespace","categories":[],"tags":[]},{"title":"小程序","slug":"front-end/wx/miniprogram","date":"2019-02-26T22:15:22.000Z","updated":"2019-03-13T11:09:22.581Z","comments":true,"path":"front-end/wx/miniprogram/","link":"","permalink":"https://xuehongjie.github.io/front-end/wx/miniprogram/","excerpt":"","text":"https://www.jianshu.com/p/635714eabcbc使用mpvue首次加载小程序时，所有页面的beforeCreate、created会全部执行页面会被缓存 问题报错调用login接口时ERR_REQUEST_PARAM1234在config中增加参数qcloudAppId: &apos;你的腾讯云 AppID&apos;,qcloudSecretId: &apos;你的腾讯云 SecretId&apos;,qcloudSecretKey: &apos;你的腾讯云 SecretKey&apos;, https://github.com/tencentyun/wafer2-quickstart/issues/13 getLocation需要在app.json中声明permission字段123456在app.json中添加&quot;permission&quot;: &#123; &quot;scope.userLocation&quot;: &#123; &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot; &#125;&#125;","categories":[],"tags":[{"name":"wx","slug":"wx","permalink":"https://xuehongjie.github.io/tags/wx/"},{"name":"miniprogram","slug":"miniprogram","permalink":"https://xuehongjie.github.io/tags/miniprogram/"}]},{"title":"apply、call、bind","slug":"front-end/js/apply-call-bind","date":"2019-02-25T21:11:07.000Z","updated":"2019-03-03T16:06:09.603Z","comments":true,"path":"front-end/js/apply-call-bind/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/apply-call-bind/","excerpt":"","text":"apply改变某个函数运行时的上下文（context），即改变函数体内部this的指向12// 第二个参数为数组Math.max.apply(Math, [1, 2, 3]) call作用同apply12// 传入参数列表Math.max.call(Math, 1, 2, 3) bind123let getMax = Math.max.bind(Math)// 传入参数列表getMax(1, 2, 3) https://www.cnblogs.com/moqiutao/p/7371988.htmlhttps://blog.csdn.net/lovefengruoqing/article/details/80186401","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"}]},{"title":"mysql","slug":"back-end/database/mysql","date":"2019-02-23T10:20:31.000Z","updated":"2019-02-25T16:15:40.262Z","comments":true,"path":"back-end/database/mysql/","link":"","permalink":"https://xuehongjie.github.io/back-end/database/mysql/","excerpt":"","text":"安装windowhttp://www.runoob.com/mysql/mysql-install.html 下载安装包(https://dev.mysql.com/downloads/mysql/) 在bin目录下运行./mysqld --initialize --console 安装mysqlmysqld install 操作mysql8修改密码https://www.cnblogs.com/xyabk/p/8967990.html 记录查看表的创建语法show create table 表名 报错执行mysqld install提示Install/Remove of the Service Denied!在C:\\Windows\\System32的目录下找到cmd.exe 右键已管理员身份运行。进入mysql的bin目录重新运行mysqld install You must reset your password using ALTER USER statement before executing this statement MySQL版本5.7.6版本以前用户可以使用如下命令： SET PASSWORD = PASSWORD(&#39;Xiaoming250&#39;); MySQL版本5.7.6版本开始的用户可以使用如下命令： ALTER USER USER() IDENTIFIED BY &#39;Xiaoming250&#39;; Client does not support authentication protocol requested by server123use mysql;alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;1234&apos;;flush privileges; Unknown database ‘cauth’create database cAuth","categories":[],"tags":[{"name":"database","slug":"database","permalink":"https://xuehongjie.github.io/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://xuehongjie.github.io/tags/mysql/"}]},{"title":"koa","slug":"back-end/node/koa","date":"2019-02-22T23:47:31.000Z","updated":"2019-02-23T03:54:44.478Z","comments":true,"path":"back-end/node/koa/","link":"","permalink":"https://xuehongjie.github.io/back-end/node/koa/","excerpt":"","text":"初始化1234const Koa = require(&apos;koa&apos;)const app = new Koa()app.listen(3000) 中间件执行顺序1234567891011121314151617181920212223242526app.use(async(ctx, next) =&gt; &#123; ctx.body = &apos;1&apos; next() // 执行下一个中间件，异步 ctx.body += &apos;2&apos;&#125;)app.use(async(ctx, next) =&gt; &#123; ctx.body += &apos;3&apos; next() ctx.body += &apos;4&apos;&#125;)输出结果 1342app.use(async(ctx, next) =&gt; &#123; ctx.body = &apos;1&apos; ctx.body += &apos;2&apos;&#125;)app.use(async(ctx, next) =&gt; &#123; ctx.body += &apos;3&apos; next() ctx.body += &apos;4&apos;&#125;)输出结果12","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://xuehongjie.github.io/tags/node/"},{"name":"koa","slug":"koa","permalink":"https://xuehongjie.github.io/tags/koa/"}]},{"title":"nginx","slug":"back-end/nginx/nginx","date":"2019-02-22T10:20:31.000Z","updated":"2019-02-21T14:12:17.713Z","comments":true,"path":"back-end/nginx/nginx/","link":"","permalink":"https://xuehongjie.github.io/back-end/nginx/nginx/","excerpt":"","text":"location location = patt {} 精准匹配 location patt {} 一般匹配 location ~ patt {} 正则匹配 匹配过程 有没有精准匹配，有则停止匹配 定位流程123456789location = / &#123; root html index index.htm index.html&#125;location / &#123; root html2 index index.html index.htm&#125; 精准匹配中/，得到index页为index.htm 再次访问/index.htm，此次内部跳转uri已经是index.htm，根目录为html2 最终访问了html2 123456789location / &#123; root html index index.html index.htm&#125;location ~ image &#123; root image index index.html index.htm&#125; 记录查看错误日志在nginx目录下tail logs/error.log","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://xuehongjie.github.io/tags/nginx/"}]},{"title":"promise","slug":"front-end/js/promise","date":"2019-02-21T11:47:31.000Z","updated":"2019-03-05T15:06:17.712Z","comments":true,"path":"front-end/js/promise/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/promise/","excerpt":"","text":"手动写一个promise12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyPromise &#123; constructor(fn) &#123; this.state = &apos;PENDING&apos; this.doneList = [] this.failList = [] fn(this.resolve.bind(this), this.reject.bind(this)) &#125; done(handle) &#123; if (typeof handle === &apos;function&apos;) &#123; this.doneList.push(handle) &#125; else &#123; throw new Error(&apos;the handle is miss&apos;) &#125; return this &#125; fail(handle) &#123; if (typeof handle === &apos;function&apos;) &#123; this.failList.push(handle) &#125; else &#123; throw new Error(&apos;the handle is miss&apos;) &#125; return this &#125; then(success, fail) &#123; this.done(success || function() &#123;&#125;).fail(fail || function() &#123;&#125;) return this &#125; always(handle) &#123; this.done(handle || function() &#123;&#125;).fail(handle || function() &#123;&#125;) return this &#125; resolve() &#123; this.state = &apos;RESOLVED&apos; let args = Array.prototype.slice.call(arguments) setTimeout(function() &#123; this.doneList.forEach((item, key, arr) =&gt; &#123; item.apply(null, args) arr.shift() &#125;) &#125;.bind(this), 200) &#125; reject() &#123; this.state = &apos;REJECT&apos; let args = Array.prototype.slice.call(arguments) setTimeout(function() &#123; this.failList.forEach((item, key, arr) =&gt; &#123; item.apply(null, args) arr.shift() &#125;) &#125;.bind(this), 200) &#125;&#125; 参考链接https://www.jianshu.com/p/43de678e918a","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://xuehongjie.github.io/tags/promise/"}]},{"title":"gulp","slug":"front-end/tools/gulp","date":"2019-02-17T12:50:23.000Z","updated":"2019-02-17T04:53:21.243Z","comments":true,"path":"front-end/tools/gulp/","link":"","permalink":"https://xuehongjie.github.io/front-end/tools/gulp/","excerpt":"","text":"报错gulp: Did you forget to signal async completion?使用done1234gulp.task(&apos;default&apos;, done =&gt; &#123; console.log(&apos;Hello World!&apos;); done();&#125;);","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"gulp","slug":"gulp","permalink":"https://xuehongjie.github.io/tags/gulp/"}]},{"title":"SPA、SEO、SSR","slug":"front-end/other/SPA-SEO-SSR","date":"2019-02-13T21:58:39.000Z","updated":"2019-03-03T15:53:59.703Z","comments":true,"path":"front-end/other/SPA-SEO-SSR/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/SPA-SEO-SSR/","excerpt":"","text":"SPA单页面应用(Single Page Application) 优缺点优点： 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等 缺点： 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。 不利于SEO SEO搜索引擎优化(Search Engine Optimization)，用于提高该网站在搜索引擎中某些关键词的搜索结果排名 SSR服务端渲染(Server-Side Rendering) 优缺点优点： 更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了 更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。 缺点： 相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序会占用更多的CPU和内存资源 一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。 参考链接","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://xuehongjie.github.io/tags/other/"}]},{"title":"linux","slug":"back-end/linux/linux","date":"2019-01-31T21:58:39.000Z","updated":"2019-03-11T11:38:07.701Z","comments":true,"path":"back-end/linux/linux/","link":"","permalink":"https://xuehongjie.github.io/back-end/linux/linux/","excerpt":"","text":"处理目录的常用命令 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 rm(移除文件或目录) f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； i ：互动模式，在删除前会询问使用者是否动作 r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 查看文件的安装版本 rpm -qa 文件名 磁盘管理检查文件系统的磁盘空间占用情况 df [-ahikHTm] [目录或文件名] a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； k ：以 KBytes 的容量显示各文件系统； m ：以 MBytes 的容量显示各文件系统； h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； H ：以 M=1000K 取代 M=1024K 的进位方式； T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 查看文件安装所在路径 whereis node 查看运行文件所在路径 which node Centos7安装nginx安装nginx环境 yum install -y gcc-c++ yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 编译安装(路径可根据个人需求进行修改) cd /usr/local 下载nginx: wget http://nginx.org/download/nginx-1.14.1.tar.gz 解压nginx: tar zxvf nginx-1.14.1.tar.gz 进入解压目录: cd nginx-1.14.1 设置安装目录和ssl配置: ./configure –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module 安装nginx: make &amp;&amp; make install 进入nginx目录: cd /usr/local/nginx/sbin 启动服务: ./nginx ssl证书文件需要放在nginx/conf下面 例子例子2 nginx常用命令 nginx 启动 nginx -s reload 重启 nginx -s quit 关闭 安装node网络查看端口是否被占用netstat -anp |grep 端口号 报错解决nginx: [emerg] the “ssl” parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://xuehongjie.github.io/tags/linux/"}]},{"title":"webpack","slug":"front-end/tools/webpack","date":"2019-01-24T23:21:54.000Z","updated":"2019-02-17T04:55:03.741Z","comments":true,"path":"front-end/tools/webpack/","link":"","permalink":"https://xuehongjie.github.io/front-end/tools/webpack/","excerpt":"","text":"api webpack打包模块的源代码 把所有模块的代码放入到函数中，用一个数组保存起来 根据require时传入的数组索引，能知道需要哪一段代码 从数组中，根据索引取出包含我们代码的函数 执行该函数，传入一个对象 module.exports 我们的代码，按照约定，正好是用module.exports = ‘’进行赋值 调用函数结束后，module.exports从原来的空对象，就有值了 最终return module.exports作为require函数的返回值 配置配置参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // 入口文件 entry: &#123; main: &apos;./main.js&apos; main2: &apos;./main2.js&apos; &#125;, // 编译后文件 output: &#123; // 指定产出的目录 path: path.resolve(&apos;./dist&apos;), // 指定文件名 filename: &apos;[name].js&apos;, &#125;, watch: true, // 是否监听变动 module: &#123; // webpack后面版本可以叫做rules loaders: [ // 处理css &#123; test: /.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, // 小于限制范围则生成base64到build.js中，大于则生成图片 &#123; test: /.(jpg|jpeg|png|gif|svg)$/, loader: &apos;url-loader?limit=1024&apos; &#125;, // 处理less文件 &#123; test: /.less$/, loader: &apos;style-loader!css-loader!less-loader&apos; &#125;, // 处理ES6,7,8 &#123; test: /.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/, // 不打包node_modules目录下的文件 options: &#123; presets: [&apos;env&apos;], // 指定处理关键字 plugins: [&apos;transform-runtime&apos;], // 处理函数 &#125; &#125;, // 处理.vue文件 &#123; test: /.vue$/, loader: &apos;vue-loader&apos;, &#125;, ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, // 生成相对dist的html文件名 template: &apos;./src/index.html&apos;, // 模板生成的参照物 inject: true, // 是否添加到html，默认为true minify: &#123; removeComments: true, // 是否移除注释 collapseWhitespace: true, // 是否移除空格 removeAttributeQuotes: true, // 是否删除不需要引号的值 &#125;, // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本 chunks: [&apos;manifest&apos;, &apos;vendor&apos;, filename], chunksSortMode: &apos;dependency&apos; &#125;) ], resolve: &#123; // 自动解析扩展，能够使用户在引入模块时不带扩展 extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], // 别名 alias: &#123; &apos;@&apos;: path.join(__dirname, &apos;..&apos;, dir)(&apos;src&apos;) &#125; &#125;&#125; 图片转成base64时，大小会增加图片的三分之一，即如果图片为9K，打包后build.js增加12K的大小 webpack快捷命令 --config webpack.dev.config.js 指定编译时要运行的配置文件 --watch 监听文件改变 --process 显示编译进度 webpack-dev-server快捷命令 --open 自动打开浏览器 --hot 热替换，不刷新的情况下替换，主要用于css的变更 --inline 自动刷新 --port 8888 指定端口 定义全局变量12345plugins:[ new webpack.ProvidePlugin(&#123; $:&apos;jquery&apos; &#125;)] scss文件提取到独立文件(loader中的配置)12ExtractTextPlugin.extract(&#123;fallback:&apos;style-loader&apos;,use:&apos;css-loader!postcss-loader!sass-loader&apos;&#125;)ExtractTextPlugin.extract(&#123;fallback:&apos;style-loader&apos;,use:[&apos;css-loader&apos;, &#123;loader: &apos;postcss-loader&apos;, options: &#123;sourceMap: true&#125;&#125;, &apos;sass-loader&apos;]&#125;) scss文件提取到独立文件(plugins中的配置)new ExtractTextPlugin(‘styles.[contentHash:8].css’) vue的scss样式提取到独立文件options:{loaders:{scss:ExtractTextPlugin.extract({fallback:’vue-style-loader’,use:’css-loader!postcss-loader!sass-loader})}} 使用sourcemap才可以在浏览器中调试 使用全局变量12345&#123;test: resolve(&apos;src/utils/index&apos;),use:[&#123;loader:&apos;expose-loader&apos;,options: &apos;Utils&apos; //全局变量名&#125;]&#125; 设置路径~assets相当于src/assets config/index.js文件中的assetsPublicPath属性需要根据服务器的路径来进行设置如果后台服务器的路径不是 / ，需要设置build.assetsPublicPath属性，如：后台路径为http://localhost:4100/pl-mls/car-run-activity.html，则设置该值为pl-mls/如果mode为hash，则不需要修改vue-router的配置如果mode为history，需要在vue-router中设置base为/pl-mls/，dev.assetsPublicPath为’/‘ hash和chunkhash的区别 hash:整个应用对应同一个hash；不利于缓存 chunkhash:根据内容计算所得，每个entry单独对应一个hash；上线后无改动的文件不会失去缓存 常用loader css-loader，读取.css文件的内容 style-loader，将读取到的css内容插入到style标签 file-loader，将图片文件提取出来 url-loader(依赖file-loader)，将图片转为base64 devtool使用’#cheap-module-eval-source-map’ devServer1234567891011121314config.devServer:&#123; port:8080, // 端口号 host: &apos;0.0.0.0&apos;, // 地址 overlay:&#123; errors: true // 错误提示 &#125;, open: true, // 自动打开浏览器 hot: true, // 热加载，局部修改内容 historyFallback: &#123;&#125;&#125;config.plugins.push( new webpack.HotModuleReplacementPlugin() // 配合hot使用 new webpack.NoEmitOnErrorsPlugin() // 减少不必要的信息展示) 提取第三方资源到单独文件12345678entry: &#123; vendor: [&apos;vue&apos;]&#125;config.plugins.push( new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos; &#125;)) 打包优化查看项目打包(webpack-bundle-analyzer)webpack有个插件，可以查看项目一共打了多少包，每个包的体积，每个包里面的包情况。首先下载插件npm intall webpack-bundle-analyzer --save-dev同时在webpack.config.js配置123const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;webpackConfig.plugins.push(new BundleAnalyzerPlugin()); 在package.json中添加命令123&quot;script&quot;: &#123; &quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run deploy:prod&quot;&#125; webpack外部扩展引入CDN资源需要配置webpack，使其打包的时候不在将这些资源打包。1234567891011121314151617const webpackConfig = &#123; name: &apos;client&apos;, target: &apos;web&apos;, devtool: config.compiler_devtool, resolve: &#123; root: paths.client(), extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;, &apos;.json&apos;], &#125;, externals: &#123; &apos;react&apos;: &apos;React&apos;, &apos;react-dom&apos;: &apos;ReactDOM&apos;, &apos;react-router&apos;: &apos;ReactRouter&apos;, &apos;redux&apos;: &apos;Redux&apos;, &apos;history&apos;: &apos;History&apos; &#125;, module: &#123;&#125;,&#125; DLLdll 全称是：dynamic link library（动态链接库）dll方式也就是通过配置，告诉webpack指定库在项目中的位置，从而直接引入，不将其打包在内。上面介绍的方式是将包放到cdn上，build的时候不在引入对应的包；dll方式就是指定包在项目中，build的时候不在打包对应的包，使用的时候引入。webpack通过webpack.DllPlugin与webpack.DllReferencePlugin两个内嵌插件实现此功能。新建webpack.dll.config.js1234567891011121314151617181920const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; vendor: [&apos;vue&apos;, &apos;vue-router&apos;, &apos;vuex&apos;, &apos;axios&apos;, &apos;vuex-router-sync&apos;, &apos;mint-ui&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;../static&apos;), filename: &apos;[name].dll.js&apos;, library: &apos;[name]_library&apos; &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.resolve(__dirname, &apos;../[name]-manifest.json&apos;), name: &apos;[name]_library&apos;, context: __dirname &#125;) ]&#125; webpack.DllPlugin选项：path：manifest.json文件的输出路径，这个文件会用于后续的业务代码打包；name：dll暴露的对象名，要跟output.library保持一致;context：解析包路径的上下文，这个要跟接下来配置的 webpack.config.js 一致。运行文件运行：webpack –progress –colors –config build/webpack.dll.config.js生成两个文件，一个是打包好的vendor.dll.js，另外一个是vendor-mainifest.json配置webpack.config.js123456plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require(&apos;../vendor-manifest.json&apos;) &#125;)] webpack.DllReferencePlugin的选项中：context：需要跟之前保持一致，这个用来指导webpack匹配manifest.json中库的路径；manifest：用来引入刚才输出的manifest.json文件。生成vendor.dll.js文件后，在index.html中引入&lt;script src=&quot;./static/dll/vendor.dll.js&quot;&gt;&lt;/script&gt; 设置vue-cli打开网址可以通过localhost、本地ip地址访问使用devServer。设置host为0.0.0.0，或者在命令行中加入–host 0.0.0.0，修改open为false，通过opn模块打开网页地址不使用devServer。删除webpack.dev.conf.js文件中的devServer，新建server.js文件，在通过express建立服务器，使用opn打开网页地址 其他 zip-webpack-plugin压缩打包后的文件 安装babelbabel-loader babel-core 遍历获取文件名12345678910111213function getEntries(dirName)&#123; var jsDir＝path.join(srcDir,dirName), entriesFiles＝glob.sync(jsDir+&apos;/*/*.js&apos;), map＝&#123;&#125; entriesFiles.forEach(function()&#123; var fileName＝item.slice(item.lastIndexOf(&apos;\\/&apos;)+1,item.lastIndexOf(&apos;.&apos;)) if(process.env.NODE_ENV===&apos;dev&apos;)&#123; &#125;else&#123; map[fieName]=item &#125; &#125;)&#125; 报错‘cross-env’ 不是内部或外部命令，也不是可运行的程序或批处理文件。安装cross-env插件 cross-env NODE_ENV=test被 new webpack.DefinePlugin({‘process.env’: require(‘../config/dev.env’)}) 覆盖问题使用cross-env NODE_ENV只在编译代码中生效，不在项目代码中生效在config文件夹中新建test.env.js文件，定义其NODE_ENV为test，在调用webpack.DefinePlugin之前判断其process.env.NODE_ENV 使用node(8.x)版本运行npm install以后，如果切换到node(6.x)版本，build的时候会报错 使用vux框架，引用swiper插件打包时，ERROR in static/js/vendor.ca6b94cef1413d8d46f1.js from UglifyJs修改引用方式，将swiper改为swiper/dist/js/swiper webpack4https://www.cnblogs.com/carrotWu/p/8665720.htmlhttps://juejin.im/entry/5c302140f265da611b587f99 config/index.js相关说明https://www.cnblogs.com/whkl-m/p/6627864.html","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"webpack","slug":"webpack","permalink":"https://xuehongjie.github.io/tags/webpack/"}]},{"title":"Git","slug":"front-end/tools/git","date":"2019-01-23T22:08:19.000Z","updated":"2021-03-28T13:23:04.402Z","comments":true,"path":"front-end/tools/git/","link":"","permalink":"https://xuehongjie.github.io/front-end/tools/git/","excerpt":"","text":"参考资料 查看、配置用户信息设置全局用户信息(用户名和邮件)git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@xx.com&quot; 查看用户信息git config user.namegit config user.email 配置别名git config --global alias.st status 用st代替statusgit config --global alias.unstage &#39;reset HEAD&#39; 查看配置目录git config --list --show-origin 常用命令生成 git 版本库git init 克隆远程仓库到本地git clone [url] 添加文件到暂存区git add &lt;name&gt;-f 强制添加 提交暂存区文件到仓库区git commit -m 注释没有加-m 时会进入 vim，输入:wq 回车即可退出 修改注释(重新)git commit --amend -m 注释 查看状态git status 查看修改git diff &lt;name&gt; 查看日志git log加上–pretty=oneline 展示一行，输入 q 退出 log 版本重置1234git reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD^^ 回退到上上一个版本git reset --hard HEAD~100 回退100个版本git reset --hard 版本号 回退到某个版本 ###查看之前执行的每一次命令git reflog 撤销修改(可用于还原本地删除的文件)git checkout -- &lt;name&gt; 把暂存区的修改撤销掉(unstage),重新放回工作区git reset HEAD 文件名 还原单个文件git reset 提交Id &lt;name&gt;git checkout -- &lt;name&gt; 删除版本库的文件git rm &lt;name&gt;git commit -m &#39;message&#39; 关联远程仓库git remote add origin git@github.com:xuehongjie/git-demo.git 删除远程仓库git remote rm origin 修改远程仓库地址git remote set-url origin git@github.com:xuehongjie/git-demo.git 将本地文件推送到远程仓库git push -u origin master-u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令，git push即可。 分支创建 dev 分支，然后切换到 dev 分支：git checkout -b &lt;name&gt;相当于：git branch &lt;name&gt; git checkout &lt;name&gt; 创建分支git branch &lt;name&gt; 分支切换git checkout &lt;name&gt; 查看本地分支git branch 查看远程分支git branch -r // origin/master 查看本地和远程分支git branch -a 合并指定分支到当前分支git merge &lt;name&gt;–no-ff 表示禁用 Fast forward，普通模式合并，合并后的历史有分支，能看出来曾经做过合并 合并其他分支的某几个提交1234567891011// 合并其他分支的1个提交git cherry-pick &lt;commitHash&gt;// 合并其他分支的其中2个提交git chery-pick &lt;commitHash A&gt; &lt;commitHash B&gt;// 合并其他分支的某段提交，A 必须早于 B// 不包含 Agit chery-pick &lt;commitHash A&gt;..&lt;commitHash B&gt;// 包含 Agit chery-pick &lt;commitHash A&gt;^..&lt;commitHash B&gt; 删除分支git branch -d &lt;name&gt;git branch -D &lt;name&gt; 在没有合并的情况下强制删除 建立追踪关系，在现有分支和指定的远程分支之间git branch --set-upstream [branch] [remote-branc]最新版本使用git branch --set-upstream-to origin &lt;分支名&gt; 删除远程分支git push origin --delete &lt;branchname&gt;git push origin :&lt;branchname&gt;(推送空分支，相当于删除分支) 工作现场把当前工作现场“储藏”起来git stash 查看之前存储的工作现场git stash list 恢复工作现场，恢复后工作现场不会删除git stash apply 删除工作现场git stash drop 恢复的同时把 stash 内容也删了git stash pop 恢复指定的 stashgit stash apply stash@{0} 显示详细信息git remote -v 标签创建标签git tag &lt;name&gt;git tag &lt;name&gt; &lt;commit id&gt;给对应的 commit 添加标签，-a 指定标签名，-m 指定说明文字，-s 用私钥签名一个标签，签名采用 PGP 签名，因此，必须首先安装 gpg（GnuPG），如果没有找到 gpg，或者没有 gpg 密钥对，就会报错 查看所有标签git tag 查看标签信息git show &lt;tagname&gt; 删除标签git tag -d &lt;tagname&gt; 推送标签到远程git push origin &lt;tagname&gt; 一次性推送全部尚未推送到远程的本地标签git push origin -tags 删除远程标签先删除本地标签git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 其他创建 SSH Key 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell（Windows 下打开 Git Bash），创建 SSH Key：ssh-keygen -t rsa -C &quot;用户名&quot; 登陆 GitHub，打开“settings”，“SSH and GPG keys”页面：然后，点“New SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub(C:\\Users\\电脑用户名.ssh)文件的内容 查看本地 ssh 文件cat ~/.ssh/id_rsa.pub 让 git 显示颜色git config --global color.ui true 检查.gitignore 文件的规则是否写错git check-ignore 记住密码git config --global credential.helper store 多人协作的工作模式 首先，可以试图用 git push origin branch-name 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用 git push origin branch-name 推送就能成功！ Linux 安装 gityum install git-core 提交若出现冲突，解决冲突后重新 add 和 commit 报错解决The authenticity of host ‘github.com (192.30.255.112)’ can’t be established.SSH 警告,当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告：输入 yes 回车即可 failed to push some refs to &#39;git@github.com:xuehongjie/git-demo.git’出现错误的主要原因是 github 中的 README.md 文件不在本地代码目录中,可以通过如下命令进行代码合并【注：pull=fetch+merge]git pull --rebase origin master git pull 提示“no tracking information”说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream &lt;branch-name&gt; origin/&lt;branch-name&gt; git pull 提示 fatal: refusing to merge unrelated historiesgit pull origin master --allow-unrelated-histories The remote end hung up unexpectedly提交文件过大，可以分批提交 git both modified修改冲突文件后重新提交 Updates were rejected because the tip of your current branch is behind更新代码，重新 commit 提交 warning: LF will be replaced by CRLF in 文件名.The file will have its original line endings in your working directory.git rm -r --cache &lt;name&gt;git config core.autocrlf falsegit add . error: pathspec ‘Rose’ did not match any file(s) known to git.(分支切换失败)git fetchgit checkout &lt;branchname&gt; git reset –hard HEAD^后显示 more?的解决方案这是因为 cmd 控制台中换行符默认是^，而不是\\ ，所以它的 more？的意思是问你下一行是否需要再输入，而^ 符号就被当做换行符而被 git 命令忽略掉了。解决方法有如下几种：加引号：git reset --hard &quot;HEAD^&quot;加一个^：git reset --hard HEAD^^换成~：git reset --hard HEAD~ 或者 git reset --hard HEAD~1~ 后面的数字表示回退几次提交，默认是一次 git pull 时报错，Auto packing the repository in background for optimum performance. See “git help gc” for manual housekeeping.运行git gc，然后重新git pull 拉代码进行合并时，进入无法操作的界面输入:q 进行退出 git merge dev 时，refusing to merge unrelated historiesgit merge dev --allow-unrelated-histories 合并代码后提交代码报 cannot do a partial commit during a merge. merge 以后先把代码 commit 一次，修改需要合并的地方 重新 add、commit 提交代码 拉取代码提示 fatal: refusing to merge unrelated histories 强制拉取代码 git pull origin master --allow-unrelated-histories 本地文件名大小写问题导致远程 git 仓库有 2 份目录/文件 12// 删除本地缓存，然后提交git rm --cached 文件路径 -r 解决文件大小写后导致无法切换分支，提示 The following untracked working tree files would be overwritten by checkout: 12// 将忽略大小写的 git 配置打开，成功切换分支后移除多余文件再关闭git config core.ignorecase true","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"Git","slug":"Git","permalink":"https://xuehongjie.github.io/tags/Git/"}]},{"title":"npm","slug":"front-end/tools/npm","date":"2019-01-20T23:21:54.000Z","updated":"2019-02-06T14:34:15.169Z","comments":true,"path":"front-end/tools/npm/","link":"","permalink":"https://xuehongjie.github.io/front-end/tools/npm/","excerpt":"","text":"NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 仓库设置设置淘宝仓库npm config set registry https://registry.npm.taobao.orgnpm install --registry=https://registry.npm.taobao.org 设置回默认仓库npm config set registry https://registry.npmjs.org 解决npm下载慢问题12345npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ npm install安装模块12345678npm install (with no args, in package dir)npm install [&lt;@scope&gt;/]&lt;name&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt;npm install &lt;tarball file&gt;npm install &lt;tarball url&gt;npm install &lt;folder&gt; npm简写npm i默认会安装最新版本：common options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run]安装指定版本：npm install gulp@3.9.1 -S, –savenpm install gulp --save 或 npm install gulp -S 12345// 生产阶段的依赖// 安装后会在package.json的dependencies属性中添加响应的文件名和版本&quot;dependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -D, –save-devnpm install gulp --save-dev 或 npm install gulp -D12345// 开发阶段的依赖// 安装包信息将加入到devDependencies，所以开发阶段一般使用它&quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -O, –save-optionalnpm install gulp --save-optional 或 npm install gulp -O123456// 可选阶段的依赖// 安装包信息将加入到optionalDependenciespackage.json 文件的optionalDependencies字段：&quot;optionalDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -E, –save-exactnpm install gulp --save-exact 或 npm install gulp -E12345// 精确安装指定模块版本// 输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，可以看出版本号中的^消失了&quot;dependencies&quot;: &#123; &quot;gulp&quot;: &quot;3.9.1&quot;&#125; 常用命令本地安装（local）npm install gulp，alias: i 全局安装（global）,使用 -g 或 –globalnpm install gulp -g 卸载模块npm uninstall，aliases: remove, rm, r, un, unlinknpm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional] 卸载开发版本的模块npm uninstall gulp --save-dev 更新模块npm updatenpm update [-g] [&lt;pkg&gt;...] 检查模块是否已经过时npm outdatednpm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...]此命令会列出所有已经过时的包，可以及时进行包的更新 查看安装的模块npm lsnpm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 查看全局安装的模块及依赖npm ls -g 在项目中引导创建一个package.json文件npm init安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用。npm init [-f|--force|-y|--yes] 查看某条命令的详细帮助npm helpnpm help &lt;term&gt; [&lt;terms..&gt;]例如输入npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.html 查看包(node_modules)的安装路径npm rootnpm root [-g] 管理npm的配置路径npm config1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm config get &lt;key&gt;npm config delete &lt;key&gt;npm config listnpm config editnpm get &lt;key&gt;npm set &lt;key&gt; &lt;value&gt; [-g|--global] 对于config这块用得最多应该是设置代理，解决npm安装一些模块失败的问题例如我在公司内网，因为公司的防火墙原因，无法完成任何模块的安装，这个时候设置代理可以解决npm config set proxy=http://xxx.com:8080又如国内的网络环境问题，某官方的IP可能被和谐了，幸好国内有好心人，搭建了镜像，此时我们简单设置镜像npm config set registry=&quot;http://r.cnpmjs.org&quot;也可以临时配置，如安装淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 管理模块的缓存npm cache1234567891011npm cache add &lt;tarball file&gt;npm cache add &lt;folder&gt;npm cache add &lt;tarball url&gt;npm cache add &lt;name&gt;@&lt;version&gt;npm cache ls [&lt;path&gt;]// 清除npm本地缓存npm cache clean [&lt;path&gt;]npm cache cleannpm cache clean --force // 强制清除 启动模块npm startnpm start [-- &lt;args&gt;]该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp -ws&quot;&#125; 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。如果package.json文件没有设置start，则将直接启动node server.js 停止模块npm stopnpm stop [-- &lt;args&gt;] 重新启动模块npm restartnpm restart [-- &lt;args&gt;] 测试模块npm test1234567npm test [-- &lt;args&gt;]npm tst [-- &lt;args&gt;]该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;gulp release&quot;&#125;,此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 查看模块版本npm versionnpm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git] ‘npm [-v | –version]’ to print npm version‘npm view version’ to view a package’s published version‘npm ls’ to inspect current package/dependency versions 查看模块的注册信息npm viewnpm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]123456查看模块的依赖关系npm view gulp dependencies查看模块的源文件地址npm view gulp repository.url查看模块的贡献者，包含邮箱地址npm view npm contributors 查看最新版本npm info vue version 查看所有版本npm info vue versions 发布npm包用户登录npm addusernpm adduser [--registry=url] [--scope=@orgname] [--always-auth] 发布模板到npm社区前需要先登录，然后再进入发布的操作 发布模块npm publishnpm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;] 撤销发布的模块npm unpublishnpm unpublish &lt;pkg&gt;需要加上–force参数 在发布的包上设置访问级别npm access123456789npm access public [&lt;package&gt;]npm access restricted [&lt;package&gt;]npm access grant &lt;read-only|read-write&gt; &lt;scope:team&gt; [&lt;package&gt;]npm access revoke &lt;scope:team&gt; [&lt;package&gt;]npm access ls-packages [&lt;user&gt;|&lt;scope&gt;|&lt;scope:team&gt;]npm access ls-collaborators [&lt;package&gt; [&lt;user&gt;]]npm access edit [&lt;package&gt;] package.json的语法参考链接英文原版 npm会根据包内容设置一些默认值。 “scripts”: {“start”: “node server.js”}如果包的根目录有server.js文件，npm会默认将start命令设置为node server.js。 “scripts”:{“preinstall”: “node-waf clean || true; node-waf configure build”}如果包的根目录有wscript文件，npm会默认将preinstall命令用node-waf进行编译。 “scripts”:{“preinstall”: “node-gyp rebuild”}如果包的根目录有binding.gyp文件，npm会默认将preinstall命令用node-gyp进行编译。 “contributors”: […]如果包的根目录有AUTHORS文件，npm会默认逐行按Name (url)格式处理，邮箱和url是可选的。#号和空格开头的行会被忽略。 name在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。name是这个东西的名字。注意：不要把node或者js放在名字中。因为你写了package.json它就被假定成为了js，不过你可以用”engine”字段指定一个引擎（见后文）。这个名字会作为在URL的一部分、命令行的参数或者文件夹的名字。任何non-url-safe的字符都是不能用的。这个名字可能会作为参数被传入require()，所以它应该比较短，但也要意义清晰。在你爱上你的名字之前，你可能要去npm registry查看一下这个名字是否已经被使用了。http://registry.npmjs.org/ versionversion必须能被node-semver解析，它被包在npm的依赖中。（要自己用可以执行npm install semver）可用的“数字”或者“范围”. description放简介，字符串，方便在npm search中搜索 keywords关键字，数组、字符串，方便在npm search中搜索 bugs你项目的提交问题的url和（或）邮件地址1234&#123; &quot;url&quot;: &quot;http://github.com/owner/project/issues&quot;, &quot;email&quot;: &quot;project@hostname.com&quot;&#125; license你应该要指定一个许可证，让人知道使用的权利和限制的。最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：123&#123; &quot;license&quot;: &quot;BSD&quot;&#125; 如果你又更复杂的许可条件，或者想要提供给更多地细节，可以这样:1234&quot;licenses&quot;: [&#123; &quot;type&quot;: &quot;MyLicense&quot;, &quot;url&quot;: &quot;http://github.com/owner/project/path/to/license&quot;&#125;] repository指定你的代码存放的地方。这个对希望贡献的人有帮助。如果git仓库在github上，那么npm docs命令能找到你。这样做：123456789&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;http://github.com/isaacs/npm.git&quot;&#125;&quot;repository&quot;: &#123; &quot;type&quot;: &quot;svn&quot;, &quot;url&quot; : &quot;http://v8.googlecode.com/svn/trunk/&quot;&#125; URL应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的url。不应该是一个html的项目页面。因为它是给计算机看的。 scripts“scripts”是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令。参考上面的npm start、npm test命令 config“config” hash可以用来配置用于包脚本中的跨版本参数。在实例中，如果一个包有下面的配置：1234&#123; &quot;name&quot;: &quot;foo&quot;, &quot;config&quot;: &#123; &quot;port&quot; : &quot;8080&quot; &#125; &#125; 然后有一个“start”命令引用了npm_package_config_port环境变量，用户可以通过npm config set foo:port 8001来重写他。 dependencies依赖是给一组包名指定版本范围的一个hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用tarball或者git URL。请不要将测试或过渡性的依赖放在dependencieshash中。见下文的devDependencies version 必须完全和version一致 version 必须比version大 =version 同上 &lt;version 同上 &lt;=version 同上 ~version 大约一样 1.2.x 1.2.0, 1.2.1, 等，但不包括1.3.0 http://… 见下文’依赖URL’ 所有 “” 空，同* version1 - version2 同 &gt;=version1 &lt;=version2. range1 || range2 二选一。 git… 见下文’依赖Git URL’ user/repo 见下文’GitHub URLs’ 比如下面都是合法的：1234567891011121314&#123; &quot;dependencies&quot;: &#123; &quot;foo&quot;: &quot;1.0.0 - 2.9999.9999&quot;, &quot;bar&quot;: &quot;&gt;=1.0.2 &lt;2.1.2&quot;, &quot;baz&quot;: &quot;&gt;1.0.2 &lt;=2.3.4&quot;, &quot;boo&quot;: &quot;2.0.1&quot;, &quot;qux&quot;: &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;, &quot;asd&quot;: &quot;http://asdf.com/asdf.tar.gz&quot;, &quot;til&quot;: &quot;~1.2&quot;, &quot;elf&quot;: &quot;~1.2.3&quot;, &quot;two&quot;: &quot;2.x&quot;, &quot;thr&quot;: &quot;3.3.x&quot; &#125;&#125; devDependencies如果有人要使用你的模块，那么他们可能不需要你开发使用的外部测试或者文档框架。在这种情况下，最好将这些附属的项目列在devDependencies中。这些东西会在执行npm link或者npm install的时候初始化，并可以像其他npm配置参数一样管理。对于非特定平台的构建步骤，比如需要编译CoffeeScript，可以用prepublish脚本去实现，并把它依赖的包放在devDependency中。（译者注：prepublish定义了在执行npm publish的时候先行执行的脚本）比如：1234567891011&#123; &quot;name&quot;: &quot;ethopia-waza&quot;, &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;devDependencies&quot;: &#123; &quot;coffee-script&quot;: &quot;~1.6.3&quot; &#125;, &quot;scripts&quot;: &#123; &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot; &#125;, &quot;main&quot;: &quot;lib/waza.js&quot;&#125; prepublish脚本会在publishing前运行，这样用户就不用自己去require来编译就能使用。并且在开发模式中（比如本地运行npm install）会运行这个脚本以便更好地测试。 npm list查看模块版本号npm list 版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。 如果有大变动，向下不兼容，需要更新X位。 报错Cannot publish over previously published version已撤销的版本无法发布相同的版本","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"npm","slug":"npm","permalink":"https://xuehongjie.github.io/tags/npm/"}]},{"title":"HTML快捷生成","slug":"front-end/html/emmet","date":"2019-01-20T23:16:41.000Z","updated":"2019-01-20T15:20:46.120Z","comments":true,"path":"front-end/html/emmet/","link":"","permalink":"https://xuehongjie.github.io/front-end/html/emmet/","excerpt":"","text":"HTML初始化html:5 或!：用于HTML5文档类型html:xt：用于XHTML过渡文档类型html:4s：用于HTML4严格文档类型 添加类、id、属性、文本a.bar#foo[href=#]{foo}类：.barid：#foo属性：[href=#]文本：{foo} 嵌套&gt;：子元素符号，表示嵌套的元素+：同级标签符号^：可以使该符号前的标签提升一行(提升为上级节点) 分组(.foo&gt;h1)+(.bar&gt;h2) 隐式标签(根据父标签判断子标签)li：用于ul和ol中tr：用于table、tbody、thead和tfoot中td：用于tr中option：用于select和optgroup中 定义多个元素ul&gt;li*3 生成3个li标签12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 定义多个带属性的元素ul&gt;li.item$*312345&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;/ul&gt; CSS值w100生成width:100pxp 表示%e 表示 emx 表示 ex 附加属性@f+ 模糊匹配如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的 供应商前缀在属性前加-w-w 表示 -webkit-m 表示 -moz-s 表示 -ms-o 表示 -o-","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://xuehongjie.github.io/tags/html/"},{"name":"emmet","slug":"emmet","permalink":"https://xuehongjie.github.io/tags/emmet/"}]},{"title":"Fiddler","slug":"front-end/tools/fiddler","date":"2019-01-12T00:23:36.000Z","updated":"2019-01-24T14:55:23.287Z","comments":true,"path":"front-end/tools/fiddler/","link":"","permalink":"https://xuehongjie.github.io/front-end/tools/fiddler/","excerpt":"","text":"界面按钮功能Replay 重新发起请求，快捷键RGo 用于断点调试Stream 流切换(按下为流模式，弹起为缓存模式)keep 保留回话数(电脑性能不好的情况下不要选择All sessions)Any Process 限定捕捉的服务Find 查找Save 保存现在的请求，可通过File→Recent Archives选中刚才保存的文件进行还原 statistics 数据统计inspectors 对请求解包AutoResponder 文件代理Composer 前后端接口联调Log 记录日志Timeline 网站性能分析Willow 设置手机抓包Tools → Options → HTTPS选中”Decrpt HTTPS traffic”, Fiddler就可以截获HTTPS请求，选中ignore server certificate errorsTools → Options → Connections选中”Allow remote computers to connect”. 是允许别的机器把HTTP/HTTPS请求发送到Fiddler上来AutoResponder勾选Enable rules和Unmatched requests passthrough打开手机浏览器，输入电脑ip:8888(fiddler端口号)，点击FiddlerRoot certificate进行证书下载IOS需要在通用 → 关于本机 → 证书信任设置，进行证书信任 抓包时遇到的问题1、使用*redir进行服务重定向，需要把localhost改为电脑ip地址苹果手机才能重定向。2、如果抓包时一直443或者1443，删除证书重新下载；如果还是不行，打开命令行输入certmgr.msc，删除个人文件夹里的证书。 Fiddler命令bpu url地址 对请求打断点，可在raw页签修改请求参数和响应结果，不加地址为清除断点bpv 请求类型，对相应请求类型的请求打断点dump 将请求存储到C:\\Users\\lenovo\\Documents\\Fiddler2\\Captures中 其他 Tools→HOSTS选中enable可以修改host Alt+q可以切换到命令行","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://xuehongjie.github.io/tags/tool/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://xuehongjie.github.io/tags/Fiddler/"}]},{"title":"scss","slug":"front-end/css/scss","date":"2019-01-10T22:06:53.000Z","updated":"2020-03-01T15:25:58.898Z","comments":true,"path":"front-end/css/scss/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/scss/","excerpt":"","text":"官方文档 安装需要安装sass、sass-loader、node-sass、node-gyp安装node-sass之前需要先安装npm-cli和node-gyp 定义定义变量使用$符定义变量，即$color 定义用于继承的类使用%定义，定义的class不编译 定义列表$list: first second third; 定义混合样式通过@mixin定义，@include引入 继承使用@extend继承某个类的样式 循环1234567// 使用@each、@for、@while来循环@for循环，through指包含该值，to不包含该值@for $i from 1 through 100 &#123; .marginTop-#&#123;$i&#125; &#123; margin-top: #&#123;$i&#125;px; &#125;&#125; 在scss中使用原生import import的文件以.css结尾 引入的路径是以http://开头 使用url()函数引用时 import后面带有media queries的时候 设置底部安全距离123456/* 底部安全距离 */@mixin safe-bottom($distance: 0) &#123; padding-bottom: #&#123;$distance&#125;px; padding-bottom: calc(constant(safe-area-inset-bottom) + #&#123;$distance&#125;px); /* 兼容 iOS &lt; 11.2 */ padding-bottom: calc(env(safe-area-inset-bottom) + #&#123;$distance&#125;px); /* 兼容 iOS &gt;= 11.2 */&#125; 其他 文件名前面带_表示不编译成css文件，直接引入其他文件 使用#{$width}包裹变量，避免做除法运算 同一目录下，局部文件和和非局部文件不能重名 .error {&amp;.instrusion {}} .serious {@extend .error}该继承会生成.serious.instrusion的样式 extend不能继承嵌套选择器，如.A .B 使用@at-root将样式提取到最外层，用法@at-root {.main {}} 7以下版本的深度选择器使用/deep/，8版本开始使用&gt;&gt;&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"},{"name":"scss","slug":"scss","permalink":"https://xuehongjie.github.io/tags/scss/"}]},{"title":"节流与防抖","slug":"front-end/js/throttle-and-debounce","date":"2019-01-05T22:44:02.000Z","updated":"2019-01-08T14:54:59.390Z","comments":true,"path":"front-end/js/throttle-and-debounce/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/throttle-and-debounce/","excerpt":"","text":"函数节流1234567891011121314151617function throttle(method,delay,duration)&#123; var timer=null, begin=new Date(); return function()&#123; var context=this, args=arguments, current=new Date(); clearTimeout(timer); if(current-begin&gt;=duration)&#123; method.apply(context,args); begin=current; &#125;else&#123; timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125;&#125; 防抖函数简单的防抖动函数12345678910function debounce(func, wait, immediate) &#123; // 定时器变量 var timeout; return function() &#123; // 每次触发 scroll handler 时先清除定时器 clearTimeout(timeout); // 指定 xx ms 后触发真正想进行的操作 handler timeout = setTimeout(func, wait); &#125;;&#125;; 防抖动函数1234567891011121314function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;","categories":[],"tags":[{"name":"throttle","slug":"throttle","permalink":"https://xuehongjie.github.io/tags/throttle/"},{"name":"debounce","slug":"debounce","permalink":"https://xuehongjie.github.io/tags/debounce/"}]},{"title":"微信","slug":"front-end/wx/wx","date":"2019-01-02T22:56:52.000Z","updated":"2019-01-02T15:30:28.996Z","comments":true,"path":"front-end/wx/wx/","link":"","permalink":"https://xuehongjie.github.io/front-end/wx/wx/","excerpt":"","text":"注册 引入js文件 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt; 调用后台接口获取签名(signature)、时间戳(timestamp)、随机串(nonceStr)，通过config接口注入权限验证配置 js-sdk调用隐藏分享栏1WeixinJSBridge.call(&apos;hideOptionMenu&apos;) 问题微信端无法自动播放音频问题 使用微信提供的js-sdk，在ready中调用播放的API 1234567891011121314151617//首先引用js: &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;//然后写方法: function autoPlayAudio1()&#123; wx.config(&#123; //配置信息, 即使不正确也能使用 wx.ready debug: false, appId: &apos;&apos;, timestamp: 1, nonceStr: &apos;&apos;, signature: &apos;&apos;, jsApiList: [] &#125;); wx.ready(function() &#123; document.getElementById(&apos;audio&apos;).play(); &#125;);&#125; 监听WeixinJSBridgeReady事件 1234var audio=document.querySelector(&quot;#audio&quot;); document.addEventListener(&quot;WeixinJSBridgeReady&quot;,function()&#123; audio.play();&#125;, false);","categories":[],"tags":[{"name":"sdk","slug":"sdk","permalink":"https://xuehongjie.github.io/tags/sdk/"},{"name":"微信","slug":"微信","permalink":"https://xuehongjie.github.io/tags/微信/"}]},{"title":"企业微信","slug":"front-end/wx/qywx","date":"2019-01-02T22:56:35.000Z","updated":"2019-03-03T13:25:48.944Z","comments":true,"path":"front-end/wx/qywx/","link":"","permalink":"https://xuehongjie.github.io/front-end/wx/qywx/","excerpt":"","text":"注册 引入js文件&lt;script type=&quot;text/javascript&quot; src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt; 调用后台接口获取签名(signature)、时间戳(timestamp)、随机串(nonceStr)，通过config接口注入权限验证配置 注册相关文档通过企业微信提供的网站校验 js-sdk调用图片上传 使用wx.chooseImage拍照或者从相册中获取，返回localIds本地ID列表 调用wx.uploadImage上传照片到临时素材，返回serverId，需要同步上传，上传一张成功才能接着上传下一张 调用后台接口，后台将临时素材中的图片拉取到服务器中 IOS可通过调用getLocalImgData使用localIds获得base64进行展示，Android可以通过img直接使用localIdsbase64转file时name属性需要带后缀，否则上传后得到的文件为tmp文件 图片上传sdkbase64转File方法 问题企业微信注册报invalid signture 在home界面调用注册方法会报错，修改调用的位置至需要使用新建表单页面 后台返回的时间戳单位需要为秒，注册的url需要encodeURIComponent再传给后台，由后台decode 项目用的是history模式，每个页面使用sdk都需要重新调用注册方法 url不调用encodeURIComponent的话链接上通过&amp;字符连接起来的参数会不被加入签名中 安卓手机无法预览图片12345// 调用接口时，urls必须传wx.previewImage(&#123; current: imgUrl, // 当前显示图片的http链接 urls: [imgUrl] // 需要预览的图片http链接列表&#125;);","categories":[],"tags":[{"name":"企业微信","slug":"企业微信","permalink":"https://xuehongjie.github.io/tags/企业微信/"},{"name":"sdk","slug":"sdk","permalink":"https://xuehongjie.github.io/tags/sdk/"}]},{"title":"axios","slug":"front-end/plugins/axios","date":"2018-12-27T22:50:20.000Z","updated":"2019-02-02T15:15:22.532Z","comments":true,"path":"front-end/plugins/axios/","link":"","permalink":"https://xuehongjie.github.io/front-end/plugins/axios/","excerpt":"","text":"api 特色 浏览器端发起XMLHttpRequests请求 node端发起http请求 支持Promise API 拦截请求和返回 转化请求和返回(数据) 取消请求 自动转化jsonshuju 客户端支持抵御XSRF(跨站请求伪造) 合并请求1axios.all([request1, request2]).then(axios.spread((res1, res2) =&gt; &#123;&#125;)) 取消请求1234567const CancelToken = axios.CancelTOken;const source = CancelToken.source(); // 创建标志请求的源对象axios.post(&apos;/&apos;, &#123;&#125;, &#123; cancelToken: source.token,&#125;)source.cancel(); 文件断点续传12345678910111213// 裁剪文件let fileData = this.file.slice(this.loaded + 1, this.file.size);let formData = new FormData();formData.append(&apos;file&apos;, fileData);axios.post(&apos;/&apos;, formData, &#123; onUploadProgress(progressEvent)&#123; // 当前上传字节 this.loaded = progressEvent.loaded // progressEvent.total 文件总字节 &#125;&#125;); 拦截器 请求拦截器 123axios.interceptors.request.use((config) =&gt; &#123; return config&#125;) 响应拦截器 1axios.interceptor.response.use((res) =&gt; &#123;&#125;) 单请求配置options: axios.post(url, data, options) 全局配置defaults: axios.defaults config: 请求拦截器中的参数 response.config响应拦截器中的参数 options baseURL 基础URL路径 params 查询字符串(对象) transformRequest: function(req) {post请求传递的数据} 转换请求体数据 transformResponse: function(res) {自己转换响应的数据} 转换响应体数据 headers 请求头信息 data 请求体数据 timeout 请求超时时间(毫秒) 实例创建1234let instance = axios.create(&#123; baseURL: &apos;https://127.0.0.1:8080&apos;, headers: &#123;&#125;&#125;)","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://xuehongjie.github.io/tags/ajax/"},{"name":"axios","slug":"axios","permalink":"https://xuehongjie.github.io/tags/axios/"}]},{"title":"Vuex相关知识点记录","slug":"front-end/framework/Vuex","date":"2018-12-26T22:30:20.000Z","updated":"2019-02-10T06:55:22.290Z","comments":true,"path":"front-end/framework/Vuex/","link":"","permalink":"https://xuehongjie.github.io/front-end/framework/Vuex/","excerpt":"","text":"官网 使用 引用vuex，import Vuex from &#39;vuex&#39; 安装Vuex，Vue.use(Vuex) 创建store对象 12345678910111213const state = &#123; num: 5&#125;;const mutations = &#123; addNum(state, payload) &#123; state.num += payload.num; &#125;&#125;const store = new Vuex(&#123; state, mutations,&#125;); 在vue实例中使用 123new Vue(&#123; store,&#125;) 获取/修改值 12345// 获取值this.$store.state.num// 修改值this.$store.commit(&apos;addNum&apos;, &#123;num: 5&#125;) 核心属性State123456state: &#123; num: 5&#125;// 获取值this.$store.state.num Getter12345678getters: &#123; getNum(state) &#123; return state.num &#125;&#125;// 获取值this.$store.getters.getNum Mutation必须是同步的，否则devtools中捕捉的状态会不正确，即丢失快照记录12345678910mutations: &#123; addNum(state, payload) &#123; setTimeout(() =&gt; &#123; state.num += payload.num; &#125;, 1000) &#125;&#125;// 修改值this.$store.commit(&apos;addNum&apos;, &#123;num: 5&#125;) Action可以进行异步操作12345678910actions: &#123; addNumByAct(store, payload) &#123; setTimeout(() =&gt; &#123; store.commit(&apos;addNum&apos;, payload); &#125;, 1000) &#125;&#125;// 修改值this.$store.dispatch(&apos;addNumByAct&apos;, &#123;num: 5&#125;) module辅助函数mapState引入import {mapState} from &#39;vuex&#39; 123456computed: mapState(&#123; num: state =&gt; state.num, // 使用aliasNum代替num来获取值 aliasNum: &apos;num&apos;,&#125;) 12345computed: &#123; ...mapState(&#123; num: state =&gt; state.num, &#125;)&#125; 1234computed: mapState([ // 映射 this.num 为 store.state.num &apos;num&apos;]) mapGetters引入import {mapGetters} from &#39;vuex&#39; 12345computed: &#123; ...mapGetters([ &apos;getNum&apos;, ])&#125; 123mapGetters(&#123; getNumByMap: &apos;getNum&apos;&#125;) vuex报错Error in callback for watcher “function () { return this._data.$$state }”: “Error: [vuex] Do not mutate vuex store state outside mutation handlers.”mutations的修改中不允许使用setTimeOut等异步操作","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuehongjie.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://xuehongjie.github.io/tags/vuex/"}]},{"title":"VueRouter相关知识点记录","slug":"front-end/framework/VueRouter","date":"2018-12-25T22:45:58.000Z","updated":"2019-03-10T10:25:11.636Z","comments":true,"path":"front-end/framework/VueRouter/","link":"","permalink":"https://xuehongjie.github.io/front-end/framework/VueRouter/","excerpt":"","text":"官网 使用 引用vue-router，import VueRouter from &#39;vue-router&#39; 安装VueRouter，Vue.use(VueRouter) 创建、配置路由对象 1234567891011121314151617181920212223242526272829const routes = [&#123; name: &apos;login&apos;, path: &apos;/login&apos;, component: Login, meta: &#123; isCheck: false &#125;, // 路由元信息，可用来做登录权限的处理 children: [&#123; name: &apos;child&apos;, path: &apos;child&apos;, // 路径为/login/child component: Child &#125;, &#123; name: &apos;child&apos;, path: &apos;/child2&apos;, // 路径为/child2 component: Child &#125;]&#125;, &#123; path: &apos;*&apos;, redirect: &#123;name: &apos;login&apos;&#125;, // 重定向&#125;];const router = new VueRouter(&#123; base: &apos;/&apos;, mode: &apos;hash&apos;, // 可选值，hash、history、abstract routes,&#125;);// 若new VueRouter的时候没有传入routes属性，可通过addRoutes添加router.addRoutes(routes); 在vue实例中使用 123new Vue(&#123; router,&#125;) html中使用 123456// 跳转的按钮&lt;router-link to=&quot;/login&quot;&gt;跳转登录&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;name: &apos;login&apos;&#125;&quot;&gt;跳转登录&lt;/router-link&gt;// 用于展示视图&lt;router-view&gt;&lt;/router-view&gt; 命名视图12345678910111213141516&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向 路径字符串 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;*&apos;, redirect: &apos;/login&apos; &#125; ]&#125;) 路由对象 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;*/a*&apos;, redirect: &#123; name: &apos;login&apos; &#125;&#125; ]&#125;) 函数 12345678const router = new VueRouter(&#123; routes: [ &#123; path: &apos;*&apos;, redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 实例属性 $route，路由信息对象，只读 $router，路由操作对象，只写 编程式导航 调到指定的路由 123456this.$router.push(&#123; name: &apos;login&apos;, path: &apos;/login&apos;, query: &#123;id: 1&#125;, params: &#123;name: &apos;test&apos;&#125;&#125;) 根据历史记录前进或者后退 12// n传入正值代表前进，负值代表后退this.$router.go(n); 路由跳转通过router-link12&lt;router-link to=&quot;/login&quot;&gt;跳转登录&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;name: &apos;login&apos;&#125;&quot;&gt;跳转登录&lt;/router-link&gt; 通过$router12345678910111213141516vue-router跳转(以/开头的嵌套路径会被当做根路径)跳转写法// 字符串this.$router.push(&apos;/home&apos;);// 对象this.$router.push(&#123; path:&apos;home&apos;&#125;);// 命名的路由this.$router.push(&#123; name:&apos;home&apos;, params:&#123;userId: 1&#125;, query: &#123;&#125;&#125;); 钩子函数beforeEach 可以用来做登录拦截，通过next来控制页面是否跳转123456789101112131415161718192021router.beforeEach((to, from, next) =&gt; &#123; // 是否需要校验登录，不校验则正常跳转 if (!to.meta.isCheck) &#123; next(); &#125; else &#123; if (isLogin) &#123; next(); &#125; else &#123; next(&#123;name: &apos;login&apos;&#125;); &#125; &#125;&#125;);to: 目标路由，即要进入的路由from: 源路由，即跳转前的路由next: 是否允许跳转// next传值1. next()，正常跳转2. next(false)，停止跳转，效果等同于不调用next3. next(&#123;name: &apos;login&apos;&#125;)，路由重定向，跳转到login 组件内的守卫 12345678910111213141516171819202122export default &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建，可通过next的回调来获取 next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;) &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` // 可通过next(false)取消跳转 &#125;&#125; 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫(beforeRouteLeave)。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter(routes中定义的)。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 模式hash利用hashchange监听url中hash部分(如#/home)的改变 history 需要服务端配合，每次都重定向到index.html页面 需要设置config/index.js中assetsPublicPath为/ 路由懒加载 利用require.ensure 123456789const routes = [&#123; path: &apos;/home&apos;, name: &apos;home&apos;, component(resolve) &#123; require.ensure([&apos;../views/home.vue&apos;], () =&gt; &#123; resolve(require(&apos;../views/home.vue&apos;)) &#125;) &#125;&#125;] 使用import和syntax-dynamic-importhttps://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/ 12345678910111213npm install --save-dev @babel/plugin-syntax-dynamic-importconst Foo = () =&gt; import(&apos;./Foo.vue&apos;)const routes = [&#123; path: &apos;/home&apos;, name: &apos;home&apos;, component: Foo,&#125;];// .babelrc中配置&#123; &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;]&#125; 记录 scrollBehavior只能在history中生效 报错在history模式下使用子路由刷新报错问题修改assetsPublicPath路径，使用绝对路径","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuehongjie.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://xuehongjie.github.io/tags/vue-router/"}]},{"title":"Vue相关知识点记录","slug":"front-end/framework/Vue","date":"2018-12-24T23:45:58.000Z","updated":"2019-02-13T16:09:26.088Z","comments":true,"path":"front-end/framework/Vue/","link":"","permalink":"https://xuehongjie.github.io/front-end/framework/Vue/","excerpt":"","text":"官网 dist目录中的相关文件 vue.common.js 模块化代码 vue.esm.js ES6模块化代码 vue.min.js 压缩后的代码 vue.runtime.**.js 运行时，比vue小30% 指令自带指令 v-if/v-show: v-if是插入或者移除，v-show是显示或者隐藏(控制display) v-else-if/v-else: 需要和v-if搭配使用，且和v-if的元素相邻 v-bind/v-on: v-bind是给属性赋值(简写:)，v-on是绑定事件(简写@) 12v-bind:属性=&quot;变量&quot; ===&gt; :属性=&quot;变量&quot;v-on:事件名=&quot;函数&quot; ===&gt; @事件名=&quot;函数&quot; v-bind/v-model: v-bind是单向数据绑定，v-model是双向数据绑定 定义自定义指令1234567Vue.directive(&apos;test&apos;, &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;) 使用指令123&lt;div v-if=&quot;show&quot;&gt; &lt;div v-test&gt;&lt;/div&gt;&lt;/div&gt; 组件component定义全局组件12345Vue.component(&apos;MyButton&apos;, &#123; data()&#123; return &#123;&#125; &#125;&#125;) 定义局部组件1234// 引入组件MyButtoncomponents: &#123; MyButton: MyButton&#125; 使用组件1&lt;my-button&gt;&lt;/my-button&gt; 过滤器定义全局过滤器123Vue.filter(reverse, (val, arg) =&gt; &#123; return val&#125;) 定义局部过滤器123456filters: &#123; // 传入值和其他参数 reverse(val, arg) &#123; return val &#125;&#125; 使用过滤器1&lt;div&gt;&#123;&#123;test | reverse(&apos;test&apos;)&#125;&#125;&lt;/div&gt; watch监听对象12345678watch: &#123; obj: &#123; handler:function(newVal,oldVal)&#123;&#125;, // 处理函数 deep:true, // 深度监听 immediate: true, // 是否立即执行 &#125;, obj2(newVal, oldVal) &#123;&#125;&#125; 计算属性computed1234567// 当a、b的值发生改变时才会触发该函数，默认会缓存当前结果// 如果包含对象，则需要其引用地址发生改变才会触发computed: &#123; result:function()&#123; return this.a + this.b &#125;&#125; 插槽slot默认插槽1234567891011// parent&lt;child&gt; &lt;h1&gt;111&lt;/h1&gt;&lt;/child&gt;// child&lt;div&gt; &lt;slot&gt; &lt;div&gt;默认值&lt;/div&gt; &lt;/slot&gt;&lt;/div&gt; 具名插槽1234567891011// parent，通过slot属性找到对应的插槽&lt;child&gt; &lt;h1 slot=&quot;first&quot;&gt;111&lt;/h1&gt;&lt;/child&gt;// child，name属性定义插槽的名称&lt;div&gt; &lt;slot name=&quot;first&quot;&gt; &lt;div&gt;默认值&lt;/div&gt; &lt;/slot&gt;&lt;/div&gt; 插槽中可以使用插槽1234&lt;slot name=&quot;parentSlot&quot;&gt; &lt;div&gt;默认值&lt;/div&gt; &lt;slot name=&quot;childSlot&quot;&gt;&lt;/slot&gt;&lt;/slot&gt; 作用域插槽slot-scope12345678910111213141516171819// child&lt;div class=&apos;mater_other&apos;&gt; &lt;slot name=&quot;other&quot; :item=&quot;item&quot; :name=&quot;&apos;123&apos;&quot;&gt; &#123;&#123;item.price&#125;&#125; &lt;/slot&gt;&lt;/div&gt;// parent(2.5.0+可以在template元素上使用)&lt;div slot=&quot;other&quot; slot-scope=&quot;props&quot;&gt; &lt;div class=&apos;mater_left&apos;&gt; &#123;&#123;props.item.price&#125;&#125; &#123;&#123;props.name&#125;&#125; &lt;/div&gt;&lt;/div&gt;// 支持解构赋值&lt;div slot=&quot;other&quot; slot-scope=&quot;&#123;item, name&#125;&quot;&gt; &lt;div class=&apos;mater_left&apos;&gt; &#123;&#123;item.price&#125;&#125; &#123;&#123;name&#125;&#125; &lt;/div&gt;&lt;/div&gt; 生命周期概述 new Vue → 初始化事件 → beforeCreate → 初始化数据 → created 判断是否设置了el选项，若没有则等待vm.$mount(el)后才继续执行 判断是否有template，有则编译成render函数，没有则编译el为模板 beforeMount → 用$el替换el元素，进行渲染 → mounted 若数据发生改变，若改变则执行beforeUpdate然后重新render，再执行updated 当执行销毁时(自动销毁或者调用vm.$destory)，beforeDestory → 移除watch、子组件和事件 → destoryed 一般情况 创建时beforeCreate → created → beforeMount → mounted 离开页面时beforeDestroy → destroyed 在mounted中改变data的值beforeCreate → created → beforeMount → mounted → beforeUpdate → updated 使用keep-alive 创建时beforeCreate → created → beforeMount → mounted → activated 离开页面时deactivated 在mounted中改变data的值beforeCreate → created → beforeMount → mounted → activated → beforeUpdate → updated 在created钩子中的执行顺序mixin → 当前vue文件 → components 父子组件、mixins之间的顺序 父子组件、mixins的生命周期 router组件异步加载时，App.vue的mounted会先执行 异步加载页面时的声明周期 ref属性作用便于获取DOM节点或者组件对象 如何获取通过this.$refs获取设置ref属性的数据对象，如this.$refs.test 若为多个元素/组件设置相同的ref，获取的值为数组 在DOM渲染后获取通过this.$nextTick()传入回调，在回调中获取$refs 组件对象的属性 $data，数据对象 $refs，设置了ref属性的DOM元素/组件对象 $parent，父组件 $children，子组件(数组) $root，new Vue的实例，vm $el，DOM元素 $slots，插槽对象 $scopedSlots，作用域插槽对象 $listeners，父作用域中不含.native修饰的事件 属性注册(触发视图更新)全局12给item注册checked属性，值为trueVue.set(item,&apos;checked&apos;,true) 局部1this.$set(item,&apos;checked&apos;,true) Vue自定义插件定义install方法123456789101112131415let MyPlugin = &#123;&#125;MyPlugin.install = function()&#123; // 1. 添加全局方法或属性，通过Vue.myGlobalMethod 调用 Vue.myGlobalMethod = function () &#123;&#125; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, &#123; bind (el, binding, vnode, oldVnode) &#123;&#125; &#125;) // 3. 注入组件 Vue.mixin(&#123; created: function () &#123;&#125; &#125;) // 4. 添加实例方法，通过this.$myMethod 调用 Vue.prototype.$myMethod = function (methodOptions) &#123;&#125;&#125; 注册vue插件12// 调用vue的use方法Vue.use(MyPlugin) 使用vue插件12345678910111213141516171819202122232425通过this.$xxx调用插件https://blog.csdn.net/qq_26522773/article/details/79358819import dialogfrom &apos;dialog.vue&apos;function install () &#123; Object.defineProperty(Vue.prototype, &apos;$dialog&apos;, &#123; get() &#123; let div = document.createElement(&apos;div&apos;); document.body.appendChild(div); return (message, modalBody) =&gt; &#123; const Constructor = Vue.extend(dialog) const Instance = new Constructor(&#123; data() &#123; return &#123; message: message, show: true, modalBody: modalBody &#125; &#125; &#125;).$mount(div) return Instance.setSubmit //放回 一个方法用于 传递 自定义的数据和 submit 时方法 &#125;; &#125; &#125;);&#125;Vue.use(Dialog) 上传到npm 每次上传npm需要修改版本号 12345678910111213141516修改package.json文件private:false, // 默认是true 私人的 需要改为false 不然发不上去 你可以试试..&quot;license&quot;: &quot;MIT&quot;, // 许可证&quot;main&quot;: &quot;dist/vue-pay-keyboard.js&quot;, // 这个超级重要 决定了你 import xxx from “vue-pay-keyboard” 它默认就会去找 dist下的vue-pay-keyboard 文件&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/yucccc/vue-pay-keyboard&quot;&#125;, // 配置这个地址存放你项目在github上的位置 也尤为重要npm adduserUsername: your name Password: your password Email: yourmail[@gmail](/user/gmail).comnpm whoami 查看用户npm login 登录npm publish 发布 组件通信的方法props、事件、v-model 父组件访问子组件props$children在组件上定义ref，然后通过$refs访问 子组件访问父组件$emit修改父组件传递的props(仅限引用变量，不推荐)$parent父组件定义回调传入子组件，子组件调用 非父子组件、兄弟组件通信(A页面跳B页面)使用一个Vue实例作为中央事件总线let event = new Vue() // 事件总线event.$on(‘eventName’, (val) =&gt; {}) // 事件处理，在B的created中定义，在B的beforeDestory中销毁event.$emit(‘eventName’, data) // 事件触发，在A的beforeDestory中触发 引用mui.js报callee错误时在rules中加入{rest: resolve(‘src/plugin/mui’),use:[{loader: ‘expose-loader’,options: ‘mui’}]} 使用.ctrl等修饰符进行事件绑定时，可以绑定多个相同的事件，如：@click.ctrl=””和@click=””可以同时绑定 transition和keep-alive联合使用问题需要用transition包裹keep-alive，使用keep-alive包裹transition时路由无法缓存 使用字体图标以下错误 将目录(./font)修改为绝对路径 字体文件需要放到static目录下 assets目录和static目录存放文件的区别在 *.vue 组件中，所有模板和CSS都会被 vue-html-loader 及 css-loader 解析，并查找资源URL。例如，在&lt;img src=&quot;./logo.png&quot;&gt;和 background: url(./logo.png) 中，&quot;./logo.png&quot; 是相对的资源路径，将由Webpack解析为模块依赖。因为 logo.png 不是 JavaScript，当被视为模块依赖时，需要使用 url-loader 和 file-loader处理它。vue-cli 的 webpack 脚手架已经配置了这些 loader，因此可以使用相对/模块路径。由于这些资源可能在构建过程中被内联/复制/重命名，所以它们基本上是源代码的一部分。这就是为什么建议将Webpack 处理的静态资源放在 /src 目录中和其它源文件放一起的原因。事实上，甚至不必把它们全部放在 /src/assets：可以用模块/组件的组织方式来使用它们。例如，可以在每个放置组件的目录中存放静态资源。简单理解为：static存放第三方资源，assets存放自己的资源 依赖注入(provide/inject)provide123456可以为其所有子组件传递一个方法或属性provide() &#123; return &#123; test: this.test, &#125;&#125; inject1234567891011接收父组件provide传递的值// 写法一inject: [&apos;test&apos;]// 写法二inject: &#123; test: &#123; default()&#123; console.log(&apos;child&apos;) &#125; &#125;&#125; style标签使用scoped的时候无法覆盖子组件样式解决方法: 去掉scoped 混用本地和全局样式，即增加一个style标签，不写scoped，进行样式覆 使用深度选择器 /deep/或者&gt;&gt;&gt;，如.a /dep/ .b{} 使用scoped导致的问题 无法覆盖子组件样式 @media 不生效 template的使用123使用template包裹元素进行v-if判断最终的渲染结果不包含template元素，适用于包裹多个要用相同if条件判断的元素&lt;template&gt;&lt;h1&gt;123&lt;/h1&gt;&lt;/template&gt;编译后只展示&lt;h1&gt;123&lt;/h1&gt; v-model生效的元素自带value属性的元素 错误捕获 2.2.0+可用, 2.4.0+支持自定义事件的捕获 1234567891011Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 修改config/index.js中build的assetsPublicPath为 ‘./‘时，style标签background-image使用相对路径打包报错问题https://www.cnblogs.com/qiuyueding/p/8953396.html修改util.js文件ExtractTextPlugin.extract({ use: loaders, fallback: ‘vue-style-loader’, publicPath: ‘../../‘ // 解决打包style标签图片路径问题}) SPA优缺点优点： 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等 缺点： 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。 不利于SEO SPA优化 预渲染使用prerender-spa-plugin vue-router设置history模式 使用prerender-spa-plugin12345// 在webpack.prod.js的plugins中添加new PrerenderSpaPlugin(&#123; staticDir: path.join(__dirname, &apos;..&apos;, &apos;dist&apos;), // 代码打包的目录 routes: [&apos;/&apos;, &apos;/user&apos;], // 根据路由找到预渲染页面&#125;) 骨架屏提前预览结构 记录 在style标签中添加scoped属性可以定义样式的作用域 v-cloak属性保证Vue在new之前不展示{} :class 和:style 使用{}绑定数据时，key代表样式名，使用[]绑定数据时，每个项代表的是data中的数据 给vue组件添加click等原生事件时需要.native 父组件的created会比子组件的created先执行 使用v-for时普通元素会自动计算一个key，组件需要手动设置key，建议普通元素也加上key，提升性能 SPA对SEO不友好 报错vue过渡动画生硬可以使用position:absolute 在android手机出现过渡时页面缩小的情况，可以给过渡元素设置position:absolute 在.vue文件中使用render不生效需要将template去掉 编译报错You are using the runtime-only build of Vue where the template compiler is not available 12345678910// 声明import Vue from &apos;vue&apos;new Vue(&#123; el: &apos;#app&apos;, components: &#123;App,&#125;, template: &apos;&lt;app/&gt;&apos;&#125;)// 处理修改引用的vue文件，import Vue from &apos;vue/dist/vue&apos; Component template should contain exactly one root element模板只能有一个根标签 Cannot use v-for on stateful component root element because it renders multiple elements根标签不能使用v-for 在webstorm中使用scss报错设置style标签type=”text/scss” command failed: npm install --loglevel error --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist执行上述的npm install","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuehongjie.github.io/tags/vue/"}]},{"title":"日常小记-HTML","slug":"front-end/html/daily-notes","date":"2018-12-24T23:16:00.000Z","updated":"2019-02-21T04:04:25.719Z","comments":true,"path":"front-end/html/daily-notes/","link":"","permalink":"https://xuehongjie.github.io/front-end/html/daily-notes/","excerpt":"","text":"渲染机制 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 其他 textarea添加spellcheck＝”false”去除检查 视频播放自动全屏问题设置playsinline=”true”、webkit-playsinline=”true”、x5-playsinline=”true”、x-webkit-airplay=”allow” 修改浏览器页签图标 dns获取1&lt;link href=&quot;https://a.alipayobjects.com&quot; rel=&quot;dns-prefetch&quot;/&gt; 调用颜色盘设置input的type为color","categories":[],"tags":[{"name":"daily-notes","slug":"daily-notes","permalink":"https://xuehongjie.github.io/tags/daily-notes/"},{"name":"html","slug":"html","permalink":"https://xuehongjie.github.io/tags/html/"}]},{"title":"基础小记","slug":"front-end/other/front-end-basics","date":"2018-12-23T23:12:07.000Z","updated":"2019-02-09T10:47:58.484Z","comments":true,"path":"front-end/other/front-end-basics/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/front-end-basics/","excerpt":"","text":"网页加载优化123456789// DNS Prefetch 应该尽量的放在网页的前面，推荐放在 &lt;meta charset=&quot;UTF-8&quot;&gt; 后面。具体使用方法如下：&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.zhix.net&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.zhix.net&quot;&gt;// 需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。// 如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt; CSS盒模型正常盒模型content-box: content 怪异盒模型border-box: content + padding + border 获取盒模型的宽和高123456dom.style.width/heightdom.currentStyle.width/height (IE)window.getComputedStyle(dom).width/height (兼容性较好，获取计算后的样式，可获取伪元素的)dom.getBoundingClientRect().width/height (可以获得transform后的宽高)dom.clientWidth/clientHeight(获取宽高)dom.offsetWidth/offsetHeight (获取宽高，包括padding和border) margin重叠 父子元素 兄弟元素 空的block元素 解决margin重叠BFC(块级格式化上下文) DOM事件 DOM事件模型 事件捕获、冒泡 DOM事件类事件级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(‘click’, function(){}, false) IE:attachEventListener DOM3 element.addEventListener(‘keyup’, function(){}, false) 事件流捕获 → 目标阶段 → 冒泡 描述DOM事件捕获的具体流程如何获取html标签：document.documentElementwindow → document → html → body → … → 目标元素 → … → body → html → document → window Event对象的常见应用1234567891011121314// 阻止默认事件event.preventDefault()// 阻止事件冒泡event.stopPropagation() // 阻止事件继续执行，即一个DOM绑定多个事件，执行该方法会阻止在当前回调后注册的回调函数的执行event.stopImmediatePropagation() // 绑定事件的元素event.currentTarget // 触发事件的元素event.target 自定义事件 Event 12345let evt = new Event(&apos;custom&apos;);document.addEventListner(&apos;custom&apos;, function()&#123; console.log(&apos;custom&apos;);&#125;)document.dispatchEvent(evt); CustomEvent HTTP协议类 HTTP协议的主要特点 简单快速(每个资源都是固定的) 灵活(可以完成不同数据类型的传输) 无连接(只连接一次就会断掉) 无状态(不能区分两次连接的身份) HTTP报文的组成部分请求报文 请求行(包含http方法、页面地址、http协议、版本) 请求头(key、value值) 空行(分割请求头和请求体) 请求体 响应报文 状态行 响应头 空行 响应体 HTTP方法 GET → 获取资源 POST → 传输资源 PUT → 更新资源 DELETE → 删除资源 HEAD → 获得报文首部 POST和GET的区别 GET在浏览器回退时是无害的，而POST会再次提交请求 GET产生的URL地址可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求只能进行url编码，而POST支持多种编码方式 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的(基本是2KB)，而POST没有限制 对参数的数据类型，GET只接受ASCII字符，而POST没有限制 GET比POST更不安全，因为参数直接暴露的URL上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在Request body中 HTTP状态码 1xx：指示信息 - 表示请求已接收，继续处理 2xx：成功 - 表示请求已被成功接收 3xx：重定向 - 要完成请求必须进行更进一步的操作 4xx：客户端错误 - 请求有语法错误或请求无法实现 5xx：服务器错误 - 服务器未能实现合法的请求 200 OK：客户端请求成功 206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它 301 Moved Permanently：所请求的页面已经转移至新的url 302 Found：所请求的页面已经临时转移至新的url 304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态代码必须和www-Authenticate报头域一起使用 403 Forbidden：对被请求页面的访问被禁止 404 Not Found：请求资源不存在 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常 持久连接HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接(HTTP协议为无连接的协议)当使用Keep-Alive模式(又称持久连接、连接重用)时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 管线化在使用持久连接的情况下，某个连接上消息的传递类似于请求1 =》响应1 =》请求2 =》响应2 =》请求3 =》响应3 管线化是指某个连接上的消息变成了类似这样请求1 =》请求2 =》请求3 =》响应1 =》响应2 =》响应3 管线化机制通过持久连接完成，仅HTTP/1.1支持此技术只有GET和HEAD请求可以进行管线化，而POST则有所限制初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefix默认并未开启管线化支持 原型链创建对象有几种方法字面量let o = {name: ‘o’};let obj = new Object({name: ‘obj’}); 通过构造函数let M = function(){this.name = ‘o2’};let obj2 = new M();Object.create(prototype, descriptors)let P = {name: ‘o3’};let obj3 = Object.create(P); 原型、构造函数、实例、原型链之间的关系 原型、构造函数、实例、原型链 let M = function(){}let o = new M();构造函数：M；实例：o；原型对象：M.prototype/o.proto；原型链：通过proto一直向上查找proto的链只有构造函数才有prototype属性，只有对象(实例也是对象)和函数才有proto属性o.proto === M.prototype // trueM.prototype.proto === Object.prototype // trueo.proto.constructor === M // true 使用这个方法来判断是否为M的实例对象，instanceof不严谨 实例、构造函数、原型 o instanceof M // trueo instanceof Object // true new运算符 面对对象类的声明123456789function Animal()&#123; this.name = &apos;name&apos;;&#125;// ES6class Animal()&#123; constructor()&#123; this.name = &apos;name&apos;; &#125;&#125; 借助构造函数实现继承 缺点：无法继承prototype的属性和方法 1234567function Parent()&#123; this.name = &apos;parent&apos;;&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125; 借助原型链实现继承 缺点：共用prototype属性和方法，修改一个影响全部 1234567function Parent()&#123; this.name = &apos;parent&apos;;&#125;function Child()&#123; this.type = &apos;child&apos;;&#125;Child.prototype = new Parent(); 组合方式 使用instanceof的时候Child和Parent都为true 123456789function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = new Parent(); 优化一 缺点：Child的实例对象使用constructor时，指向Parent 123456789function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = Parent.prototype; 优化二12345678910function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.construcor = Child; 通信类同源策略及限制 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 这是一个用于隔离潜在恶意文件的关键的安全机制。 Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 Ajax请求不能发送 前后端如何通信 Ajax WebSocket CORS 如何创建Ajax XMLHttpRequest对象的工作流程(XMLHttpRequest、ActiveXObject(‘Microsoft.XMLHTTP’)) 兼容性处理 事件的触发条件 事件的触发顺序 跨域通信的几种方式 JSONP Hash postMessage WebSocket CORS postMessage使用CORS使用http://www.ruanyifeng.com/blog/2016/04/cors.html 安全类CSRF通常称为跨站请求伪造，英文名Cross-site request forgery 攻击原理利用接口漏洞，多次执行接口 防御措施 Token验证 Referer验证 隐藏令牌 XSS(http://www.imooc.com/learn/812)https://www.qdfuns.com/article/40048/bfb73a7b6b6495c8105dab76faa4dfff.html跨域脚本攻击，cross-site scripting 攻击原理向页面注入js进行运行 算法类排序快速排序选择排序希尔排序 堆栈、队列、链表https://juejin.im/entry/58759e79128fe1006b48cdfd 递归https://segmentfault.com/a/1190000009857470 波兰式和逆波兰式理论: https://www.cnblogs.com/chenying99/p/3675876.html源码: https://github.com/Tairraos/rpn.js/blob/master/rpn.js 渲染机制类什么是DOCTYPE及作用DTD(document type definition, 文档类型定义) 是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会用它来判断文档类型，决定用何种协议来解析，以及切换浏览器模式DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错 HTML5 的DOCTYPE头为&lt;!DOCTYPE html&gt;HTML4.0.1包含严格模式(strict)和宽松模式(loose)，不包括展示性和弃用元素 浏览器渲染过程 HTML通过解析生成DOM树，样式通过解析生成样式规则，DOM树和样式规则组合生成渲染树，渲染、绘制视图 重排reflowDOM结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow 触发reflow 增加、修改、删除DOM节点时，会导致reflow或repaint 移动DOM的位置，或是写动画的时候 修改CSS样式的时候 resize窗口的时候(移动端没有这个问题)，或是滚动的时候 修改网页的默认字体时(不允许突然修改字体，会导致浏览器出现问题) 重绘repaint当各种盒子的位置、大小以及其他属性，如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为repaint 触发repaint(界面变动都会触发repaint) DOM改动 CSS改动 运行机制浏览器是单线程的，先执行同步操作，再执行异步队列 异步任务 setTimeout和setInterval DOM事件 ES6中的Promise 总结 理解JS的单线程的概念 理解任务队列 理解Event Loop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类提升页面性能的方法资源压缩合并，减少HTTP请求非核心代码异步加载 → 异步加载的方式 → 异步加载的区别利用浏览器缓存 → 缓存的分类 → 缓存的原理使用CDN预解析DNS，https协议开头的，很多浏览器默认关闭dns预解析，需要执行第一行代码，强制开启预解析 // 强制打开a标签的预解析 异步加载异步加载的方式动态脚本加载deferasync异步加载的区别defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 浏览器缓存缓存分类强缓存(如果Expires和Cache-Contorl同时有，则以Cache-Control为优先)Expires Expires: Thu ,21 Jan 2018 23:59:23 GMT 以浏览器的时间作比较Cache-Control Cache-Control: max-age=3600 以服务器的时间作比较 协商缓存Last-Modified(服务器下发的) If-Modified-Since(客户端请求时带的) Last-Modified: Wed ,26 Jan 2018 00:34:23 GMTEtag(服务器下发) If-None-Match(客户端发起) 错误监控前端错误的分类 即时运行错误(代码错误) 资源加载错误 错误的捕获方式 即时运行错误的捕获方式try…catchwindow.onerror 资源加载错误(不会冒泡)object.onerrorperformance.getEntries()Error事件捕获(window.addEventListener(‘error’,fn, true)，在捕获阶段获取，不在冒泡阶段获取冒泡)延伸：跨域的js运行错误跨域捕获吗，错误提示什么，应该怎么处理？ 在script标签增加crossorigin属性设置js资源响应头Access-Control-Allow-Origin:* 上报错误的基本原理采用Ajax通信的方式上报利用Image对象上报((new Image()).src = ‘’，主要这个)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://xuehongjie.github.io/tags/html/"},{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"}]},{"title":"文件类型转换","slug":"front-end/js/file-type-conversion","date":"2018-12-23T00:10:50.000Z","updated":"2019-01-20T14:45:30.835Z","comments":true,"path":"front-end/js/file-type-conversion/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/file-type-conversion/","excerpt":"","text":"canvas转dataURL：canvas对象、转换格式、图像品质123function canvasToDataURL(canvas, format, quality) &#123; return canvas.toDataURL(format || &apos;image/jpeg&apos;, quality || 1.0);&#125; DataURL转canvas123456789101112function dataURLToCanvas(dataurl, cb) &#123; let canvas = document.createElement(&apos;canvas&apos;); let ctx = canvas.getContext(&apos;2d&apos;); let img = new Image(); img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); cb(canvas); &#125;; img.src = dataurl;&#125; image转canvas：图片地址123456789101112function imageToCanvas(src, cb) &#123; let canvas = document.createElement(&apos;canvas&apos;); let ctx = canvas.getContext(&apos;2d&apos;); let img = new Image(); img.src = src; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); cb(canvas); &#125;;&#125; canvas转image12345function canvasToImage(canvas) &#123; let img = new Image(); img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0); return img;&#125; File/Blob对象转DataURL1234567function fileOrBlobToDataURL(obj, cb) &#123; let a = new FileReader(); a.readAsDataURL(obj); a.onload = function (e) &#123; cb(e.target.result); &#125;;&#125; DataURL转Blob对象1234567891011function dataURLToBlob(dataurl) &#123; let arr = dataurl.split(&apos;,&apos;); let mime = arr[0].match(/:(.*?);/)[1]; let bstr = atob(arr[1]); let n = bstr.length; let u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type: mime&#125;);&#125; Blob转image1234567function blobToImage(blob, cb) &#123; fileOrBlobToDataURL(blob, function (dataurl) &#123; let img = new Image(); img.src = dataurl; cb(img); &#125;);&#125; image转Blob12345function imageToBlob(src, cb) &#123; imageToCanvas(src, function (canvas) &#123; cb(dataURLToBlob(canvasToDataURL(canvas))); &#125;);&#125; Blob转canvas12345function BlobToCanvas(blob, cb) &#123; fileOrBlobToDataURL(blob, function (dataurl) &#123; dataURLToCanvas(dataurl, cb); &#125;);&#125; canvas转Blob123function canvasToBlob(canvas, cb) &#123; cb(dataURLToBlob(canvasToDataURL(canvas)));&#125; image转dataURL12345function imageToDataURL(src, cb) &#123; imageToCanvas(src, function (canvas) &#123; cb(canvasToDataURL(canvas)); &#125;);&#125; dataURL转image，这个不需要转，直接给了src就能用12345function dataURLToImage(dataurl) &#123; let img = new Image(); img.src = d; return img;&#125; 将base64转换为文件 filename需要带后缀，否则会转成tmp 123456789101112function dataURLToFile(dataurl, filename) &#123; let arr = dataurl.split(&apos;,&apos;); let bstr = window.atob(arr[1]); let len = bstr.length; let u8arr = new Uint8Array(len); let mime = arr[0].match(/:(.*?);/)[1]; while (len--) &#123; u8arr[len] = bstr.charCodeAt(len); &#125; return new File([u8arr], filename, &#123;type: mime&#125;);&#125;","categories":[],"tags":[]},{"title":"正则","slug":"front-end/js/regexp","date":"2018-12-20T00:35:46.000Z","updated":"2019-01-20T14:44:55.514Z","comments":true,"path":"front-end/js/regexp/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/regexp/","excerpt":"","text":"正则应用场景文件夹命名1/[\\/\\\\:*?&quot;&lt;&gt;!]+/匹配特殊符号 去除字符串两端空白123String.prototype.trim ＝ function()&#123; return this.replace(/(∧\\s*)|(\\s*$)/g,&apos;&apos;);&#125; 匹配location.search中的请求参数123let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;)let match = str.match(reg)match[2] // 参数的值 参考链接一次性搞懂JavaScript正则表达式之语法","categories":[],"tags":[]},{"title":"错误捕获","slug":"front-end/js/error-catch","date":"2018-12-18T23:37:38.000Z","updated":"2019-01-20T14:42:05.562Z","comments":true,"path":"front-end/js/error-catch/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/error-catch/","excerpt":"","text":"Vue中的错误捕获123456789101112// 2.2.0+支持，2.4.0+支持自定义事件的捕获Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; window.onerror1234567window.onerror = (errorMessage, scriptURI, lineNo, columnNo, error) =&gt; &#123; console.log(&apos;errorMessage: &apos; + errorMessage); // 异常信息 console.log(&apos;scriptURI: &apos; + scriptURI); // 异常文件路径 console.log(&apos;lineNo: &apos; + lineNo); // 异常行号 console.log(&apos;columnNo: &apos; + columnNo); // 异常列号 console.log(&apos;error: &apos; + error); // 异常堆栈信息&#125;; window.addEventListener(‘error’)123window.addEventListener(&apos;error&apos;, (err) =&gt; &#123; console.log(err)&#125;) 参考链接https://www.cnblogs.com/luozhihao/p/8635507.html","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuehongjie.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"error","slug":"error","permalink":"https://xuehongjie.github.io/tags/error/"}]},{"title":"Canvas","slug":"front-end/js/canvas","date":"2018-12-16T23:39:44.000Z","updated":"2019-01-20T14:41:07.707Z","comments":true,"path":"front-end/js/canvas/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/canvas/","excerpt":"","text":"初始化1234567891011121314151617// 创建canvas对象var ctx = $(&quot;#canvas&quot;)[0].getContext(&apos;2d&apos;);var ctx2 = $(&quot;#canvas2&quot;)[0].getContext(&apos;2d&apos;);// 设置线条颜色ctx.strokeStyle = &apos;#00f&apos;;// 设置填充颜色ctx.fillStyle = &apos;#f00&apos;;//fillRect(x, y, width, height)// 绘制有颜色填充的矩形,参数：起始坐标ctx.fillRect(0,0,100,50);//strokeRect(x, y, width, height)// 绘制无填充色的矩形ctx.strokeRect(150,0,100,50); 文本1234567891011121314151617181920// 设置字体大小和字体ctx.font = &apos;30px Arial&apos;;ctx.cont = &apos;italic 30px serif&apos;; // 斜体// 绘制实心文字ctx.fillText(&apos;Canvas&apos;,150,25);// 绘制空心文字ctx.strokeText(&apos;Canvas&apos;,0,25); // 设置颜色渐变var grd = ctx.createLinearGradient(0,0,100,0); //参数：起始坐标(x0,y0),终止坐标(x1,y1)grd.addColorStop(0,&apos;blue&apos;); //指定停止颜色,值为0-1grd.addColorStop(0.5,&apos;white&apos;);grd.addColorStop(1,&apos;red&apos;);ctx.fillStyle = grd;ctx.fillRect(0,50,100,50); //clearRect(x, y, width, height)ctx.clearRect(0,30,10,10); //清空矩形区域的内容,参数：x坐标,y坐标,宽度,高度 线条12345678910//moveTo(x, y)// 定义线条开始的坐标ctx2.moveTo(0,0);//lineTo(x, y)// 定义线条结束的坐标ctx2.lineTo(200,100);// 绘制线条，或者使用fillctx2.stroke(); 圆1234567// 重新生成一条路径ctx2.beginPath();//arc(x, y, radius, startAngle, endAngle, anticlockwise)// 绘制圆形，参数：x坐标，y坐标，圆的半径，起始角度，终止角度;anticlockwise：false为顺时针，true为逆时针(默认为false)ctx2.arc(100,50,30,0,Math.PI * 2,false);ctx2.stroke(); 绘制圆弧12345ctx2.beginPath();ctx2.moveTo(25,50);ctx2.arc(25,50,25,0,Math.PI * 0.5,false); //参数：x坐标，y坐标，半径，起始角度(圆的正右方开始)，终止角度，是否逆时针(false为顺时针，true为逆时针)ctx2.lineTo(25,50)ctx2.stroke(); 参考链接https://www.cnblogs.com/charmingyj/p/5527223.html","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://xuehongjie.github.io/tags/canvas/"}]},{"title":"对象","slug":"front-end/js/object","date":"2018-12-16T23:28:19.000Z","updated":"2019-01-19T15:48:10.395Z","comments":true,"path":"front-end/js/object/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/object/","excerpt":"","text":"判断是不是数组/对象123456789// 是否为数组if(typeof Array.isArray===&quot;undefined&quot;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos; &#125;;&#125;// 是否为对象Object.prototype.toString.call(arg) === &apos;[object Object]&apos; defineProperty/defineProperties123456789writable、value和set、get不能同时存在Object.defineProperty(obj, prop, &#123; configurable: false, //是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置 enumerable: false, //枚举性，表示是否可以通过for-in循环返回 writable: false, //可写性：是否可以修改属性的值 value: undefined, //包含属性的值，也就是对应的可读性。 set: undefined, get: undefined&#125;) 对象拷贝浅拷贝 Object.assign(obj) 扩展运算符(…) {...obj} let obj = Object.defineProperties({}, Object.getOwnPropertyDescriptors(copyObj)) 深拷贝 JSON.parse(JSON.stringify(obj))局限性 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 MessageChannel，不支持包含函数的对象，异步，支持Android4.4+1234567function deepCopy(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125; new的过程 创建一个新对象 将构造函数的作用域赋值给新对象 执行构造函数的代码 返回新的对象 禁止扩展方法preventExtensions禁止对象扩展，可修改已有的值，可以通过defineProperty重新定义已有属性，Object.preventExtensions(obj) isExtensible判断对象是否可扩展，Object.isExtensible(obj) seal禁止对象扩展，可修改已有的值，不可以通过defineProperty重新定义已有属性，Object.seal(obj) isSealed判断对象是否密封，Objct.isSealed(obj) freeze冻结对象，返回冻结的对象，不能做任何操作，只能读取，Object.freeze(obj) isFrozen判断对象是否冻结，Object.isFrozen(obj) 汇总表格 函数 对象已设置为不可扩展的 为每个属性将configurable设置为false 为每个属性将writable设置为false Object.preventExtensions 是 否 否 Object.seal 是 是 否 Object.freeze 是 是 是 函数 对象是否可扩展 为每个属性将configurable设置为false 为每个属性将writable设置为false Object.isExtensible 是 否 否 Object.isSealed 否 是 是 Object.isFrozen 否 是 是 其他原型链的顶层是什么Object.prototype.__proto__ // null Object.create(null)、new Object()、{}的区别Object.create(null)创建的对象没有继承Object的属性和方法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"Object","slug":"Object","permalink":"https://xuehongjie.github.io/tags/Object/"}]},{"title":"事件","slug":"front-end/js/event","date":"2018-12-15T23:17:49.000Z","updated":"2019-02-21T04:09:06.700Z","comments":true,"path":"front-end/js/event/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/event/","excerpt":"","text":"事件级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(‘click’, function(){}, false) IE:attachEventListener DOM3 element.addEventListener(‘keyup’, function(){}, false) 事件流捕获 → 目标阶段 → 冒泡 事件流 DOM事件捕获的具体流程如何获取html标签：document.documentElementwindow → document → html → body → … → 目标元素 → … → body → html → document → window 事件的绑定与解绑事件绑定123456789addEventListener(type, fn, useCapture/options)useCapture: 默认为false，监听冒泡阶段options可传值： - passive: false 是否阻止默认事件；如果设置为true，则即使在触发的函数中使用e.preventDefault也不会生效 - capture: false 触发阶段；true为捕获时触发，false为冒泡时触发 - once: 只执行一次IEattachEvent(&apos;on&apos; + type, listener); 事件解绑12345// 传值与绑定相同removeEventListener(type, fn, useCapture/options)IEdetachEvent(&apos;on&apos; + type, listener); 单线程和异步的关系 单线程，只有一个线程，只能做一件事，两段JS不能同时执行 原因，避免DOM渲染冲突 浏览器需要渲染DOM JS可以修改DOM JS执行时，浏览器DOM渲染暂停 两端JS不能同时执行(都修改DOM就冲突了) webworker支持多线程，但不能访问DOM 解决方案，异步 Event对象的常见应用 event.preventDefault() // 阻止默认事件 event.stopPropagation() // 阻止事件冒泡 event.stopImmediatePropagation() // 阻止事件继续执行，即一个DOM绑定多个事件，执行该方法会阻止在该回调后注册的回调函数的执行 event.currentTarget // 绑定事件的元素 event.target // 触发事件的元素 自定义事件 Event()构造函数, 创建一个新的事件对象 Event 利用addEventListener中的handleEvent CustomEvent()创建一个自定义事件 document.createEvent()创建一个新的事件（Event），随之必须调用自身的init方法进行初始化。 使用Event1234567891011121314151617181920212223let evt = new Event(&apos;custom&apos;);document.addEventListner(&apos;custom&apos;, function()&#123; console.log(&apos;custom&apos;);&#125;)document.dispatchEvent(evt);// 使用new Event(不能使用自定义参数detail)var ev = new Event(&apos;test&apos;, &#123; bubbles: &apos;true&apos;, cancelable: &apos;true&apos;, detail: &#123;&#125;, // 细节参数、自定义参数 test: &apos;test&apos;,&#125;);document.addEventListener(&apos;test&apos;, function (event) &#123; console.log(event.bubbles); // true 返回布尔值 console.log(event.cancelable); // true 返回布尔值 console.log(event.detail); // undefined console.log(event.test); // undefined&#125;, false);document.dispatchEvent(ev); 使用handleEvent12345678var tap = &#123; handleEvent: function(e) &#123; console.log(this.name); // tap &#125;, name:&apos;tap&apos;&#125;;document.addEventListener(&apos;click&apos;, tap, false); 使用CustomEvent1234567891011121314document.addEventListener(&apos;tap&apos;, function(e)&#123; console.log(&apos;custom &apos; + e.detail.test); // custom test&#125;, false);var evt = new window.CustomEvent(&apos;tap&apos;, &#123; bubbles: true, // 如果为 true，事件将冒泡到触发事件的元素的祖先 cancelable: true, // 如果为 true，可以使用事件对象的 stopPropagation() 方法取消事件传播。 detail: &#123; test: &apos;test&apos;, &#125; // 细节参数、自定义参数&#125;);// 触发自定义事件，返回一个布尔值，判断是否阻止默认事件，false为阻止默认事件document.dispatchEvent(evt); 使用createEvent12345let evt = document.createEvent(&quot;HTMLEvents&quot;); // 可传值HTMLEvents、MouseEvents、UIEvents以及CustomEvent(自定义事件)// 初始化evt.initEvent(&quot;alert&quot;, false, false); // eventType,canBubble,cancelable// 触发week.dispatchEvent(evt); 监听storage事件12345678910111213let setStorage = (key, newVal) =&gt; &#123; let newStorageEvent = document.createEvent(&apos;StorageEvent&apos;); const storage = &#123; setItem(key, val) &#123; localStorage.setItem(key, val); // 初始化创建的事件 newStorageEvent.initStorageEvent(&apos;setItem&apos;, false, false, key, null, val, null, null); // 派发对象 window.dispatchEvent(newStorageEvent); &#125; &#125; return storage.setItem(key, newVal);&#125; touch事件移动web页面上的click事件响应都要慢上300ms使用自定义tap事件代替click事件 自定义tap事件原理在touchstart、touchend时记录时间、手指位置，在touchend时进行比较，如果手指位置为同一位置(或允许移动一个非常小的位移值)且时间间隔较短(一般认为是200ms)，且过程中未曾触发过touchmove，即可认为出发了手持设备上的”click”，一般称它为”tap” tap穿透的解决方案 使用缓动动画，过渡300ms的延迟 中间层dom元素的加入，让中间层接受这个“穿透”事件，稍后隐藏 “上下”都使用tap事件，原理上解决tap穿透事件(但不可避免原生标签的click事件) 改用Fastclick的库 触摸事件touchstart: 手指触摸屏幕触发(已经有手指放屏幕上不会触发)touchmove: 手指在屏幕华东，连续触发touchend: 手指离开屏幕时触发touchcancel: 系统取消touch时候触发(不常用) 触摸属性touches: 跟踪触摸操作的touch对象数组targetTouches: 特定事件目标的touch对象数组changeTouches: 上次触摸改变的touch对象数组 每个touch对象包含属性clientX: 触摸目标在视口中的x坐标clientY: 触摸目标在视口中的y坐标identifier: 标识触摸的唯一IDpageX: 触摸目标在页面中的x坐标(包含滚动)pageY: 触摸目标在页面中的y坐标(包含滚动)screenX: 触摸目标在屏幕中的x坐标screenY: 触摸目标在屏幕中的y坐标target: 触摸目标的DOM节点 参考链接https://www.cnblogs.com/diligenceday/p/4175721.htmlhttps://www.imooc.com/article/71101","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"Event","slug":"Event","permalink":"https://xuehongjie.github.io/tags/Event/"}]},{"title":"移动端屏幕像素","slug":"front-end/other/mobile-screen-pixels","date":"2018-12-14T22:12:06.000Z","updated":"2019-01-11T15:59:11.117Z","comments":true,"path":"front-end/other/mobile-screen-pixels/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/mobile-screen-pixels/","excerpt":"","text":"Pixel 移动开发像素知识px: css pixels 逻辑像素，浏览器使用的抽象单位dp,pt: device independent pixels 设备无关像素dpr: devicePixelRatio 设备像素缩放比 计算公式：1px = (dpr)² * dp DPI: 打印机每英寸可以喷的墨汁点(印刷行业)PPI: 屏幕每英寸的像素数量，即单位英寸内的像素密度 计算公式：以iPhone5为例子ppi = √ (1136² + 640²) / 4 = 326ppi (视网膜Retina屏) ldpi mdpi hdpi xhdpi ppi 120 160 240 320 默认缩放比 0.75 1.0 1.5 2.0 Retina屏(高清屏): dpr都是大于等于2 PPI越高，像素数越高，图像越清晰但可视度越低(小)，系统默认设置缩放比越大 Viewport手机浏览器默认为我们做两件事 页面渲染在980px(ios)的viewport(为了排版正确) 缩放(排版正确后，再缩放到手机屏幕大小) //这就是网页在手机上，会全屏显示的原因 visual viewport：度量/视口viewport宽高visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。// 无法改变，通过缩放scale控制layout viewport: 布局viewport 如图，ios的默认layout viewport为980px// 可以理解为就是body的宽度，在此之上渲染页面 为什么不适用默认的980px的布局viewport(layout viewport) 宽度不可控制，不同系统不同设备的默认值都可能不同 页面先在layout viewport全屏渲染css,再通过缩放由visual viewport展示，交互不友好 链接不可点 有缩放，缩放后又有滚动 font-size:40px=PC的12px,不规范，字体设置是另外一门学问了。 meta标签123456&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot;&gt;width: 设置布局viewport的特定值(device-width)initial-scale: 设置页面的初始缩放minimum-scale: 最小缩放maximum-scale: 最大缩放user-scalable: 用户能否缩放 最常用写法&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt; 方案一：根据设备的实际宽度来设计(常用)手机宽320px，拿320px设计方案二：1px=1dp缩放0.5。根据设备的物理像素dp等于抽象像素px来设计。1像素边框和高清图片都不需要额外处理。 响应式设计媒体类型：screen // 屏幕print // 打印机handheld // 手持设备all // 通用 常用媒体查询参数：width // 视口宽度height // 视口高度device-width // 设备宽度device-height // 设备高度orientation // 定义输出设备中的页面可见区域高度是否大于或等于宽度。大于或等于为portrait(竖屏)，其余为landscape(横屏) @media screen and (max-width: 300px) {}","categories":[],"tags":[]},{"title":"面试记录","slug":"front-end/other/interview-record","date":"2018-12-13T22:23:55.000Z","updated":"2019-03-10T07:59:14.541Z","comments":true,"path":"front-end/other/interview-record/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/interview-record/","excerpt":"","text":"记录一个页面上两个div左右铺满整个浏览器，要保证左边的div一直为100px，右边的div跟随浏览器大小变化（比如浏览器为500，右边div为400，浏览器为900，右边div为800），请写出大概的css代码。 .box {width: 100%;height: 100px;display: flex;flex-direction: row;align-items: center;border: 1px solid #c3c3c3;}.box-left {flex-basis:100px;-webkit-flex-basis: 100px;background-color: red;height: 100%;}.box-right {height: 100%;background-color: blue;flex-grow: 1;} 使用flex 12345678910111213141516171819202122//html&lt;div class=&apos;box&apos;&gt;&lt;div class=&apos;left&apos;&gt;&lt;/div&gt;&lt;div class=&apos;right&apos;&gt;&lt;/div&gt;&lt;/div&gt;//css.box &#123; width: 100%; height: 100px; display: flex; flex-direction: row; align-items: center; border: 1px solid #c3c3c3;&#125;.left &#123; flex-basis: 100px; -webkit-flex-basis: 100px; background-color: red; height: 100%;&#125;.right &#123; flex-grow: 1; height: 100; background-color: blue;&#125; 浮动布局 123456789101112131415161718&lt;div id=&quot;left&quot;&gt;Left sidebar&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;Main Content&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;#left &#123; float: left; width: 220px; background-color: green;&#125;#content &#123; background-color: orange; margin-left: 220px; /*==等于左边栏宽度==*/&#125;&lt;/style&gt; 请写出一些前端性能优化的方式，越多越好 减少dom操作 部署前，图片压缩，代码压缩 优化js代码结构，减少冗余代码 减少http请求，合理设置 HTTP缓存 使用内容分发cdn加速 静态资源缓存 图片延迟加载 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器查找域名的 IP 地址 这一步包括 DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从http://example.com到http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求 请大概描述下页面访问cookie的限制条件 跨域问题 设置了HttpOnly 描述浏览器重绘和回流，哪些方法能够改善由于dom操作产生的回流 直接改变className，如果动态改变样式，则使用cssText 1234567891011// 不好的写法var left = 1;var top = 1;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;; // 比较好的写法el.className += &quot; className1&quot;;// 比较好的写法el.style.cssText += &quot;;left: &quot; + left + &quot;px;top: &quot; + top + &quot;px;&quot;; 让要操作的元素进行”离线处理”，处理完后一起更新 123a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；b) 使用display:none技术，只引发两次回流和重绘；c) 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘 vue生命周期钩子 beforcreate created beformount mounted beforeUpdate updated actived deatived beforeDestroy destroyed js跨域请求的方式，能写几种是几种 通过jsonp跨域 通过修改document.domain来跨子域 使用window.name来进行跨域 使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持） CORS 需要服务器设置header ：Access-Control-Allow-Origin。 nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求 对前端工程化的理解 开发规范 模块化开发 组件化开发 组件仓库 性能优化 项目部署 开发流程 开发工具 js深度复制的方式 使用jq的$.extend(true, target, obj) newobj = Object.create(sourceObj)，// 但是这个是有个问题就是newobj的更改不会影响到 sourceobj但是 sourceobj的更改会影响到newObj newobj = JSON.parse(JSON.stringify(sourceObj)) js设计模式: 总体来说设计模式分为三大类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式 图片预览 123456789101112&lt;input type=&quot;file&quot; name=&quot;file&quot; onchange=&quot;showPreview(this)&quot; /&gt;&lt;img id=&quot;portrait&quot; src=&quot;&quot; width=&quot;70&quot; height=&quot;75&quot;&gt;function showPreview(source) &#123; var file = source.files[0]; if(window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function(e) &#123; document.getElementById(&quot;portrait&quot;).src = e.target.result; &#125;; fr.readAsDataURL(file); &#125;&#125; 扁平化多维数组 老方法 123456789101112var result = []function unfold(arr)&#123; for(var i=0;i&lt; arr.length;i++)&#123; if(typeof arr[i]==&quot;object&quot; &amp;&amp; arr[i].length&gt;1) &#123; unfold(arr[i]); &#125; else &#123; result.push(arr[i]); &#125; &#125;&#125;var arr = [1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];unfold(arr) 使用tostring 12var c=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];var b = c.toString().split(&apos;,&apos;) 使用es6的reduce函数 123var arr=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];const flatten = arr =&gt; arr.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);var result = flatten(arr) iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 数组乱序 方法一 123456789function shuffle(a) &#123; var len = a.length; for (var i = 0; i &lt; len - 1; i++) &#123; var index = parseInt(Math.random() * (len - i)); var temp = a[index]; a[index] = a[len - i - 1]; a[len - i - 1] = temp; &#125;&#125; 方法二 12345678function shuffle(arr)&#123; return arr.sort(() =&gt; &#123; return Math.random() &gt; 0.5 ? -1:1 &#125;)&#125;function shuffle(arr) &#123; arr.sort(() =&gt; Math.random() - 0.5);&#125; new Function的写法 1var message = new Function(&apos;msg&apos;,&apos;alert(msg)&apos;); 原型链顶层 Object.prototype 如何覆盖组件库的px 在style里面直接用样式覆盖编写webpack的loader，在loader中将px转换成rem axios相比vue-resource的优势 axios可以用于服务端渲染 代码题 12345678910var test = (function(a)&#123; this.a = a * 2; // 立即执行函数的this指向window return function(b)&#123; return this.a + b; &#125;&#125;)((function(a)&#123; return a&#125;)(1,2))console.log(test(4)) // 6 1234new Array == new Array // false[0].concat(new Array(3)).filter(item =&gt; item === undefined) // []Array.prototype.__proto__ === Object.prototype // truenull instanceof Object // false 123let str = &apos;123abc&apos;str++ // NaNtypeof str // number 12345678910var length = 10;function fn() &#123; console.log(this.length); &#125;var obj = &#123; length: 5, method: function() &#123; fn(); // this指向window arguments[0](); // this指向arguments &#125;&#125;obj.method(fn, 1); // 10 2 cookie、sessionStorage、localStorage的区别 cookie会带在请求头上 sessionStorage、localStorage提供了api，cookie要自己封装 sessionStorage关闭浏览器页签就清除，localStorage要手动清除 存储大小不同，cookie为4K，sessionStorage、localStorage为5M 写出实现下面功能的代码 LazyMan(‘Hank’)Hi This is Hank LazyMan(‘Hank’).sleep(10).eat(‘dinner’)输出Hi This is Hank// 等待10秒Eat dinner LazyMan(‘Hank’).eat(‘dinner’).eat(‘supper’)Hi This is HankEat dinnerEat supper LazyMan(‘Hank’).sleepFirst(5).eat(‘supper’)// 等待5秒Hi This is HankEat supper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class _LazyMan &#123; constructor(name) &#123; this.name = name this.todo = [] this.sayHi() setTimeout(async () =&gt; &#123; for(let handler of this.todo) &#123; await handler() &#125; &#125;) &#125; sayHi() &#123; this.todo.push(() =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log(`Hi This is $&#123;this.name&#125;`) resolve() &#125;) &#125;) return this &#125; sleepHandler(time) &#123; return () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000 * time) &#125;) &#125; &#125; sleep(time) &#123; this.todo.push(this.sleepHandler(time)) return this &#125; sleepFirst(time) &#123; this.todo.unshift(this.sleepHandler(time)) return this &#125; eat(thing) &#123; this.todo.push(() =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log(`Eat $&#123;thing&#125;`) resolve() &#125;) &#125;) return this &#125;&#125;function LazyMan(name) &#123; return new _LazyMan(name)&#125; 明源云状态码及其表达的意思 200 请求成功 204 请求成功，但没有返回响应实体 401 当前请求需要用户验证 403 禁止访问 404 资源未找到 408 请求超时 500 后台程序错误 axios发起请求会有两个的原理，axios跨域处理 OPTIONS是预请求，判断其是否能支持跨域 vuex原理 svn和git的区别 使用ES5或者ES6实现单例模式 ES5 1234567891011121314var Single = function(name)&#123; this.name = name; // 一个标记，用来判断是否已经创建了该类的实例 this.instance = null;&#125;// 提供了一个静态方法，用户可以直接在类上调用Single.getInstance = function(name)&#123; // 没有实例化的时候创建一个该类的实例 if (!this.instance) &#123; this.instance = new Single(name) &#125; // 已经实例化了，返回第一次实例化对象的引用 return this.instance;&#125; ES6 12345678910111213class Single &#123; constructor(name) &#123; this.name = name; this.instance = null; &#125; // 构造一个广为人知的接口，供用户对该类进行实例化 static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Single(name); &#125; return this.instance; &#125;&#125; 代码题 1234567891011var test = function(a, b)&#123; alert(b); return &#123; test: function(c)&#123; return test(c, a) &#125; &#125;&#125;var a = test(100);a.test(200);a.test(300); // undefined 100 100var a = test(101).test(201).test(301); // undefined 101 201var a = test(102).test(202);a.test(302); // undefined 102 202 Promise链式调用其中一个报错，如何让其继续运行 在catch中捕获错误 AMD和CMD的异同 相同点 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 不同点 定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。 遵循的规范不同。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。 推广理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。 对开发调试的支持有差异。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。 插件机制不同。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。 1234567891011121314CMD 推崇依赖就近，AMD 推崇依赖前置。//CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() &#125;)// AMD 默认推荐的是define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;// 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething()&#125;) 工厂模式 数组转父子树形数据 12345678910111213141516171819202122232425262728let data = [ &#123;parent_id: 0, id: 1, value: &apos;xxx&apos;&#125;, &#123;parent_id: 1, id: 2, value: &apos;xxx&apos;&#125;, &#123;parent_id: 1, id: 3, value: &apos;xxx&apos;&#125;, &#123;parent_id: 2, id: 4, value: &apos;xxx&apos;&#125;,]let dataMap = &#123;&#125; // 存储所有数据的子数据let root = data.filter(item =&gt; &#123; let key = item.parent_id if(!dataMap[key]) &#123; dataMap[key] = [] &#125; dataMap[key].push(item) return data.findIndex(fData =&gt; fData.id === item.parent_id) === -1&#125;)function getChild(item) &#123; let child = dataMap[item.id] || [] if(child.length) &#123; item.children = child child.forEach(cItem =&gt; &#123; getChild(cItem) &#125;) &#125;&#125;root.forEach(item =&gt; &#123; getChild(item)&#125;) 旺合盛世rem和百分比的优缺点 iframe的优缺点 优点 iframe能够原封不动的把嵌入的网页展现出来 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度) 缺点 页面样式调试麻烦，出现多个滚动条； 浏览器的后退按钮失效； 过多会增加服务器的HTTP请求； 小型的移动设备无法完全显示框架； 产生多个页面，不易管理； 不容易打印； 代码复杂，无法被一些搜索引擎解读。 星斯达什么是MVC，MVC的框架又哪些 如何通过正则匹配协议 12location.href.match(/(\\w*):\\/\\//)[&quot;https://&quot;, &quot;https&quot;, index: 0, input: &quot;https://www.bilibili.com/video/av11314749/&quot;,length: 2] js实现二分树 智游人vue-router中history和hash模式有什么区别 hash模式的话路由地址会带上#，但是浏览器发送给服务端的却实#之前的URL，hash模式的好处是，虽然你是个单页面应用，但你可以刷新当前页。history的话需要服务端配合，如果服务端配置仅仅是找不到路由，就重定向到index.html，那么刷新会跳首页，如果服务端对于匹配不到URL不做配置，那么一般返回404页面 样式优先级 important &gt; 内联样式 &gt; id选择器 &gt; 类选择器、伪类选择器(:hover)、属性选择器 &gt; 伪元素选择器(::before)、标签选择器 冒泡排序 123456789101112function arrSort (arr) &#123; var i, j, tmp, len = arr.length - 1; for(i = 0; i&lt; len; i++) &#123; for(j = 0; j &lt; len - i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; // 升序 tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125;&#125; 开拍网DOM操作方法 123456parent.appendChild(child) 增加子元素parent.removeChild(child) 删除子元素parent.replaceChild(new, old) 替换子元素parent.insertBefore(new, existsDOM) 向已有子节点添加元素element.nextSibling 返回元素相邻的下一个元素element.previousSibling 返回元素相邻的上一个元素 妙印云flex宽度计算 写出item-1、item-2、item-3的宽度 .parent {display: flex;width: 100%;height: 100px;background-color: blue;color: #fff;}.item-1 {flex: 2 1 0%;background-color: red;}.item-2 {flex: 2 1 auto;background-color: green;}.item-3 {flex: 1 1 200px;} 1234567891011121314151617181920&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item-3&quot;&gt;&lt;/div&gt;&lt;/div&gt;.parent &#123; display: flex; width: 600px; height: 100px;&#125;.item-1 &#123; flex: 2 1 0%;&#125;.item-2 &#123; flex: 2 1 auto;&#125;.item-3 &#123; flex: 1 1 200px;&#125; 在子元素的flex-basis加起来小于父元素的宽度时用父容器宽度减去flex-basis的宽度，然后再根据flex-grow去计算扩张的值， 用sort打乱数组 123function shuffle(arr) &#123; arr.sort(() =&gt; Math.random() - 0.5);&#125; 实现add(1)(2)(3)，结果返回6的函数 123456789101112131415161718const curry = (fn, ...arg) =&gt; &#123; let all = arg || [], length = fn.length; return (...rest) =&gt; &#123; let _args = all.slice(0); //拷贝新的all，避免改动公有的all属性，导致多次调用_args.length出错 _args.push(...rest); if (_args.length &lt; length) &#123; return curry.call(this, fn, ..._args); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125;let add = curry(function(a, b, c) &#123; console.log(a + b + c);&#125;)add(1)(2)(3)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://xuehongjie.github.io/tags/html/"},{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"},{"name":"interview","slug":"interview","permalink":"https://xuehongjie.github.io/tags/interview/"}]},{"title":"项目中的那些事","slug":"front-end/other/problems-encountered-in-the-project","date":"2018-12-12T22:03:31.000Z","updated":"2020-03-01T16:10:04.006Z","comments":true,"path":"front-end/other/problems-encountered-in-the-project/","link":"","permalink":"https://xuehongjie.github.io/front-end/other/problems-encountered-in-the-project/","excerpt":"","text":"vue界面渲染时出现花括号{}123456在挂载vue的标签上使用v-cloak，设置v-cloak属性的样式，vue渲染完后会自动移除该属性&lt;div class=&quot;app&quot; v-cloak&gt;&lt;/div&gt;[v-cloak]&#123; display: none;&#125; 使用:style或:class绑定时，key名带中划线(-)问题1用引号将该key包裹起来，:style=&#123;&apos;background-color&apos;: &apos;#fff&apos;&#125; 错误捕获 2.2.0+可用, 2.4.0+支持自定义事件的捕获 123456789101112Vue.config.errorHandler捕获钩子函数的报错信息，只能捕获钩子函数的错Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 使用ref绑定问题如果绑定的元素为遍历元素，则生成的refs为数组 vue-router在history模式下使用子路由刷新报错问题修改assetsPublicPath路径，使用绝对路径 style标签使用scoped的时候无法覆盖子组件样式1234解决方法:1. 去掉scoped2. 混用本地和全局样式，即增加一个style标签，不写scoped，进行样式覆3. 使用深度选择器 /deep/或者&gt;&gt;&gt;，如.a /dep/ .b&#123;&#125; 进入详情页要缓存，从首页进入时要刷新的处理方法1234567891011121314151617181920212223242526使用keep-alive，在router中定义keeyAlive，在App.vue中&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;js代码：watch: &#123; $route: &#123; handler(to, from) &#123; if (to.name === &apos;Home&apos;) &#123; this.$refs.customerList.clearStatus(); from.meta.reload = true; &#125; &#125; &#125;&#125;,created() &#123; this.loadData();&#125;,activated() &#123; if (this.$route.meta.reload) &#123; this.loadData(); this.$route.meta.reload = false; &#125;&#125; style标签使用scss的@import相对路径问题1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;], alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;src&apos;), &#125;&#125;引用时，@import &apos;~@/scss/icon.scss&apos;; Duplicate presence of slot “titleName” found in the same render tree1234使用具名插槽slot-scope&lt;template slot=&quot;titleName&quot; slot-scope=&quot;props&quot;&gt; &lt;span class=&quot;order-title&quot;&gt;采购订单&lt;/span&gt;&lt;/template&gt; IOS日期转换问题12日期中不允许有-，需要replace(/-/g, &apos;/&apos;)才可以进行new Date()日期中不允许有.0，如(2018-09-06 00:00:00.0)，需要replace(/\\..*/g,&apos;&apos;)替换处理 IOS7伸缩盒兼容性问题使用伸缩盒时加webkit前缀，使用box IOS9元素运行动画后不显示问题121. z-index没有设置或者太小2. 没有设置animation-fill-mode: forwards animation-play-state失效问题1234567添加父容器，在暂停的时候给父容器加transformlet container = this.$refs.musicContainerlet musicT = getComputedStyle(this.$refs.music).transformlet containerT = getComputedStyle(container).transformlet transform = containerT === &apos;none&apos; ? musicT : musicT.concat(&apos; &apos;, containerT)container.style.transform = transformcontainer.style.webkitTransform = transform 滚动暂停问题121. 将滚动容器从body改为app，设置-webkit-overflow-scrolling:touch，该属性会造成scroll事件只会在滚动停止的时候执行一次2. 使用滚动插件(如better-scroll) 使用-webkit-overflow-scrolling:touch问题如果触发了外层容器的弹性滚动，则该元素短时间内会无法滚动，可以使用better-scroll来实现滚动 IOS的弹性滚动 body层滚动(系统特殊化处理):自带弹性滚动，overflow: hidden失效，GIF和定时器暂停 局部滚动:没有弹性滚动，没有惯性滚动，不流畅局部滚动开启弹性滚动(仅支持IOS)设置滚动容器-webkit-overflow-scrolling: touch; 上拉加载使用scroll事件，而不是touch事件(因为android中会有bug) -webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug在使用该属性的元素上不设置定位或者手动设置定位为static在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。 -webkit-overflow-scrolling:touch还会导致的bug 滚动中 scrollTop 属性不会变化 手势可穿过其他元素触发元素滚动 滚动时暂停其他 transition Android打开view时界面会有空白问题在mounted中使用setTimeout进行font-size的设置 Android4.3中设置background的大小不生效通过background-size设置 4.3版本的svg无法使用transform用div将svg包裹起来，设置div的transform 兼容低版本css带webkit的css要放在后面 Android4系统touchmove问题在touchmove的时候会执行touchcancel事件，导致touchmove只执行一次，需要使用e.preventDefault阻止默认事件才可以执行多次，但是会导致一些默认行为不触发，如scroll click事件失效问题父元素的touch事件加了preventDefault导致子元素的click事件不触发，修改子元素的click事件为touch事件 动画由大变小闪动问题123给动画元素的父容器加position: relative;overflow: hidden; 安卓手机音频无法自动播放通过touch事件手动触发播放 插件在元素隐藏的时候new Swiper，Swiper会有错位问题 设置obserVer和observParents为true 1234new Swiper(this.$refs.swiperContainer, &#123; observer: true,//修改swiper自己或子元素时，自动初始化swiper observeParents: false,//修改swiper的父元素时，自动初始化swiper&#125;); 显示的时候手动调用update方法 better-scroll内的子元素无法通过overflow滚动 better-scroll的bug vue中同事使用keep-alive和better-scroll同时使用keep-alive和better-scroll时，better-scroll注册的事件不会自动销毁，需要手动调用bScroll.destroy()方法进行销毁。 svg使用animate时，animate动画不运行121. 获取animate的DOM，调用beginElement方法执行动画2. animate的dur设置的时间太小(小于25ms)，动画不会执行 JScanvas绘制问题绘制前需要设置canvas的宽高 记录 引用时如果存在目录和文件名相同，优先寻找目录下的index.js文件 工具使用webstorm时无法自动编译问题取消webstorm的自动保存功能 http401状态码登录token有问题 好车主APP某些机型打开健步行时白屏问题绘制圆环canvas的时候没有获取到DOM导致webview奔溃，在$nextTick的时候绘制canvas，后面改成了SVG aopsId获取失败连续调用了相同的客户端方法，导致前面的被覆盖 监听APP前后台切换通过postEvent方法监听webview的切换 因为手机设置字体大小导致样式错位问题安卓客户端通过webview配置webview.getSettings().setTextZoom(100)就可以禁止缩放，按照百分百显示。 微信/企业微信微信端无法自动播放音频问题 使用微信提供的js-sdk，在ready中调用播放的API 1234567891011121314151617//首先引用js: &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;//然后写方法: function autoPlayAudio1()&#123; wx.config(&#123; //配置信息, 即使不正确也能使用 wx.ready debug: false, appId: &apos;&apos;, timestamp: 1, nonceStr: &apos;&apos;, signature: &apos;&apos;, jsApiList: [] &#125;); wx.ready(function() &#123; document.getElementById(&apos;audio&apos;).play(); &#125;);&#125; 监听WeixinJSBridgeReady事件 1234var audio=document.querySelector(&quot;#audio&quot;); document.addEventListener(&quot;WeixinJSBridgeReady&quot;,function()&#123; audio.play();&#125;, false); 隐藏分享栏1WeixinJSBridge.call(&apos;hideOptionMenu&apos;) 企业微信注册报invalid signture 在home界面调用注册方法会报错，修改调用的位置至需要使用新建表单页面 后台返回的时间戳单位需要为秒，注册的url需要encodeURIComponent再传给后台，由后台decode 项目用的是history模式，每个页面使用sdk都需要重新调用注册方法 url不调用encodeURIComponent的话链接上通过&amp;字符连接起来的参数会不被加入签名中 安卓手机无法预览图片12345调用接口时，urls必须传wx.previewImage(&#123; current: imgUrl, // 当前显示图片的http链接 urls: [imgUrl] // 需要预览的图片http链接列表&#125;); 金雅福123456789// post上传文件报400let formData = new FormData()formData.append(&apos;key&apos;, data)formData.append(&apos;content-type&apos;, &apos;&apos;)formData.append(&apos;x-obs-acl&apos;, &apos;&apos;)formData.append(&apos;AccessKeyId&apos;, &apos;&apos;)formData.append(&apos;policy&apos;, &apos;&apos;)formData.append(&apos;signature&apos;, &apos;&apos;)formData.append(&apos;file&apos;, file) // file参数需要在最后","categories":[],"tags":[]},{"title":"日常小记-JS","slug":"front-end/js/daily-notes","date":"2018-12-11T23:59:39.000Z","updated":"2019-03-02T16:22:29.804Z","comments":true,"path":"front-end/js/daily-notes/","link":"","permalink":"https://xuehongjie.github.io/front-end/js/daily-notes/","excerpt":"","text":"$(“p”).empty与$(“p”).remove1234$(&quot;p&quot;).empty移除p标签中的文本及其子节点，留下p标签$(&quot;p&quot;).remove移除p标签及其文本内容还有其子节点 事件绑定12345678910111213DOM2级事件addEventListener(type, listener, useCapture/options);removeEventListener(type, listener, useCapture/options);useCapture: 默认为false，监听冒泡阶段options: &#123; capture: Boolean, // 是否在捕获阶段触发事件 passive: Boolean, // 使preventDefault调用无效，可优化界面滚动效果 once: Boolean, // 是否执行一次&#125;IEattachEvent(&apos;on&apos; + type, listener);detachEvent(&apos;on&apos; + type, listener); 消除事件处理器的影响 图解浏览器的工作原理 123456789101112131415161718让浏览器即监听相关事件，又让组合器线程在等等主线程响应前构建新的组合帧document.body.addEventListener(&apos;touchstart&apos;, event =&gt; &#123; if (event.target === area) &#123; event.preventDefault() &#125;&#125;, &#123;passive: true&#125;);垂直方向的滚动可能会先于event.preventDefault()发生，此时可以通过 event.cancelable 来防止这种情况document.body.addEventListener(&apos;pointermove&apos;, event =&gt; &#123; if (event.cancelable) &#123; event.preventDefault(); // block the native scroll &#125; &#125;, &#123;passive: true&#125;);也可以使用 css 属性 touch-action 来完全消除事件处理器的影响，如：#area &#123; touch-action: pan-x; &#125; 表示false的值 false, 0, 空字符串(‘’), null, undefined Number,Boolean,String,Undefined比较问题 会先将复合对象转换成基本类型（依次调用valueOf和toString方法）再进行比较，undefined被当成基本类型，undefined转换成数字是NaN，因此undefined与除null之外的其它类型值进行比较时始终返回false（注意NaN==NaN返回false）null被当成复合对象，由于null没有valueOf和toStribg方法，因此除了和undefined之外的其它类型值进行比较时始终返回false 设置prototype的值为对象时，首先要还原构造器1234let Person = function()&#123;&#125;Person.prototype = &#123; constructor: Person&#125; 复制内容到粘贴板(仅支持IE)12let text = document.querySelector(&apos;.text&apos;).innerText;window.clipboardData.setData(&apos;text&apos;, text); []和new Array[]的运行速度比new Array快，后者需要调用构造器 mouseout、mouseleave12mouseout: 无论鼠标离开被选元素(绑定事件的元素)还是其子元素都会触发mouseleave: 当鼠标离开被选元素时触发 获取选中select标签的文本12// value和选择文本不同时，sel为select标签的dom元素sel.options[sel.selectedIndex].text hover事件相当于mouseenter+mouseleave，不相当于mouseover+mouseout，mouseover(mouseout)鼠标进入(离开)某个元素或其子元素时触发。 javascript:void(0)javascript是伪协议，表示url的内容通过javascript执行。void(0)表示不做任何操作，这样会防止链接跳转到其他界面。这么做可以保存链接的样式，但不让链接执行实际操作，具体的操作交给链接的onclick事件处理 函数声明12函数声明：function fn()&#123;&#125;函数表达式：var fn = function()&#123;&#125; 将伪数组转换成数组Array.prototype.slice.call(arguments, 0); 操作class12345dom.classList.value 获取所有类名dom.classList.add() 添加类dom.classList.remove() 移除类dom.classList.contains() 查看是否存在某个类dom.classList.toggle() 切换是否显示某个类 获取对象类型12345678Object.prototype.toString.call(xx); // 结果为[object Type]// 判断是否为数组if(typeof Array.isArray===&apos;undefined&apos;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&apos;[object Array]&apos; &#125;; &#125; 判断是否为undefined12345let a;undefined = 1; // 这样判断就会出错a === undefined; // undefined不是保留字，能被赋值a === void 0; // void后面随便跟上一个组成表达式，返回就是undefined bind、call、apply的区别 bind只改变上下文环境，不执行 call第二个参数开始是参数列表 allpy第二个参数是数组 获取元素样式1getComputedStyle(dom, 伪类); // 可以获取伪类样式 判断图片是否加载完成1231. onload2. 通过img.complete属性判断3. onreadystatechange，img.readyState为complete或者loaded为加载完成 setTimeout(fn, time, param) fn: 回调函数 time: 延迟调用时间 param: 传入回调的参数 获取transform后元素的宽高1dom.getBoundingClientRect() 语法简写123456789101112131415161718192021222324252627//取整parseInt(a,10); //BeforeMath.floor(a); //Beforea&gt;&gt;0; //Before~~a; //Aftera|0; //After//四舍五入Math.round(a); //Beforea+.5|0; //After//内置值undefined; //Beforevoid 0; //After, 快0[0]; //After, 略慢//内置值Infinity;1/0;//布尔值短写法true; //Before!0; //After//布尔值短写法false; //Before!1; //After base64图片前缀data:image/png;base64, 拷贝12345对象拷贝let obj = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(copyObj))数组拷贝let arr = [].concat(copyArr); 第二次var定义变量如果不赋值，该值为原来定义的值123var a = 100;var a;console.log(a); // 100 函数声明会比变量声明先1234console.log(a); // functionvar a = &apos;123&apos;;function a ()&#123;&#125;;console.log(a); // 123 new的过程 创建一个新对象 将构造函数的作用域赋值给新对象 执行构造函数的代码 返回新的对象 原型链的顶层null 自定义事件12345let evt = document.createEvent(&quot;HTMLEvents&quot;);// 初始化evt.initEvent(&quot;alert&quot;, false, false);// 触发week.dispatchEvent(evt); 查看元素事件12window.getEventListeners(window); // 返回事件对象，如&#123;click:[], mousedown:[]&#125;window.getEventListeners(window).click[0].listener; // 获取第一个绑定的click事件函数 生成任意长度，且值为undefined的数组Array.apply(null, {length: 2}); // [undefined, undefined] 移动端将键盘回车变为搜索12345将input的type改为search在input外包一层form, form标签设置action属性, 设置autocomplete=&quot;off&quot;去掉弹出的下拉框设置input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123;display: none;&#125;将默认的X隐藏掉设置-webkit-appearance: none;去掉默认样式使用ajax提交时需要preventDefault阻止默认行为 监听APP返回键12345678910var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; : &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; : &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; : null;var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;);var onVisibilityChange = function()&#123; if (document[hiddenProperty]) &#123; console.log(&apos;页面非激活&apos;); &#125;else&#123; console.log(&apos;页面激活&apos;) &#125;&#125;document.addEventListener(visibilityChangeEvent, onVisibilityChange); parseInt1parseInt(&apos;12abc&apos;); // 12 触发鼠标右键事件1on(&quot;contextmenu&quot;) window.openwindow.open打开的子窗口可以使用opener访问父窗口的方法和变量 onInput谷歌控制台使用Ctrl+p可以输入要打开的文件；onInput 是 HTML5 的标准事件，对于检测 textarea, input(text), input(password) 和 input(search) 这几个元素通过用户界面发生的内容变化非常有用，在内容修改后立即被触发，不像 onchange 事件需要失去焦点才触发。oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的onpropertychange 事件替代。 try、catch、finallyJs如果在try中return则不会进入finally 改变当前链接1location.replace(url) IOS日期转换问题IOS的Safari在new Date()的时候不支持’2017-3-6’的格式，支持’2017/3/6’，也不支持date为2018/09/19 00.00.00.0，后缀带.0的 httpget请求默认会在浏览器中缓存，可以通过添加时间戳来避免缓存 NodeJS Event loop1234567891011121314151617181920212223242526272829console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&apos;Promise&apos;) resolve()&#125;).then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout微任务: process.nextTick, promise, Object.observe, MutationObserver宏任务: script, setTimeout, setInterval, setImmediate, I/O, UI rendering&gt; setImmediate会比setTimeout先执行Event loop执行顺序1. 执行同步代码，这属于宏任务2. 执行栈为空，查询是否有微任务需要执行3. 执行所有微任务4. 必要的话渲染 UI5. 然后开始下一轮 Event loop，执行宏任务中的异步代码 存储特性 | cookie | localStorage | sessionStorage | indexDB—|—|—|—|—数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在数据存储大小 | 4K | 5M | 5M | 无限与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 cookie安全性属性 | 作用—|—value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击secure | 只能在协议为 HTTPS 的请求中携带same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 1234567891011121314151617181920212223242526272829303132// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker.register(&apos;sw.js&apos;).then(registration =&gt; &#123; console.log(&apos;service worker 注册成功&apos;); &#125;).catch((err) =&gt; &#123; console.log(&apos;service worker 注册失败&apos;); &#125;);&#125;// sw.js// 监听install事件，回调缓存所需文件self.addEventListener(&apos;install&apos;, e =&gt; &#123; e.waitUntil( // 设置缓存的名称为my-cache caches.open(&apos;my-cache&apos;).then(cache =&gt; &#123; return cache.addAll([&apos;./index.html&apos;, &apos;./index.js&apos;]); &#125;); );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&apos;fetch&apos;, e =&gt; &#123; e.respondWith( caches.match(e.request).then(response =&gt; &#123; if (response) &#123; return response &#125; console.log(&apos;fetch source&apos;); &#125;); );&#125;) Load和DOMContentLoaded区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 生成新图层 3D变换: translate3d、translateZ will-change video、iframe标签 通过动画实现的opacity动画转换 position: fixed 对于频繁渲染的建议生成一个新的图层，提高性能。但不能生成过多图层，会引起反作用。 重绘(Repaint)和回流(Reflow) 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 并行、并发 并行：宏观和微观上都是同时进行 并发：宏观上同时，微观上不同时 工具库loadash、date-fns(日期格式化)、accounting.js(货币格式化) jsencrypt用于请求参数加密处理，加密方式为RSA vue框架核心方法defineProperty(defineProperties)123456789writable、value和set、get不能同时存在Object.defineProperty(obj, prop, &#123; configurable: false, //是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置 enumerable: false, //枚举性，表示是否可以通过for-in循环返回 writable: false, //可写性：是否可以修改属性的值 value: undefined, //包含属性的值，也就是对应的可读性。 set: undefined, get: undefined&#125;) 获取github用户信息https://api.github.com/users/{id} 复制功能 https://clipboardjs.com/ https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4 安装nvm后无法使用问题先nvm install node，然后再nvm use [version] nvm安装最新nodejs包nvm install latest 判断点击元素是否为某个元素的后代元素12345document.addEventListener(&apos;click&apos;, (e) =&gt; &#123; if (el.contains(e.target)) &#123; console.log(&apos;包含&apos;) &#125;&#125;) js兼容写法12345678910111213(function(root, factory) &#123; if (typeof exports === &apos;object&apos;) &#123; module.exports = factory(); // commonjs环境下能拿到返回值 &#125; else if (typeof define === &apos;function&apos;) &#123; define(factory); // define(function()&#123; return &apos;a&apos; &#125;) AMD &#125; else &#123; window.eventUtil = faltory(); &#125;&#125;)(this, function() &#123; return &#123; addEvent: function(el, type, handle) &#123;&#125;, &#125;&#125;) 提现原型的扩展性jQuery.fn.init.prototype = jQuery.fn只有$会暴露在全局变量中，将插件扩展统一到$.fn中","categories":[],"tags":[{"name":"daily-notes","slug":"daily-notes","permalink":"https://xuehongjie.github.io/tags/daily-notes/"},{"name":"js","slug":"js","permalink":"https://xuehongjie.github.io/tags/js/"}]},{"title":"meta标签","slug":"front-end/html/tag-meta","date":"2018-12-11T00:43:10.000Z","updated":"2019-01-08T13:51:16.072Z","comments":true,"path":"front-end/html/tag-meta/","link":"","permalink":"https://xuehongjie.github.io/front-end/html/tag-meta/","excerpt":"","text":"基本123456789101112131415161718192021222324// 更加标准的 lang 属性写法 http://zhi.hu/XyIa&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;// 声明文档使用的字符编码&lt;meta charset=&apos;utf-8&apos;&gt;// 优先使用 IE 最新版本和 Chrome&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;&lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt;// 页面描述&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;// 页面关键词&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;// 网页作者&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;// 搜索引擎抓取&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;// 为移动设备添加 viewport&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=0&quot;&gt; iOS 设备1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 添加到主屏后的标题（iOS 6 新增）&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;// 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;// 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;// 设置苹果工具栏颜色&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;// 忽略页面中的数字识别为电话，忽略email识别&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;// 启用360浏览器的极速模式(webkit)&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;// 避免IE使用兼容模式&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;// 不让百度转码&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;// 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;// 微软的老式浏览器&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;// uc强制竖屏&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;// QQ强制竖屏&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;// UC强制全屏&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;// QQ强制全屏&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;// UC应用模式&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;// QQ应用模式&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;// windows phone 点击无高光&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; iOS 图标12345678910// iOS 图标 begin&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;// iPhone 和 iTouch，默认 57x57 像素，必须有&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;// Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;// Retina iPad，144x144 像素，可以没有，但推荐有// iOS 图标 end iOS 启动画面1234567891011121314151617181920// iPad 竖屏 768 x 1004（标准分辨率）&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;// iPad 竖屏 1536x2008（Retina）&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;// iPad 横屏 1024x748（标准分辨率）&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;// iPad 横屏 2048x1496（Retina）&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;// iPhone/iPod Touch 竖屏 320x480 (标准分辨率)&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;// iPhone/iPod Touch 竖屏 640x960 (Retina)&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;// iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina)&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; 其他1234567891011// Windows 8 磁贴颜色&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;// Windows 8 磁贴图标&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;// 添加 RSS 订阅&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;// 添加 favicon icon&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt; sns 社交标签123456// 参考微博API&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://xuehongjie.github.io/tags/html/"}]},{"title":"css实现居中","slug":"front-end/css/css-centered","date":"2018-12-11T00:03:53.000Z","updated":"2019-01-01T16:04:51.475Z","comments":true,"path":"front-end/css/css-centered/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/css-centered/","excerpt":"","text":"定位1234position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); 伸缩盒123display: flex;justify-content: center;align-items: center;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"css揭秘","slug":"front-end/css/css-reveal-secrets","date":"2018-12-10T00:04:00.000Z","updated":"2019-01-01T16:02:49.676Z","comments":true,"path":"front-end/css/css-reveal-secrets/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/css-reveal-secrets/","excerpt":"","text":"边框使用box-shadow制作假边框，第四个值为增大或者减小投影面积(box-shadow范围内不会触发事件)box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道 5px 的外框，那就需要指定扩张半径的值为15px （ 10px+5px ），会随着border-radius贴合border .box-shadow{display: inline-block;margin: 20px;width: 10px;height: 10px;-webkit-box-shadow: 0 0 0 10px red, 0 0 0 15px blue;box-shadow: 0 0 0 10px red, 0 0 0 15px blue;font-size: 12px;} 1234567&lt;div class=&quot;box-shadow&quot;&gt;&lt;/div&gt;.box-shadow&#123; width: 10px; height: 10px; box-shadow: 0 0 0 10px red, 0 0 0 15px blue;&#125; outline不触发事件，不随border-radius而贴合border .outline {margin: 10px;width: 10px;height: 10px;border: 5px solid red;outline: 5px solid blue;box-sizing: content-box;} 12345678&lt;div class=&quot;outline&quot;&gt;&lt;/div&gt;.outline &#123; width: 10px; height: 10px; border: 5px solid red; outline: 5px solid blue;&#125; background-origin通过backgroun-origin改变background-position的基准位置 reapting-linear-gradientlinear-gradient的扩展 利用linear-gradient实现网格 .linear-gradient {margin: 10px;width: 100px;height: 100px;background: white;background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%,transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0);background-size: 30px 30px;} 123456789&lt;div class=&quot;linear-gradient&quot;&gt;&lt;/div&gt;.linear-gradient &#123; width: 100px; height: 100px; background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px;&#125; 形状自适应的椭圆(元素为正方形时展示圆形)border-radius: 50% / 50%;可简写为border-radius: 50%; .circle {display: inline-block;margin: 10px;width: 50px;height: 50px;border-radius: 50%;background: blue;}.circle2 {width: 100px;} 123456789101112&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;&lt;div class=&quot;circle circle2&quot;&gt;&lt;/div&gt;.circle &#123; width: 50px; height: 50px; border-radius: 50%; background: blue;&#125;.circle2 &#123; width: 100px;&#125; 切角效果 .corner-cutting{display: inline-block;margin: 10px;width:100px; height: 100px;line-height: 100px;background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,linear-gradient(45deg, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;text-align: center;}.clip-path{clip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px);} background clip-path 12345678910111213.corner-cutting &#123; width: 100px; height: 100px; background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125;// 或者使用clip-pathclip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px); 制作单边倾斜的梯形 .trapezoid {margin: 10px;width: 50px;height: 50px;background: blue;transform: perspective(.5em) rotateX(5deg);transform-origin: bottom left;} 123456789&lt;div class=&quot;trapezoid&quot;&gt;&lt;/div&gt;.trapezoid &#123; width: 50px; height: 50px; background: blue; transform: perspective(.5em) rotateX(5deg); transform-origin: bottom left;&#125; 投影 .box-shadow {width: 50px;height: 50px;line-height: 50px;}.box-shadow1 {box-shadow: 0 5px 4px -4px black;}.box-shadow2 {box-shadow: 3px 3px 6px -3px black;}.box-shadow3 {box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black;} 单边投影邻边投影两侧投影 1234567891011121314151617181920&lt;div class=&quot;box-shadow box-shadow1&quot;&gt;单边投影&lt;/div&gt;&lt;div class=&quot;box-shadow box-shadow2&quot;&gt;邻边投影&lt;/div&gt;&lt;div class=&quot;box-shadow box-shadow3&quot;&gt;两侧投影&lt;/div&gt;.box-shadow &#123; width: 50px; height: 50px;&#125;// 单边投影.box-shadow1 &#123; box-shadow: 0 5px 4px -4px black;&#125;// 邻边投影.box-shadow2 &#123; box-shadow: 3px 3px 6px -3px black;&#125;// 两侧投影.box-shadow3 &#123; box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black;&#125; 滤镜 .filter {display: inline-block;margin: 10px;width: 50px;height: 50px;background: blue;}.filter-blur {filter: blur(5px);}.filter-grayscale {filter: grayscale();}.filter-drop-shadow {filter: drop-shadow(3px 3px 6px black)} 12345678910111213141516171819&lt;div class=&quot;filter&quot;&gt;&lt;/div&gt;.filter-blur &#123; width: 50px; height: 50px; background: blue;&#125;.filter-blur &#123; filter: blur(5px);&#125;.filter-grayscale &#123; filter: grayscale();&#125;.filter-drop-shadow &#123; filter: drop-shadow(3px 3px 6px black)&#125;filter: blur(5px) grayscale() drop-shadow(3px 3px 6px black)blur 元素模糊drop-shadow 类似于box-shadow 设置缩进1tab-size: 2; 空心字效果 .hollow-text {display: inline-block;margin-right: 10px;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black;}.hollow-text2 {text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black;} 空心字空心字 123456789&lt;div class=&quot;hollow-text&quot;&gt;空心字&lt;/div&gt;&lt;div class=&quot;hollow-text hollow-text2&quot;&gt;空心字&lt;/div&gt;.hollow-text &#123; text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black;&#125;.hollow-text2 &#123; text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black;&#125; 使用text-shadow实现文字模糊效果 .filter-text {color: black;text-shadow: 0 0 .1em black, 0 0 .3em black;} 文字模糊 123456&lt;div class=&quot;filter-text&quot;&gt;文字模糊&lt;/div&gt;.filter-text &#123; color: black; text-shadow: 0 0 .1em black, 0 0 .3em black;&#125; 利用svg实现环形文字效果 .circular{width: 50px;} circular reasoning works because 12345678&lt;div class=&quot;circular&quot;&gt; &lt;svg viewBox=&quot;0 0 100 100&quot;&gt; &lt;path d=&quot;M 0,50 a 50,50 0 1,1 0,1 z&quot; id=&quot;circle&quot; /&gt; &lt;text&gt; &lt;textPath xlink:href=&quot;#circle&quot;&gt;circular reasoning works because&lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/div&gt; 用户体验 使用合适的cursor 增大可点击范围123border: 10px solid transparent;background-clip: padding-box;需要边框时增加box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset; 水平居中行内元素：对其父元素设置text-align:center;块级元素：对其自身设置margin:0 auto; 实现水平垂直居中 通过position定位.position-container {position: relative;margin: 10px;width: 50px;height: 50px;background: red;}.position {position: absolute;top: 50%;left: 50%;width: 30px;height: 30px;background: blue;-webkit-transform: translate(-50%, -50%);transform: translate(-50%, -50%);} 123456789101112131415161718192021&lt;div class=&quot;position-container&quot;&gt; &lt;div class=&quot;position&quot;&gt;&lt;/div&gt;&lt;/div&gt;.position-container &#123; position: relative; width: 50px; height: 50px; background: red;&#125;.position &#123; position: absolute; top: 50%; left: 50%; width: 30px; height: 30px; background: blue; transform: translate(-50%, -50%);&#125;margin: 50% auto 0;transform: translateY(-50%);(只适用于全屏居中) 使用flex.flex-container {display: flex;margin: 10px;width: 50px;height: 50px;background: red;}.margin-item {margin: auto;width: 30px;height: 30px;background: blue;}.flex-container2 {justify-content: center;align-items: center;}.flex-item {width: 30px;height: 30px;background: blue;}marginflex 12345678910111213141516171819202122232425262728// 使用margin&lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;margin-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;.flex-container &#123; display: flex; width: 50px; height: 50px; background: red;&#125;.margin-item &#123; margin: auto; width: 30px; height: 30px; background: blue;&#125;// 使用伸缩盒属性.flex-container2 &#123; justify-content: center; align-items: center;&#125;.flex-item &#123; width: 30px; height: 30px; background: blue;&#125; 小球回弹动画@keyframes bounce {60%, 80%, to {transform: translateX(400px);animation-timing-function: ease;}70% { transform: translateX(300px); }90% { transform: translateX(360px); }}.ball {margin: 10px;width: 50px;height: 50px;background: blue;animation: bounce 3s cubic-bezier(.1,.25,1,.25) infinite;animation-direction: alternate;} 1234567891011121314151617&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateX(400px); animation-timing-function: ease; &#125; 70% &#123; transform: translateX(300px); &#125; 90% &#123; transform: translateX(360px); &#125;&#125;.ball &#123; width: 50px; height: 50px; background: blue; animation: bounce 3s cubic-bezier(.1,.25,1,.25) infinite; animation-direction: alternate;&#125; 利用steps对png背景做切换12animation: loader 1s infinite steps(8);@keyframes loader &#123;to &#123; background-position: -800px 0; &#125;&#125; 实现闪烁效果@keyframes twinkle {0% {backgroud: blue;}100% {background: transparent;}}.twinkle {margin: 10px;width: 50px;height: 50px;background: blue;animation: twinkle .5s linear infinite alternate;} 12345678910111213141516&lt;div class=&quot;twinkle&quot;&gt;&lt;/div&gt;@keyframes twinkle &#123; 0% &#123; backgroud: blue; &#125; 100% &#123; background: transparent; &#125;&#125;.twinkle &#123; width: 50px; height: 50px; background: blue; animation: twinkle .5s linear infinite alternate;&#125; 背景图片来回播放1234567891011@keyframes panoramic &#123;to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url(&quot;img/naxos-greece.jpg&quot;); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123; animation-play-state: running;&#125; 利用translate实现transform-origin的效果 .transform-container {margin: 50px;}.transform {width: 50px;height: 50px;background: blue;transform: rotate(30deg);transform-origin: 50px 100px;}.transform2 {transform: translate(50px, 100px) rotate(30deg) translate(-50px, -100px);transform-origin: 0 0;} 1234567891011121314151617181920&lt;div class=&quot;transform-container&quot;&gt; &lt;div class=&quot;transform&quot;&gt;&lt;/div&gt; &lt;div class=&quot;transform2&quot;&gt;&lt;/div&gt;&lt;/div&gt;.transform-container &#123; margin: 50px;&#125;.transform &#123; width: 50px; height: 50px; background: blue; transform: rotate(30deg); transform-origin: 50px 100px;&#125;// 效果同上.transform2 &#123; transform: translate(50px, 100px) rotate(30deg) translate(-50px, -100px); transform-origin: 0 0;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"日常小记-样式","slug":"front-end/css/daily-notes","date":"2018-12-09T00:12:08.000Z","updated":"2020-03-01T15:28:57.541Z","comments":true,"path":"front-end/css/daily-notes/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/daily-notes/","excerpt":"","text":"命名规范BEM(block element modifier) 常用的屏幕大小手机屏：&lt;768pad屏：≥768显示器：≥992大屏显示器：≥1200 禁止文本选中1user-select:none 链接的伪类 :link // 初始 :visited // 访问后 :hover // 鼠标悬停时 :active // 点击时 浮动问题子元素都为float，则父元素需要设置float才能被撑开 background属性的设置顺序bsckground:url() repeat attachment position/size origin clip 制作梯形1transform: perspective(20px) rotateX(-1deg ) rotateY(-2deg) translateZ(0) 实现模糊效果(支持IOS)1backdrop-filter:blur(10px); matrix(a,b,c,d,e,f) e和f相当于translate a和d相当于scale b和c相当于rotate 使滚动变流畅1-webkit-overflow-scrolling: touch; -webkit-overflow-scrolling产生的问题 滚动中scrollTop不会变化、不触发scroll事件，只在停下来的时候触发 手势可穿过其它元素触发元素滚动 滚动时暂停其它transition 有时会卡住不动，浏览器容器回弹停止后才可滑动 文本渐变123456789101112h2[data-text] &#123; position: relative;&#125;h2[data-text]::after &#123; content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));&#125; 黑白图片123img &#123; filter: grayscale(100%);&#125; 优化文本显示12345.text &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 文本模糊123.text&#123; text-shadow: 0 0 5px rgba(0, 0, 0, .5)&#125; 表格单元格等宽123.table &#123; table-layout: fixed;&#125; 多行省略号12345display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; 伸缩盒子元素的宽度没有超过父元素宽度或没有设置flex-wrap: wrap时，align-content不生效 GPU硬件加速1、设置will-change:transform进行硬件加速，还需要设置trsnsform:translateZ(0)进行hack2、transform: translate3d(0, 0, 0) 避免隐式合成保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。 动画优化 减少浏览器的重排和重绘的发生。 不要使用table布局。 css动画中尽量只使用transform和opacity，这不会发生重排和重绘。 尽可能地只使用css做动画。 避免浏览器的隐式合成。 改变复合层的尺寸。(使用小图片，通过scale放大) 使用锚点切换时平滑滚动1scroll-behavior: smooth 实现左右300px，中间自适应布局1、float(优：兼容性好；缺：需要清除浮动)2、position:absolute(优：布局快；缺：兄弟元素都需要脱离文档流处理，可使用性差)3、flex(比较完美)4、table、table-cell(易处理；其中一个单元格高度增长时，其余也会跟着增长)5、grid background的设置顺序background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; :last-child匹配父元素的最后一个元素 position:fixed宽高受父级元素影响问题如果父级元素使用了transform，则其position为fixed的子元素设置的宽高受父元素影响 touch-action 开发者文档 张鑫旭的博客 移动端设置cursor: pointer时，点击元素会有背景色123* &#123; -webkit-tap-highlight-color: transparent;&#125; 图片上下排列3px间隔的消除方法 给居上的图片加vertical-align: top 给居上的图片加display: block 设置font-size: 0 position static不拖出文档流 relative不拖出文档流 absolute拖出文档流 fixed拖出文档流 display和visibility12display: none; // 隐藏DOM，不占据空间visibility: hidden; // 隐藏DOM，占据空间 GPU硬件加速121. 设置will-change: transform，还需要设置transform: translateZ(0)进行hack2. transform: traslate3d(0, 0, 0) 硬件加速优化 设置动画元素的z-index高于其他元素 使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显 元素容器宽度固定，当元素超出容器时整个元素换行处理1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt;&lt;/div&gt;方法一.item &#123; display: inline-block;&#125;方法二.container &#123; display: flex;&#125; 实现半圆阴影12345678910111213141516171819202122.half_circle &#123; position: absolute; top: 50%; left: -.25rem; z-index: 1; width: .2rem; height: .2rem; border-radius: 50%; transform: translate(0, -50%); /*background: radial-gradient(circle, #fbfbfb 10px, #fff);*/ box-shadow: inset 0 0 10px 0 rgba(0, 0, 0, .1); &amp;:before &#123; content: &apos;&apos;; position: absolute; top: 0; left: 0; z-index: 3; width: .1rem; height: .2rem; background: linear-gradient(to left, rgb(250, 250, 250), #fff); &#125;&#125; 实现字体图标渐变核心思想为下面 3 条属性值。 background: -webkit-linear-gradient(-45deg, #caff55 20%, #45cd00 60%); // 设置渐变的背景 -webkit-background-clip: text; // 规定背景的绘制区域为文字区域 这个属性还有其他值： border-box (默认) 背景被剪裁到边框盒 padding-box 背景被剪裁到内边距框 content-box 背景被剪裁到内容框 -webkit-text-fill-color: transparent; // 文字填充颜色（这里一定要设置 transparent，不然会覆盖底部的背景色） 适配iphoneX123456.container &#123; $actionHeight: 56px; padding-bottom: $actionHeight; padding-bottom: calc(env(safe-area-inset-bottom) + 56px); padding-bottom: calc(constant(safe-area-inset-bottom) + 56px);&#125; 其他 浏览器html默认字体大小为16px，设置font-size为62.5%后可换算为10px 只有块级元素或者行内块元素transform属性才回生效 display:inline-block的元素可以通过vertical-align:middle实现居中 50vh表示50%的设备高度，50vw表示50%的设备宽度 word-break：break-all;设置后火狐下的文字会比较对齐 文字要超过一行text-align:justify才会生效 resize属性可以设置文本框的拖动，其overflow需要设置为overflow/auto/scroll ie浏览器的option标签不可改变样式、不触发事件(由select触发) 伪对象after和before相当于内联元素 使用inline-block边距会多出4个像素，可通过font-size:0去除 需要右边框且超出省略时可以用丨(gun)来代替","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"},{"name":"daily-notes","slug":"daily-notes","permalink":"https://xuehongjie.github.io/tags/daily-notes/"}]},{"title":"屏幕适配","slug":"front-end/css/screen-adaptation","date":"2018-12-08T00:34:18.000Z","updated":"2019-01-01T15:43:41.458Z","comments":true,"path":"front-end/css/screen-adaptation/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/screen-adaptation/","excerpt":"","text":"常见移动web适配方法PC 960px/1000px居中 盒子模型，定高，定宽 display:inline-block 移动web: 定高，宽度百分比 flex Media Query(媒体查询) Media Query1234@media 媒体类型 and (媒体特性)如: @media screen and (max-width:320px)可在标签上引用&lt;link href=&quot;&quot; media=&quot;screen and (max-width:320px)&quot;/&gt; rem原理和简介 字体单位 值根据html根元素大小而定，同样可以作为宽度、高度等单位 适配原理将px替换成rem，动态修改html的font-size适配 兼容性IOS6以上、Android2.1以上 js动态修改font-size12345678910(function computedWidth()&#123; let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; let $html = document.querySelector(&apos;html&apos;); $html.style.fontSize = htmWidth / 3.75 + &apos;px&apos;; // iPhone6的手机尺寸 //屏幕宽度变化时 window.addEventListener(&apos;resize&apos;, computedWidth); //横竖屏切换时 window.addEventListener(&apos;orientationchange&apos;, computedWidth);&#125;)();","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"},{"name":"rem","slug":"rem","permalink":"https://xuehongjie.github.io/tags/rem/"}]},{"title":"深入overflow","slug":"front-end/css/deep-into-overflow","date":"2018-12-07T22:28:51.000Z","updated":"2019-01-01T15:35:27.772Z","comments":true,"path":"front-end/css/deep-into-overflow/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/deep-into-overflow/","excerpt":"","text":"相关问题 overfloe-x、overflow-y(IE8+)如果overflow-x与overflow-y相同，则等同于overflow；如果两个设置不同，切其中一个设置为visible则visible会被重置为auto 表格元素无效，需要先设置table-layout:fixed overflow:auto时，chrome下能显示padding-bottom，而其他浏览器都不显示padding-bottom 作用 清除浮动影响overflow:hidden;_zoom:1; 避免margin穿透问题 两栏自适应布局 BFC属性12345678910111213// 自适应，但溢出不可见，限制了应用场景overflow:hidden// 包裹性+破坏性，无法自适应，块状浮动布局float+floatposition:absolute // 包裹性，无法自适应，IE6、7不识别display:inline-block// 包裹性，无溢出特性，绝对宽度也能自适应display:table-cell 文字溢出出省略号123456789101112// 单行省略width:100px;white-space:nowrap;text-overflow:ellipisis;overflow:hidden;// 多行省略号display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; 其他 无论什么浏览器，默认滚动条都来自html标签，而不是body标签 滚动条的宽度等于外部容器减去内部元素的clientWidth 获取滚动高度12chrome:document.body.scrollTop其他浏览器:document.documentElement.scrollTop 出现滚动条时，修复水平居中的元素跳动问题 设置html{overflow-y:scroll} container{padding-left:calc(100vw - 100%)}，既设置滚动条的宽度，适用于IE9+及其他浏览器 块级格式化上下文1overflow:auto/scroll/hidden 元素包裹问题元素的父元素没有设置position:absolute/relative/fixed时，父元素的overflow无法包裹住position:absolute的子元素1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;.container &#123; position: relative; overflow: hidden;&#125;.item &#123; position: absolute;&#125; overflow失效妙用123456// 父元素height:0;overflow:hidden;text-align:right;// 子元素position:absolute 锚点定位 锚点定位的触发 url地址中的锚链与锚点元素 可focus的锚点元素处于focus态","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"深入float","slug":"front-end/css/deep-into-float","date":"2018-12-06T21:39:30.000Z","updated":"2019-01-01T14:57:31.188Z","comments":true,"path":"front-end/css/deep-into-float/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/deep-into-float/","excerpt":"","text":"设置初衷为了文字的环绕float元素会产生BFC(块级格式化上下文，block formatting context) 特性包裹具有包裹性的相关属性123display:inline-block/table-cellposition:absolute/fixed/stickyoverflow:hidden/scroll 破坏(父元素塌陷)具有破坏性的相关属性12display:noneposition:absolute/fixed/sticky 能形成BFC的样式12345float:left/rightposition:absolute/fixedoverflow:hidden/scroll(IE7+)display:inline-block/table-cell(IE8+)width/height/zoom:1...(IE6/IE7) 清除浮动(较佳使用)123456789.clearfix:after&#123; content:&apos;&apos;; display:table; clear:both;&#125;.clesrfix&#123; *zoom:1; //IE6、7&#125;应用于包含浮动元素的父元素上 浮动与两侧皆适应的流体布局1234display:table-cell;*display:inline-block;width:2000px;*width:auto","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"深入border","slug":"front-end/css/deep-into-border","date":"2018-12-05T23:16:00.000Z","updated":"2019-01-01T15:28:48.172Z","comments":true,"path":"front-end/css/deep-into-border/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/deep-into-border/","excerpt":"","text":"特性 border-style为dashed时，不同浏览器下实线和空白区域的比例不同 border-style为dotted时，形状不同 当border-color没有指定颜色时，默认使用color作为边框颜色，类似的还有box-shadow,text-shadow,outline 应用场景让背景图固定距离右侧50px12border-right:50px solid transparent;background-position:100% 40px ; 实现三角形.triangle {margin-bottom: 10px;width: 0;height: 0;border: 25px solid transparent;border-bottom-color: blue;} 12345678&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;.triangle &#123; width: 50px; height: 50px; border: 25px solid transparent; border-bottom-color: blue;&#125; 实现梯形.trapezoid {margin-bottom: 10px;width: 70px;height: 0;border: 25px solid transparent;border-bottom-color: blue;} 12345678&lt;div class=&quot;trapezoid&quot;&gt;&lt;/div&gt;.trapezoid &#123; width: 50px; height: 50px; border: 25px solid transparent; border-bottom-color: blue;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"深入padding","slug":"front-end/css/deep-into-padding","date":"2018-12-04T21:37:28.000Z","updated":"2019-01-25T16:11:47.896Z","comments":true,"path":"front-end/css/deep-into-padding/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/deep-into-padding/","excerpt":"","text":"padding是否生效对于block水平元素 padding值过大，一定会影响尺寸 width非auto，padding一定影响尺寸 width为auto或box-sizing为border-box，同时padding值没有过大，不影响尺寸 对于inline水平元素水平padding影响尺寸，垂直padding不影响尺寸，但是会影响背景色(占据空间) 支持的属性值 不支持负值 百分比根据宽度计算(如果设置50%则为一个正方形) inline元素的padding：同样相对于宽度计算，默认的宽度高度细节有差异，padding会断行 应用场景实现border与内容区域之间空白的效果.clip-container {margin: 10px;padding: 10px;width: 50px;height: 50px;border: 10px solid red;background-color: blue;background-clip: content-box;} 1234567891011&lt;div class=&quot;clip-container&quot;&gt;&lt;/div&gt;// 利用background-clip实现.clip-container &#123; padding: 10px; width: 50px; height: 50px; border: 10px solid red; background-color: blue; background-clip: content-box;&#125; 如何得到一个正方形.square-container{margin: 10px;width: 50px;height: 50px;}.square {width: 100%;padding-top: 100%;background-color: blue;} 12345678910111213&lt;div class=&quot;square-container&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;&lt;/div&gt;.square-container&#123; width: 50px; height: 50px;&#125;.square &#123; width: 100%; padding-top: 100%; background-color: blue;&#125; 其他 inline元素的垂直padding会让让空白节点显现，既规范中的strut，可以通过font-size:0去除 ol/ul标签内置padding-left是以px为单位的，如果字号很小，间距就会很开；如果字号很大，就会跑到容器外面 在firefox下设置button的padding为0时依然有padding值，通过设置button::-moz-focus-inner{padding:0}。 IE7下文字越多，button的padding值越大，通过设置button{overflow:visiable;}去除。 可访问性隐藏：将元素设置absolute，定位到看不见的地方，或者设置z-index:-1隐藏在背景之下。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]},{"title":"深入margin","slug":"front-end/css/deep-into-margin","date":"2018-12-03T22:42:01.000Z","updated":"2019-01-01T15:09:01.337Z","comments":true,"path":"front-end/css/deep-into-margin/","link":"","permalink":"https://xuehongjie.github.io/front-end/css/deep-into-margin/","excerpt":"","text":"什么是margin设置元素的外边距，允许使用负值，适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 设置方式1234567891011// 设置一个值，相当于四个方向的外边距都为10pxmargin: 10px;// 设置两个值，相当于设置上下、左右的外边距，即上下为10px，左右为5pxmargin: 10px 5px;// 设置三个值，相当于设置上、左右、下的外边距，即上为10px，左右为5px，下为1pxmargin: 10px 5px 1px;// 设置四个值，相当于设置上、右、下、左的外边距，即上为10px，右为5px，下为2px，左为1pxmargin: 10px 5px 2px 1px; 特性 可以改变元素尺寸 适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 如何计算普通元素的百分比margin都是相对于容器的宽度计算的绝对定位元素的百分比margin是相对于第一个定位祖先元素（relative、absolute、fixed）的宽度计算的。 margin重叠margin重叠特性只对block元素(除float和absolute)起作用，只发生在垂直方向上(writing-mode设置可变为水平方向) 重叠的三种情景 相邻的兄弟元素 父级元素和第一个或最后一个子元素 空的block元素正正取大值，正负值相加，负负最负值 实现水平垂直居中12345678// 元素宽高固定position:absolute;top: 50%;left: 50%;margin-top: -50px;margin-left: -100px;width: 100px;height: 200px; 负值的应用场景1234567891011121314// margin负值下的两端对齐ul &#123; margin-right:-20px;&#125;li &#123; margin-right:20px;&#125;// margin负值下的等高布局div &#123; margin-bottom:-600px; padding-bottom:600px;&#125;// margin负值下的两栏自适应布局 margin失效情形 inline水平元素的垂直margin无效 margin重叠 display:table-cell等 position:absolute;当其父元素设置为relative时会生效 前一个元素float以后，后一个元素的margin-left要大于前一个元素的宽度时才会生效 内联特性导致无效 新属性值123456789101112// (一开始相当于margin-left):文档流开始的方向leftmargin-start// 相当于margin-topmargin-before// 相当于margin-bottommargin-after// 重叠效果margin-collapse可选值：collapse(默认重叠) | discard(取消margin效果) | separate(不重叠)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xuehongjie.github.io/tags/css/"}]}]}