{"meta":{"title":"薛鸿杰的博客","subtitle":null,"description":null,"author":"薛鸿杰","url":"https://tragiclife.github.io"},"pages":[{"title":"","date":"2018-12-02T07:00:58.836Z","updated":"2018-12-02T07:00:58.836Z","comments":false,"path":"tags/index.html","permalink":"https://tragiclife.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-05T14:13:25.229Z","updated":"2018-12-05T14:13:25.229Z","comments":false,"path":"categories/index.html","permalink":"https://tragiclife.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue相关知识点记录","slug":"front-end/framework/Vue","date":"2018-12-24T23:45:58.000Z","updated":"2018-12-28T16:17:41.615Z","comments":true,"path":"2018/12/25/front-end/framework/Vue/","link":"","permalink":"https://tragiclife.github.io/2018/12/25/front-end/framework/Vue/","excerpt":"","text":"dist目录中的相关文件 vue.common.js 模块化代码 vue.esm.js ES6模块化代码 vue.min.js 压缩后的代码 vue.runtime.**.js 运行时，比vue小30% 属性注册(触发视图更新)全局12给item注册checked属性，值为trueVue.set(item,&apos;checked&apos;,true) 局部1this.$set(item,&apos;checked&apos;,true) 计算属性过滤列表值1234567v-for＝&quot;item in items | filterAddress通过computed进行计算computed: &#123; filterAddress:function()&#123; return this.items.slice(0,3) &#125;&#125; watch监听对象12345obj:&#123; handler:function(val,oldVal)&#123;&#125;, deep:true, immediate: true,&#125; 生命周期一般情况beforeCreate → created → beforeMount → mounted离开页面时beforeDestroy → destroyed 在mounted中改变data的值beforeCreate → created → beforeMount → mounted → beforeUpdate → updated 使用keep-alivebeforeCreate → created → beforeMount → mounted → activated离开页面时deactivated 在mounted中改变data的值beforeCreate → created → beforeMount → mounted → activated → beforeUpdate → updated 在created钩子中的执行顺序mixin → 当前vue文件 → components 父子组件、mixins之间的顺序 父子组件、mixins的生命周期 router组件异步加载时，App.vue的mounted会先执行 异步加载页面时的声明周期 Vue自定义插件定义install方法123456789101112131415let MyPlugin = &#123;&#125;MyPlugin.install = function()&#123;// 1. 添加全局方法或属性，通过Vue.myGlobalMethod 调用Vue.myGlobalMethod = function () &#123;&#125;// 2. 添加全局资源Vue.directive(&apos;my-directive&apos;, &#123;bind (el, binding, vnode, oldVnode) &#123;&#125;&#125;)// 3. 注入组件Vue.mixin(&#123;created: function () &#123;&#125;&#125;)// 4. 添加实例方法，通过this.$myMethod 调用Vue.prototype.$myMethod = function (methodOptions) &#123;&#125;&#125; 注册vue插件12// 调用vue的use方法Vue.use(MyPlugin) 使用vue插件12345678910111213141516171819202122232425通过this.$xxx调用插件https://blog.csdn.net/qq_26522773/article/details/79358819import dialogfrom &apos;dialog.vue&apos;function install () &#123; Object.defineProperty(Vue.prototype, &apos;$dialog&apos;, &#123; get() &#123; let div = document.createElement(&apos;div&apos;); document.body.appendChild(div); return (message, modalBody) =&gt; &#123; const Constructor = Vue.extend(dialog) const Instance = new Constructor(&#123; data() &#123; return &#123; message: message, show: true, modalBody: modalBody &#125; &#125; &#125;).$mount(div) return Instance.setSubmit //放回 一个方法用于 传递 自定义的数据和 submit 时方法 &#125;; &#125; &#125;);&#125;Vue.use(Dialog) 上传到npm 每次上传npm需要修改版本号 123456789101112131415修改package.json文件private:false, // 默认是true 私人的 需要改为false 不然发不上去 你可以试试..&quot;license&quot;: &quot;MIT&quot;, // 许可证&quot;main&quot;: &quot;dist/vue-pay-keyboard.js&quot;, // 这个超级重要 决定了你 import xxx from “vue-pay-keyboard” 它默认就会去找 dist下的vue-pay-keyboard 文件&quot;repository&quot;: &#123;&quot;type&quot;: &quot;git&quot;,&quot;url&quot;: &quot;https://github.com/yucccc/vue-pay-keyboard&quot;&#125;, // 配置这个地址存放你项目在github上的位置 也尤为重要npm adduserUsername: your name Password: your password Email: yourmail[@gmail](/user/gmail).comnpm whoami 查看用户npm login 登录npm publish 发布 组件通信的方法props、事件、v-model 父组件访问子组件props$children在组件上定义ref，然后通过$refs访问 子组件访问父组件$emit修改父组件传递的props(仅限引用变量，不推荐)$parent父组件定义回调传入子组件，子组件调用 非父子组件、兄弟组件通信(A页面跳B页面)使用一个Vue实例作为中央事件总线let event = new Vue() // 事件总线event.$on(‘eventName’, (val) =&gt; {}) // 事件处理，在B的created中定义，在B的beforeDestory中销毁event.$emit(‘eventName’, data) // 事件触发，在A的beforeDestory中触发 引用mui.js报callee错误时在rules中加入{rest: resolve(‘src/plugin/mui’),use:[{loader: ‘expose-loader’,options: ‘mui’}]} 使用.ctrl等修饰符进行事件绑定时，可以绑定多个相同的事件，如：@click.ctrl=””和@click=””可以同时绑定 transition和keep-alive联合使用问题需要用transition包裹keep-alive，使用keep-alive包裹transition时路由无法缓存 使用字体图标以下错误 将目录(./font)修改为绝对路径 字体文件需要放到static目录下 assets目录和static目录存放文件的区别在 *.vue 组件中，所有模板和CSS都会被 vue-html-loader 及 css-loader 解析，并查找资源URL。例如，在和 background: url(./logo.png) 中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。因为 logo.png 不是 JavaScript，当被视为模块依赖时，需要使用 url-loader 和 file-loader处理它。vue-cli 的 webpack 脚手架已经配置了这些 loader，因此可以使用相对/模块路径。由于这些资源可能在构建过程中被内联/复制/重命名，所以它们基本上是源代码的一部分。这就是为什么建议将Webpack 处理的静态资源放在 /src 目录中和其它源文件放一起的原因。事实上，甚至不必把它们全部放在 /src/assets：可以用模块/组件的组织方式来使用它们。例如，可以在每个放置组件的目录中存放静态资源。简单理解为：static存放第三方资源，assets存放自己的资源 vue过渡动画生硬的时候可以使用position:absolute但是在android会出现缩小的情况 android手机出现过渡时页面缩小的情况看过渡类中是否有使用position:absolute vue-router在history模式下使用子路由刷新报错问题修改assetsPublicPath路径，使用绝对路径 在.vue文件中使用render需要将template删掉 依赖注入(provide/inject)provide123456可以为其所有子组件传递一个方法或属性provide() &#123; return &#123; test: this.test, &#125;&#125; inject1234567891011接收父组件provide传递的值// 写法一inject: [&apos;test&apos;]// 写法二inject: &#123; test: &#123; default()&#123; console.log(&apos;child&apos;) &#125; &#125;&#125; style标签使用scoped的时候无法覆盖子组件样式解决方法: 去掉scoped 混用本地和全局样式，即增加一个style标签，不写scoped，进行样式覆 使用深度选择器 /deep/或者&gt;&gt;&gt;，如.a /dep/ .b{} 使用scoped导致的问题 无法覆盖子组件样式 @media 不生效 template的使用123使用template包裹元素进行v-if判断最终的渲染结果不包含template元素，适用于包裹多个要用相同if条件判断的元素&lt;template&gt;&lt;h1&gt;123&lt;/h1&gt;&lt;/template&gt;编译后只展示&lt;h1&gt;123&lt;/h1&gt; 错误捕获 2.2.0+可用, 2.4.0+支持自定义事件的捕获 1234567891011Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 修改config/index.js中build的assetsPublicPath为 ‘./‘时，style标签background-image使用相对路径打包报错问题https://www.cnblogs.com/qiuyueding/p/8953396.html修改util.js文件ExtractTextPlugin.extract({ use: loaders, fallback: ‘vue-style-loader’, publicPath: ‘../../‘ // 解决打包style标签图片路径问题}) slot-scope(作用域插槽)的使用123456789101112131415161718子组件&lt;div class=&apos;mater_other&apos;&gt; &lt;slot name=&quot;other&quot; :item=&quot;item&quot; :name=&quot;&apos;123&apos;&quot;&gt; &#123;&#123;item.price&#125;&#125; &lt;/slot&gt;&lt;/div&gt;父组件(2.5.0+不限制在template元素上使用)&lt;div slot=&quot;other&quot; slot-scope=&quot;props&quot;&gt; &lt;div class=&apos;mater_left&apos;&gt; &#123;&#123;props.item.price&#125;&#125; &#123;&#123;props.name&#125;&#125; &lt;/div&gt;&lt;/div&gt;支持解构赋值&lt;div slot=&quot;other&quot; slot-scope=&quot;&#123;item, name&#125;&quot;&gt; &lt;div class=&apos;mater_left&apos;&gt; &#123;&#123;item.price&#125;&#125; &#123;&#123;name&#125;&#125; &lt;/div&gt;&lt;/div&gt; slot-scope多层传递问题 vue-router12345678vue-router跳转(以/开头的嵌套路径会被当做根路径)跳转写法// 字符串this.$router.push(&apos;/home&apos;);// 对象this.$router.push(&#123;path:&apos;home&apos;&#125;);// 命名的路由this.$router.push(&#123;name:&apos;home&apos;,params:&#123;userId:wise &#125;&#125;); 记录 在style标签中添加scoped属性可以定义样式的作用域 v-cloak属性保证Vue在new之前不展示{} :class 和:style 使用{}绑定数据时，key代表样式名，使用[]绑定数据时，每个项代表的是data中的数据 模板只能有一个根标签 根标签不能使用v-for 给vue组件添加click等原生事件时需要.native 父组件的created会比子组件的created先执行 在webstorm中使用scss报错设置style标签type=”text/scss”","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://tragiclife.github.io/tags/vue/"}]},{"title":"日常小记-HTML","slug":"front-end/html/daily-notes","date":"2018-12-24T23:16:00.000Z","updated":"2018-12-24T15:53:32.661Z","comments":true,"path":"2018/12/25/front-end/html/daily-notes/","link":"","permalink":"https://tragiclife.github.io/2018/12/25/front-end/html/daily-notes/","excerpt":"","text":"生成语法emmet 渲染机制 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 视频播放自动全屏问题 设置playsinline=”true”、webkit-playsinline=”true”、x5-playsinline=”true”、x-webkit-airplay=”allow” 修改浏览器页签图标 dns获取1&lt;link href=&quot;https://a.alipayobjects.com&quot; rel=&quot;dns-prefetch&quot;/&gt; 调用颜色盘设置input的type为color 记录 textarea添加spellcheck＝”false”去除检查","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://tragiclife.github.io/tags/html/"}]},{"title":"基础小记","slug":"front-end/other/front-end-basics","date":"2018-12-23T23:12:07.000Z","updated":"2018-12-28T16:33:49.646Z","comments":true,"path":"2018/12/24/front-end/other/front-end-basics/","link":"","permalink":"https://tragiclife.github.io/2018/12/24/front-end/other/front-end-basics/","excerpt":"","text":"网页加载优化 123456789// DNS Prefetch 应该尽量的放在网页的前面，推荐放在 &lt;meta charset=&quot;UTF-8&quot;&gt; 后面。具体使用方法如下：&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.zhix.net&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.zhix.net&quot;&gt;// 需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。// 如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt; CSS盒模型 正常盒模型 content-box: content 怪异盒模型 border-box: content + padding + border 获取盒模型的宽和高123456dom.style.width/heightdom.currentStyle.width/height (IE)window.getComputedStyle(dom).width/height (兼容性较好，获取计算后的样式，可获取伪元素的)dom.getBoundingClientRect().width/height (可以获得transform后的宽高)dom.clientWidth/clientHeight(获取宽高)dom.offsetWidth/offsetHeight (获取宽高，包括padding和border) margin重叠 父子元素 兄弟元素 空的block元素 解决margin重叠BFC(块级格式化上下文) DOM事件 DOM事件模型 事件捕获、冒泡 DOM事件类事件级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(‘click’, function(){}, false) IE:attachEventListener DOM3 element.addEventListener(‘keyup’, function(){}, false) 事件流捕获 → 目标阶段 → 冒泡 描述DOM事件捕获的具体流程如何获取html标签：document.documentElementwindow → document → html → body → … → 目标元素 → … → body → html → document → window Event对象的常见应用1234567891011121314// 阻止默认事件event.preventDefault()// 阻止事件冒泡event.stopPropagation() // 阻止事件继续执行，即一个DOM绑定多个事件，执行该方法会阻止在该回调后注册的回调函数的执行event.stopImmediatePropagation() // 绑定事件的元素event.currentTarget // 触发事件的元素event.target 自定义事件 Event 12345let evt = new Event(&apos;custom&apos;);document.addEventListner(&apos;custom&apos;, function()&#123; console.log(&apos;custom&apos;);&#125;)document.dispatchEvent(evt); CustomEvent HTTP协议类 HTTP协议的主要特点 简单快速(每个资源都是固定的) 灵活(可以完成不同数据类型的传输) 无连接(只连接一次就会断掉) 无状态(不能区分两次连接的身份) HTTP报文的组成部分 请求报文 请求行(包含http方法、页面地址、http协议、版本) 请求头(key、value值) 空行(分割请求头和请求体) 请求体 响应报文 状态行 响应头 空行 响应体 HTTP方法 GET → 获取资源 POST → 传输资源 PUT → 更新资源 DELETE → 删除资源 HEAD → 获得报文首部 POST和GET的区别 GET在浏览器回退时是无害的，而POST会再次提交请求 GET产生的URL地址可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求只能进行url编码，而POST支持多种编码方式 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有限制 对参数的数据类型，GET只接受ASCII字符，而POST没有限制 GET比POST更不安全，因为参数直接暴露的URL上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在Request body中 HTTP状态码 1xx：指示信息 - 表示请求已接收，继续处理 2xx：成功 - 表示请求已被成功接收 3xx：重定向 - 要完成请求必须进行更进一步的操作 4xx：客户端错误 - 请求有语法错误或请求无法实现 5xx：服务器错误 - 服务器未能实现合法的请求 200 OK：客户端请求成功 206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它 301 Moved Permanently：所请求的页面已经转移至新的url 302 Found：所请求的页面已经临时转移至新的url 304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态代码必须和www-Authenticate报头域一起使用 403 Forbidden：对被请求页面的访问被禁止 404 Not Found：请求资源不存在 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常 持久连接 HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接(HTTP协议为无连接的协议)当使用Keep-Alive模式(又称持久连接、连接重用)时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 管线化在使用持久连接的情况下，某个连接上消息的传递类似于请求1 =》响应1 =》请求2 =》响应2 =》请求3 =》响应3 管线化是指某个连接上的消息变成了类似这样请求1 =》请求2 =》请求3 =》响应1 =》响应2 =》响应3 管线化机制通过持久连接完成，仅HTTP/1.1支持此技术只有GET和HEAD请求可以进行管线化，而POST则有所限制初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefix默认并未开启管线化支持 原型链 创建对象有几种方法字面量let o = {name: ‘o’};let obj = new Object({name: ‘obj’}); 通过构造函数let M = function(){this.name = ‘o2’};let obj2 = new M();Object.create(prototype, descriptors)let P = {name: ‘o3’};let obj3 = Object.create(P); 原型、构造函数、实例、原型链之间的关系 原型、构造函数、实例、原型链 let M = function(){}let o = new M();构造函数：M；实例：o；原型对象：M.prototype/o.proto；原型链：通过proto一直向上查找proto的链只有构造函数才有prototype属性，只有对象(实例也是对象)和函数才有proto属性o.proto === M.prototype // trueM.prototype.proto === Object.prototype // trueo.proto.constructor === M // true 使用这个方法来判断是否为M的实例对象，instanceof不严谨 实例、构造函数、原型 o instanceof M // trueo instanceof Object // true new运算符 面对对象 类的声明123456789function Animal()&#123; this.name = &apos;name&apos;;&#125;// ES6class Animal()&#123; constructor()&#123; this.name = &apos;name&apos;; &#125;&#125; 借助构造函数实现继承 缺点：无法继承prototype的属性和方法 1234567function Parent()&#123; this.name = &apos;parent&apos;;&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125; 借助原型链实现继承 缺点：共用prototype属性和方法，修改一个影响全部 1234567function Parent()&#123; this.name = &apos;parent&apos;;&#125;function Child()&#123; this.type = &apos;child&apos;;&#125;Child.prototype = new Parent(); 组合方式 使用instanceof的时候Child和Parent都为true 123456789function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = new Parent(); 优化一 缺点：Child的实例对象使用constructor时，指向Parent 123456789function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = Parent.prototype; 优化二12345678910function Parent()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child()&#123; Parent.call(this); this.type = &apos;child&apos;;&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.construcor = Child; 通信类 同源策略及限制 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 这是一个用于隔离潜在恶意文件的关键的安全机制。 Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 Ajax请求不能发送 前后端如何通信 Ajax WebSocket CORS 如何创建Ajax XMLHttpRequest对象的工作流程(XMLHttpRequest、ActiveXObject(‘Microsoft.XMLHTTP’)) 兼容性处理 事件的触发条件 事件的触发顺序 跨域通信的几种方式 JSONP Hash postMessage WebSocket CORS postMessage使用CORS使用(http://www.ruanyifeng.com/blog/2016/04/cors.html)安全类 CSRF通常称为跨站请求伪造，英文名Cross-site request forgery 攻击原理利用接口漏洞，多次执行接口 防御措施 Token验证 Referer验证 隐藏令牌 XSS(http://www.imooc.com/learn/812)跨域脚本攻击，cross-site scripting 攻击原理向页面注入js进行运行 算法类 排序快速排序选择排序希尔排序 堆栈、队列、链表https://juejin.im/entry/58759e79128fe1006b48cdfd 递归https://segmentfault.com/a/1190000009857470 波兰式和逆波兰式理论: https://www.cnblogs.com/chenying99/p/3675876.html源码: https://github.com/Tairraos/rpn.js/blob/master/rpn.js 渲染机制类 什么是DOCTYPE及作用DTD(document type definition, 文档类型定义) 是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会用它来判断文档类型，决定用何种协议来解析，以及切换浏览器模式DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错 HTML5 的DOCTYPE头为&lt;!DOCTYPE html&gt;HTML4.0.1包含严格模式(strict)和宽松模式(loose)，不包括展示性和弃用元素 浏览器渲染过程 HTML通过解析生成DOM树，样式通过解析生成样式规则，DOM树和样式规则组合生成渲染树，渲染、绘制视图 重排reflowDOM结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow 触发reflow 增加、修改、删除DOM节点时，会导致reflow或repaint 移动DOM的位置，或是写动画的时候 修改CSS样式的时候 resize窗口的时候(移动端没有这个问题)，或是滚动的时候 修改网页的默认字体时(不允许突然修改字体，会导致浏览器出现问题) 重绘repaint当各种盒子的位置、大小以及其他属性，如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为repaint 触发repaint(界面变动都会触发repaint) DOM改动 CSS改动 运行机制浏览器是单线程的，先执行同步操作，再执行异步队列 异步任务 setTimeout和setInterval DOM事件 ES6中的Promise 总结 理解JS的单线程的概念 理解任务队列 理解Event Loop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类提升页面性能的方法资源压缩合并，减少HTTP请求非核心代码异步加载 → 异步加载的方式 → 异步加载的区别利用浏览器缓存 → 缓存的分类 → 缓存的原理使用CDN预解析DNS，https协议开头的，很多浏览器默认关闭dns预解析，需要执行第一行代码，强制开启预解析 // 强制打开a标签的预解析 异步加载异步加载的方式动态脚本加载deferasync异步加载的区别defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 浏览器缓存缓存分类强缓存(如果Expires和Cache-Contorl同时有，则以Cache-Control为优先)Expires Expires: Thu ,21 Jan 2018 23:59:23 GMT 以浏览器的时间作比较Cache-Control Cache-Control: max-age=3600 以服务器的时间作比较 协商缓存Last-Modified(服务器下发的) If-Modified-Since(客户端请求时带的) Last-Modified: Wed ,26 Jan 2018 00:34:23 GMTEtag(服务器下发) If-None-Match(客户端发起) 错误监控前端错误的分类 即时运行错误(代码错误) 资源加载错误 错误的捕获方式 即时运行错误的捕获方式try…catchwindow.onerror 资源加载错误(不会冒泡)object.onerrorperformance.getEntries()Error事件捕获(window.addEventListener(‘error’,fn, true)，在捕获阶段获取，不在冒泡阶段获取冒泡)延伸：跨域的js运行错误跨域捕获吗，错误提示什么，应该怎么处理？ 在script标签增加crossorigin属性设置js资源响应头Access-Control-Allow-Origin:* 上报错误的基本原理采用Ajax通信的方式上报利用Image对象上报((new Image()).src = ‘’，主要这个)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://tragiclife.github.io/tags/html/"},{"name":"js","slug":"js","permalink":"https://tragiclife.github.io/tags/js/"}]},{"title":"文件类型转换","slug":"front-end/js/file-type-conversion","date":"2018-12-23T00:10:50.000Z","updated":"2018-12-22T16:15:23.302Z","comments":true,"path":"2018/12/23/front-end/js/file-type-conversion/","link":"","permalink":"https://tragiclife.github.io/2018/12/23/front-end/js/file-type-conversion/","excerpt":"","text":"canvas转dataURL：canvas对象、转换格式、图像品质123function canvasToDataURL(canvas, format, quality) &#123; return canvas.toDataURL(format || &apos;image/jpeg&apos;, quality || 1.0);&#125; DataURL转canvas123456789101112function dataURLToCanvas(dataurl, cb) &#123; let canvas = document.createElement(&apos;canvas&apos;); let ctx = canvas.getContext(&apos;2d&apos;); let img = new Image(); img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); cb(canvas); &#125;; img.src = dataurl;&#125; image转canvas：图片地址123456789101112function imageToCanvas(src, cb) &#123; let canvas = document.createElement(&apos;canvas&apos;); let ctx = canvas.getContext(&apos;2d&apos;); let img = new Image(); img.src = src; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); cb(canvas); &#125;;&#125; canvas转image12345function canvasToImage(canvas) &#123; let img = new Image(); img.src = canvas.toDataURL(&apos;image/jpeg&apos;, 1.0); return img;&#125; File/Blob对象转DataURL1234567function fileOrBlobToDataURL(obj, cb) &#123; let a = new FileReader(); a.readAsDataURL(obj); a.onload = function (e) &#123; cb(e.target.result); &#125;;&#125; DataURL转Blob对象1234567891011function dataURLToBlob(dataurl) &#123; let arr = dataurl.split(&apos;,&apos;); let mime = arr[0].match(/:(.*?);/)[1]; let bstr = atob(arr[1]); let n = bstr.length; let u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type: mime&#125;);&#125; Blob转image1234567function blobToImage(blob, cb) &#123; fileOrBlobToDataURL(blob, function (dataurl) &#123; let img = new Image(); img.src = dataurl; cb(img); &#125;);&#125; image转Blob12345function imageToBlob(src, cb) &#123; imageToCanvas(src, function (canvas) &#123; cb(dataURLToBlob(canvasToDataURL(canvas))); &#125;);&#125; Blob转canvas12345function BlobToCanvas(blob, cb) &#123; fileOrBlobToDataURL(blob, function (dataurl) &#123; dataURLToCanvas(dataurl, cb); &#125;);&#125; canvas转Blob123function canvasToBlob(canvas, cb) &#123; cb(dataURLToBlob(canvasToDataURL(canvas)));&#125; image转dataURL12345function imageToDataURL(src, cb) &#123; imageToCanvas(src, function (canvas) &#123; cb(canvasToDataURL(canvas)); &#125;);&#125; dataURL转image，这个不需要转，直接给了src就能用12345function dataURLToImage(dataurl) &#123; let img = new Image(); img.src = d; return img;&#125; 将base64转换为文件 filename需要带后缀，否则会转成tmp 123456789101112function dataURLToFile(dataurl, filename) &#123; let arr = dataurl.split(&apos;,&apos;); let bstr = window.atob(arr[1]); let len = bstr.length; let u8arr = new Uint8Array(len); let mime = arr[0].match(/:(.*?);/)[1]; while (len--) &#123; u8arr[len] = bstr.charCodeAt(len); &#125; return new File([u8arr], filename, &#123;type: mime&#125;);&#125;","categories":[],"tags":[]},{"title":"正则","slug":"front-end/js/regexp","date":"2018-12-20T00:35:46.000Z","updated":"2018-12-19T16:40:00.810Z","comments":true,"path":"2018/12/20/front-end/js/regexp/","link":"","permalink":"https://tragiclife.github.io/2018/12/20/front-end/js/regexp/","excerpt":"","text":"一次性搞懂JavaScript正则表达式之语法 文件夹命名 1/[\\/\\\\:*?&quot;&lt;&gt;!]+/匹配特殊符号 去除字符串两端空白 123String.prototype.trim ＝ function()&#123; return this.replace(/(∧\\s*)|(\\s*$)/g,&apos;&apos;);&#125; 匹配location.search中的请求参数 123let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;)let match = str.match(reg)match[2] 参数的值","categories":[],"tags":[]},{"title":"错误捕获","slug":"front-end/js/error-catch","date":"2018-12-18T23:37:38.000Z","updated":"2018-12-18T16:16:02.134Z","comments":true,"path":"2018/12/19/front-end/js/error-catch/","link":"","permalink":"https://tragiclife.github.io/2018/12/19/front-end/js/error-catch/","excerpt":"","text":"Vue中的错误捕获例子 123456789101112// 2.2.0+支持，2.4.0+支持自定义事件的捕获Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; window.onerror1234567window.onerror = (errorMessage, scriptURI, lineNo, columnNo, error) =&gt; &#123; console.log(&apos;errorMessage: &apos; + errorMessage); // 异常信息 console.log(&apos;scriptURI: &apos; + scriptURI); // 异常文件路径 console.log(&apos;lineNo: &apos; + lineNo); // 异常行号 console.log(&apos;columnNo: &apos; + columnNo); // 异常列号 console.log(&apos;error: &apos; + error); // 异常堆栈信息&#125;; window.addEventListener(‘error’)123window.addEventListener(&apos;error&apos;, (err) =&gt; &#123; console.log(err)&#125;)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://tragiclife.github.io/tags/js/"},{"name":"error","slug":"error","permalink":"https://tragiclife.github.io/tags/error/"},{"name":"vue","slug":"vue","permalink":"https://tragiclife.github.io/tags/vue/"}]},{"title":"Canvas","slug":"front-end/js/canvas","date":"2018-12-16T23:39:44.000Z","updated":"2018-12-16T15:46:42.252Z","comments":true,"path":"2018/12/17/front-end/js/canvas/","link":"","permalink":"https://tragiclife.github.io/2018/12/17/front-end/js/canvas/","excerpt":"","text":"https://www.cnblogs.com/charmingyj/p/5527223.html 初始化// 创建canvas对象var ctx = $(“#canvas”)[0].getContext(‘2d’);var ctx2 = $(“#canvas2”)[0].getContext(‘2d’); // 设置线条颜色ctx.strokeStyle = ‘#00f’; // 设置填充颜色ctx.fillStyle = ‘#f00’;//fillRect(x, y, width, height) // 绘制有颜色填充的矩形,参数：起始坐标ctx.fillRect(0,0,100,50);//strokeRect(x, y, width, height) // 绘制无填充色的矩形ctx.strokeRect(150,0,100,50); 文本// 设置字体大小和字体ctx.font = ‘30px Arial’;ctx.cont = ‘italic 30px serif’; // 斜体 // 绘制实心文字ctx.fillText(‘Canvas’,150,25); // 绘制空心文字ctx.strokeText(‘Canvas’,0,25); // 设置颜色渐变var grd = ctx.createLinearGradient(0,0,100,0); //参数：起始坐标(x0,y0),终止坐标(x1,y1)grd.addColorStop(0,’blue’); //指定停止颜色,值为0-1grd.addColorStop(0.5,’white’);grd.addColorStop(1,’red’);ctx.fillStyle = grd;ctx.fillRect(0,50,100,50); //clearRect(x, y, width, height)ctx.clearRect(0,30,10,10); //清空矩形区域的内容,参数：x坐标,y坐标,宽度,高度 线条//moveTo(x, y)// 定义线条开始的坐标ctx2.moveTo(0,0);//lineTo(x, y) // 定义线条结束的坐标ctx2.lineTo(200,100); // 绘制线条，或者使用fillctx2.stroke(); 圆// 重新生成一条路径ctx2.beginPath();//arc(x, y, radius, startAngle, endAngle, anticlockwise) // 绘制圆形，参数：x坐标，y坐标，圆的半径，起始角度，终止角度;anticlockwise：false为顺时针，true为逆时针(默认为false)ctx2.arc(100,50,30,0,Math.PI * 2,false);ctx2.stroke(); 绘制圆弧ctx2.beginPath();ctx2.moveTo(25,50);ctx2.arc(25,50,25,0,Math.PI * 0.5,false); //参数：x坐标，y坐标，半径，起始角度(圆的正右方开始)，终止角度，是否逆时针(false为顺时针，true为逆时针)ctx2.lineTo(25,50)ctx2.stroke();","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://tragiclife.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://tragiclife.github.io/tags/canvas/"}]},{"title":"对象","slug":"front-end/js/object","date":"2018-12-16T23:28:19.000Z","updated":"2018-12-18T16:16:10.903Z","comments":true,"path":"2018/12/17/front-end/js/object/","link":"","permalink":"https://tragiclife.github.io/2018/12/17/front-end/js/object/","excerpt":"","text":"判断是不是数组12345if(typeof Array.isArray===&quot;undefined&quot;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&quot;[object Array]&quot; &#125;; &#125; vue框架核心方法defineProperty(defineProperties) 123456789writable、value和set、get不能同时存在Object.defineProperty(obj, prop, &#123; configurable: false, //是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置 enumerable: false, //枚举性，表示是否可以通过for-in循环返回 writable: false, //可写性：是否可以修改属性的值 value: undefined, //包含属性的值，也就是对应的可读性。 set: undefined, get: undefined&#125;) 对象拷贝 12345678910111213141516171819浅拷贝1. Object.assign(obj)2. 扩展运算符(...) &#123;...obj&#125;3. let obj = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(copyObj))深拷贝1. JSON.parse(JSON.stringify(obj)) 局限性 会忽略 undefined 不能序列化函数 不能解决循环引用的对象2. MessageChannel，不支持包含函数的对象，异步，支持Android4.4+function deepCopy(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125; new的过程 创建一个新对象 将构造函数的作用域赋值给新对象 执行构造函数的代码 返回新的对象 原型链的顶层是什么 null 禁止扩展方法1234567891011121314151617// 禁止对象扩展，可修改已有的值，可以通过defineProperty重新定义已有属性Object.preventExtensions(obj); // 判断对象是否可扩展Object.isExtensible(obj);// 禁止对象扩展，可修改已有的值，不可以通过defineProperty重新定义已有属性Object.seal(obj)// 判断对象是否密封Objct.isSealed(obj);// 冻结对象，返回冻结的对象，不能做任何操作，只能读取Object.freeze(obj)// 判断对象是否冻结Object.isFrozen(obj) 函数 对象已设置为不可扩展的 为每个属性将configurable设置为false 为每个属性将writable设置为false Object.preventExtensions 是 否 否 Object.seal 是 是 否 Object.seal 是 是 是 函数 对象是否可扩展 为每个属性将configurable设置为false 为每个属性将writable设置为false Object.preventExtensions 是 否 否 Object.seal 否 是 是 Object.seal 否 是 是 Object.create(null)、new Object()、{}的区别 Object.create(null)创建的对象没有继承Object的属性和方法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://tragiclife.github.io/tags/js/"},{"name":"Object","slug":"Object","permalink":"https://tragiclife.github.io/tags/Object/"}]},{"title":"事件","slug":"front-end/js/event","date":"2018-12-15T23:17:49.000Z","updated":"2018-12-23T10:49:23.450Z","comments":true,"path":"2018/12/16/front-end/js/event/","link":"","permalink":"https://tragiclife.github.io/2018/12/16/front-end/js/event/","excerpt":"","text":"事件的绑定与解绑事件绑定123456789addEventListener(type, fn, useCapture/options)useCapture: 默认为false，监听冒泡阶段options可传值： - passive: false 是否阻止默认事件；如果设置为true，则即使在触发的函数中使用e.preventDefault也不会生效 - capture: false 触发阶段；true为捕获时触发，false为冒泡时触发 - once: 只执行一次IEattachEvent(&apos;on&apos; + type, listener); 事件解绑12345// 传值与绑定相同removeEventListener(type, fn, useCapture/options)IEdetachEvent(&apos;on&apos; + type, listener); 自定义事件12345678使用handleEventvar tap = &#123; handleEvent: function(e) &#123; console.log(this.name); &#125;, name:&apos;tap&apos;&#125;;document.querySelector(&apos;.wea_mod&apos;).addEventListener(&apos;click&apos;, tap, false); 1234567891011使用CustomEventvar tap2 = document.querySelector(&apos;.wea_mod&apos;);tap2.addEventListener(&apos;tap&apos;, function(e)&#123; console.log(&apos;custom &apos; + e.detail);&#125;, false);var evt = new window.CustomEvent(&apos;tap&apos;, &#123; bubbles: true, // 如果为 true，事件将冒泡到触发事件的元素的祖先 cancelable: true, // 如果为 true，可以使用事件对象的 stopPropagation() 方法取消事件传播。 detail: &#123;&#125; // 细节参数、自定义参数&#125;);tap2.dispatchEvent(evt); // 触发自定义事件，返回一个布尔值，判断是否阻止默认事件，false为阻止默认事件 123456789101112使用new Event(不能使用自定义参数detail)var btn = document.querySelector(&apos;.wea_mod&apos;);var ev = new Event(&apos;test&apos;, &#123; bubbles: &apos;true&apos;, cancelable: &apos;true&apos;&#125;);btn.addEventListener(&apos;test&apos;, function (event) &#123; console.log(event.bubbles); console.log(event.cancelable); console.log(event.detail);&#125;, false);btn.dispatchEvent(ev); 123456使用createEventlet evt = document.createEvent(&quot;HTMLEvents&quot;); // 可传值HTMLEvents、MouseEvents、UIEvents以及CustomEvent(自定义事件)// 初始化evt.initEvent(&quot;alert&quot;, false, false); // eventType,canBubble,cancelable// 触发week.dispatchEvent(evt);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://tragiclife.github.io/tags/js/"},{"name":"Event","slug":"Event","permalink":"https://tragiclife.github.io/tags/Event/"}]},{"title":"移动端屏幕像素","slug":"front-end/other/mobile-screen-pixels","date":"2018-12-14T22:12:06.000Z","updated":"2018-12-18T16:21:10.062Z","comments":true,"path":"2018/12/15/front-end/other/mobile-screen-pixels/","link":"","permalink":"https://tragiclife.github.io/2018/12/15/front-end/other/mobile-screen-pixels/","excerpt":"","text":"Pixel 移动开发像素知识px: css pixels 逻辑像素，浏览器使用的抽象单位dp,pt: device independent pixels 设备无关像素dpr: devicePixelRatio 设备像素缩放比 计算公式：1px = (dpr)² * dp DPI: 打印机每英寸可以喷的墨汁点(印刷行业)PPI: 屏幕每英寸的像素数量，即单位英寸内的像素密度 计算公式：以iPhone5为例子ppi = √ (1136² + 640²) / 4 = 326ppi (视网膜Retina屏) ldpi mdpi hdpi xhdpi ppi 120 160 240 320 默认缩放比 0.75 1.0 1.5 2.0 Retina屏(高清屏): dpr都是大于等于2 PPI越高，像素数越高，图像越清晰但可视度越低(小)，系统默认设置缩放比越大 Viewport手机浏览器默认为我们做两件事页面渲染在980px(ios)的viewport(为了排版正确)缩放(排版正确后，再缩放到手机屏幕大小) //这就是网页在手机上，会全屏显示的原因 visual viewport：度量/视口viewport宽高visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。// 无法改变，通过缩放scale控制layout viewport: 布局viewport 如图，ios的默认layout viewport为980px// 可以理解为就是body的宽度，在此之上渲染页面 为什么不适用默认的980px的布局viewport(layout viewport)宽度不可控制，不同系统不同设备的默认值都可能不同页面先在layout viewport全屏渲染css,再通过缩放由visual viewport展示，交互不友好链接不可点有缩放，缩放后又有滚动font-size:40px=PC的12px,不规范，字体设置是另外一门学问了。 meta标签 width: 设置布局viewport的特定值(device-width)initial-scale: 设置页面的初始缩放minimum-scale: 最小缩放maximum-scale: 最大缩放user-scalable: 用户能否缩放最常用写法 方案一：根据设备的实际宽度来设计(常用)手机宽320px，拿320px设计方案二：1px=1dp缩放0.5。根据设备的物理像素dp等于抽象像素px来设计。1像素边框和高清图片都不需要额外处理。 响应式设计媒体类型：screen(屏幕)print(打印机)handheld(手持设备)all(通用)常用媒体查询参数：width(视口宽度)height(视口高度)device-width(设备宽度)device-height(设备高度)orientation(检查设备处于横向(landscape)还是竖屏(portrait)) 移动web页面上的click事件响应都要慢上300ms使用tap事件代替click事件 自定义tap事件原理：在touchstart、touchend时记录时间、手指位置，在touchend时进行比较，如果手指位置为同一位置(或允许移动一个非常小的位移值)且时间间隔较短(一般认为是200ms)，且过程中未曾触发过touchmove，即可认为出发了手持设备上的”click”，一般称它为”tap” tap透传的解决方案使用缓动动画，过渡300ms的延迟中间层dom元素的加入，让中间层接受这个“穿透”事件，稍后隐藏“上下”都使用tap事件，原理上解决tap透传事件(但不可避免原生标签的click事件)改用Fastclick的库 触摸事件touchstart: 手指触摸屏幕触发(已经有手指放屏幕上不会触发)touchmove: 手指在屏幕华东，连续触发touchend: 手指离开屏幕时触发touchcancel: 系统取消touch时候触发(不常用) 触摸属性touches: 跟踪触摸操作的touch对象数组targetTouches: 特定事件目标的touch对象数组changeTouches: 上次触摸改变的touch对象数组 每个touch对象包含属性:clientX: 触摸目标在视口中的x坐标clientY: 触摸目标在视口中的y坐标identifier: 标识触摸的唯一IDpageX: 触摸目标在页面中的x坐标(包含滚动)pageY: 触摸目标在页面中的y坐标(包含滚动)screenX: 触摸目标在屏幕中的x坐标screenY: 触摸目标在屏幕中的y坐标target: 触摸目标的DOM节点 弹性滚动body层滚动(系统特殊化处理):自带弹性滚动，overflow: hidden失效，GIF和定时器暂停局部滚动:没有弹性滚动，没有惯性滚动，不流畅局部滚动开启弹性滚动(仅支持IOS)-webkit-overflow-scrolling: touch;上拉加载使用scroll事件，而不是touch事件(因为android中会有bug) -webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug在使用该属性的元素上不设置定位或者手动设置定位为static在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。 -webkit-overflow-scrolling:touch还会导致的bug滚动中 scrollTop 属性不会变化手势可穿过其他元素触发元素滚动滚动时暂停其他 transition","categories":[],"tags":[]},{"title":"面试记录","slug":"front-end/other/interview-record","date":"2018-12-13T22:23:55.000Z","updated":"2018-12-18T16:20:49.386Z","comments":true,"path":"2018/12/14/front-end/other/interview-record/","link":"","permalink":"https://tragiclife.github.io/2018/12/14/front-end/other/interview-record/","excerpt":"","text":"记录一个页面上两个div左右铺满整个浏览器，要保证左边的div一直为100px，右边的div跟随浏览器大小变化（比如浏览器为500，右边div为400，浏览器为900，右边div为800），请写出大概的css代码。 使用flex 12345678910111213141516171819202122//html&lt;div class=&apos;box&apos;&gt;&lt;div class=&apos;left&apos;&gt;&lt;/div&gt; &lt;div class=&apos;right&apos;&gt;&lt;/div&gt;&lt;/div&gt;//css.box &#123; width: 400px; height: 100px; display: flex; flex-direction: row; align-items: center; border: 1px solid #c3c3c3;&#125;.left &#123; flex-basis：100px; -webkit-flex-basis: 100px; /* Safari 6.1+ */ background-color: red; height: 100%;&#125;.right &#123; background-color: blue; flex-grow: 1;&#125; 浮动布局 123456789101112131415161718&lt;div id=&quot;left&quot;&gt;Left sidebar&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;Main Content&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;#left &#123; float: left; width: 220px; background-color: green;&#125;#content &#123; background-color: orange; margin-left: 220px; /*==等于左边栏宽度==*/&#125;&lt;/style&gt; 请写出一些前端性能优化的方式，越多越好 减少dom操作 部署前，图片压缩，代码压缩 优化js代码结构，减少冗余代码 减少http请求，合理设置 HTTP缓存 使用内容分发cdn加速 静态资源缓存 图片延迟加载 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器查找域名的 IP 地址 这一步包括 DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从http://example.com到http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求 请大概描述下页面访问cookie的限制条件 跨域问题 设置了HttpOnly 描述浏览器重绘和回流，哪些方法能够改善由于dom操作产生的回流 直接改变className，如果动态改变样式，则使用cssText 1234567891011// 不好的写法var left = 1;var top = 1;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;; // 比较好的写法el.className += &quot; className1&quot;;// 比较好的写法el.style.cssText += &quot;;left: &quot; + left + &quot;px;top: &quot; + top + &quot;px;&quot;; 让要操作的元素进行”离线处理”，处理完后一起更新 123a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；b) 使用display:none技术，只引发两次回流和重绘；c) 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘 vue生命周期钩子 beforcreate created beformount mounted beforeUpdate updated actived deatived beforeDestroy destroyed js跨域请求的方式，能写几种是几种 通过jsonp跨域 通过修改document.domain来跨子域 使用window.name来进行跨域 使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持） CORS 需要服务器设置header ：Access-Control-Allow-Origin。 nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求 对前端工程化的理解 开发规范 模块化开发 组件化开发 组件仓库 性能优化 项目部署 开发流程 开发工具 js深度复制的方式 使用jq的$.extend(true, target, obj) newobj = Object.create(sourceObj)，// 但是这个是有个问题就是newobj的更改不会影响到 sourceobj但是 sourceobj的更改会影响到newObj newobj = JSON.parse(JSON.stringify(sourceObj)) js设计模式: 总体来说设计模式分为三大类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式 图片预览123456789101112&lt;input type=&quot;file&quot; name=&quot;file&quot; onchange=&quot;showPreview(this)&quot; /&gt;&lt;img id=&quot;portrait&quot; src=&quot;&quot; width=&quot;70&quot; height=&quot;75&quot;&gt;function showPreview(source) &#123; var file = source.files[0]; if(window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function(e) &#123; document.getElementById(&quot;portrait&quot;).src = e.target.result; &#125;; fr.readAsDataURL(file); &#125;&#125; 扁平化多维数组 老方法 123456789101112var result = []function unfold(arr)&#123; for(var i=0;i&lt; arr.length;i++)&#123; if(typeof arr[i]==&quot;object&quot; &amp;&amp; arr[i].length&gt;1) &#123; unfold(arr[i]); &#125; else &#123; result.push(arr[i]); &#125; &#125;&#125;var arr = [1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];unfold(arr) 使用tostring 12var c=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];var b = c.toString().split(&apos;,&apos;) 使用es6的reduce函数 123var arr=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];const flatten = arr =&gt; arr.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);var result = flatten(arr) iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 数组乱序 方法一 123456789function shuffle(a) &#123; var len = a.length; for (var i = 0; i &lt; len - 1; i++) &#123; var index = parseInt(Math.random() * (len - i)); var temp = a[index]; a[index] = a[len - i - 1]; a[len - i - 1] = temp; &#125;&#125; 方法二 12345function shuffle(arr)&#123; return arr.sort(() =&gt; &#123; return Math.random() &gt; 0.5 ? -1:1 &#125;)&#125; new Function的写法1var message = new Function(&apos;msg&apos;,&apos;alert(msg)&apos;); 原型链顶层 Object.prototype 代码题12345678910var test = (function(a)&#123; this.a = a * 2; // 立即执行函数的this指向window return function(b)&#123; return this.a + b; &#125;&#125;)((function(a)&#123; return a&#125;)(1,2))console.log(test(4)) // 6 明源云状态码及其表达的意思 200 请求成功 204 请求成功，但没有返回响应实体 401 当前请求需要用户验证 403 禁止访问 404 资源未找到 408 请求超时 500 后台程序错误 防止代码提交冲突的方案 axios发起请求会有两个的原理，axios跨域处理OPTIONS是预请求，判断其是否能支持跨域 vuex原理 svn和git的区别 使用ES5或者ES6实现单例模式 ES5 1234567891011121314var Single = function(name)&#123; this.name = name; // 一个标记，用来判断是否已经创建了该类的实例 this.instance = null;&#125;// 提供了一个静态方法，用户可以直接在类上调用Single.getInstance = function(name)&#123; // 没有实例化的时候创建一个该类的实例 if (!this.instance) &#123; this.instance = new Single(name) &#125; // 已经实例化了，返回第一次实例化对象的引用 return this.instance;&#125; ES6 12345678910111213class Single &#123; constructor(name) &#123; this.name = name; this.instance = null; &#125; // 构造一个广为人知的接口，供用户对该类进行实例化 static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Single(name); &#125; return this.instance; &#125;&#125; 代码题1234567891011var test = function(a, b)&#123; alert(b); return &#123; test: function(c)&#123; return test(c, a) &#125; &#125;&#125;var a = test(100);a.test(201);a.test(301); // undefined 100 100var a = test(101).test(201).test(301); // undefined 101 201var a = test(103).test(203);a.test(303); // undefined 103 203 Promise链式调用其中一个报错，如何让其继续运行在catch中捕获错误 AMD和CMD的异同 相同点 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 不同点 定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。 遵循的规范不同。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。 推广理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。 对开发调试的支持有差异。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。 插件机制不同。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。 1234567891011121314CMD 推崇依赖就近，AMD 推崇依赖前置。//CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() &#125;)// AMD 默认推荐的是define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;// 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething()&#125;) 如何使脱离文档流的元素回到文档流 旺合盛世rem和百分比的优缺点 iframe的优缺点优点 iframe能够原封不动的把嵌入的网页展现出来 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。5.重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度) 缺点 页面样式调试麻烦，出现多个滚动条； 浏览器的后退按钮失效； 过多会增加服务器的HTTP请求； 小型的移动设备无法完全显示框架； 产生多个页面，不易管理； 不容易打印； 代码复杂，无法被一些搜索引擎解读。 星斯达什么是MVC，MVC的框架又哪些 如何通过正则匹配协议12location.href.match(/(\\w*):\\/\\//)[&quot;https://&quot;, &quot;https&quot;, index: 0, input: &quot;https://www.bilibili.com/video/av11314749/&quot;,length: 2] js实现二分树 智游人vue-router中history和hash模式有什么区别hash模式的话路由地址会带上#，但是浏览器发送给服务端的却实#之前的URL，hash模式的好处是，虽然你是个单页面应用，但你可以刷新当前页。history的话需要服务端配合，如果服务端配置仅仅是找不到路由，就重定向到index.html，那么刷新会跳首页，如果服务端对于匹配不到URL不做配置，那么一般返回404页面 样式优先级important &gt; 内联样式 &gt; id选择器 &gt; 类选择器、伪类选择器(:hover)、属性选择器 &gt; 伪元素选择器(::before)、标签选择器 冒泡排序123456789101112function arrSort (arr) &#123; var i, j, tmp, len = arr.length - 1; for(i = 0; i&lt; len; i++) &#123; for(j = 0; j &lt; len - i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; // 升序 tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125;&#125; 仙人掌原型和原型链 开拍网DOM操作方法parent.appendChild(child) 增加子元素parent.removeChild(child) 删除子元素parent.replaceChild(new, old) 替换子元素parent.insertBefore(new, existsDOM) 向已有子节点添加元素element.nextSibling 返回元素相邻的下一个元素element.previousSibling 返回元素相邻的上一个元素","categories":[],"tags":[]},{"title":"项目中遇到的那些事","slug":"front-end/other/problems-encountered-in-the-project","date":"2018-12-12T22:03:31.000Z","updated":"2018-12-27T16:07:07.548Z","comments":true,"path":"2018/12/13/front-end/other/problems-encountered-in-the-project/","link":"","permalink":"https://tragiclife.github.io/2018/12/13/front-end/other/problems-encountered-in-the-project/","excerpt":"","text":"vue界面渲染时出现花括号{}123456在挂载vue的标签上使用v-cloak，设置v-cloak属性的样式，vue渲染完后会自动移除该属性&lt;div class=&quot;app&quot; v-cloak&gt;&lt;/div&gt;[v-cloak]&#123; display: none;&#125; 使用:style或:class绑定时，key名带中划线(-)问题1用引号将该key包裹起来，:style=&#123;&apos;background-color&apos;: &apos;#fff&apos;&#125; 错误捕获 2.2.0+可用, 2.4.0+支持自定义事件的捕获123456789101112Vue.config.errorHandler捕获钩子函数的报错信息，只能捕获钩子函数的错Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 使用ref绑定问题 如果绑定的元素为遍历元素，则生成的refs为数组 vue-router在history模式下使用子路由刷新报错问题 修改assetsPublicPath路径，使用绝对路径 style标签使用scoped的时候无法覆盖子组件样式1234解决方法:1. 去掉scoped2. 混用本地和全局样式，即增加一个style标签，不写scoped，进行样式覆3. 使用深度选择器 /deep/或者&gt;&gt;&gt;，如.a /dep/ .b&#123;&#125; 进入详情页要缓存，从首页进入时要刷新的处理方法1234567891011121314151617181920212223242526使用keep-alive，在router中定义keeyAlive，在App.vue中&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;js代码：watch: &#123; $route: &#123; handler(to, from) &#123; if (to.name === &apos;Home&apos;) &#123; this.$refs.customerList.clearStatus(); from.meta.reload = true; &#125; &#125; &#125;&#125;,created() &#123; this.loadData();&#125;,activated() &#123; if (this.$route.meta.reload) &#123; this.loadData(); this.$route.meta.reload = false; &#125;&#125; style标签使用scss的@import相对路径问题1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;], alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;src&apos;), &#125;&#125;引用时，@import &apos;~@/scss/icon.scss&apos;; Duplicate presence of slot “titleName” found in the same render tree1234使用具名插槽slot-scope&lt;template slot=&quot;titleName&quot; slot-scope=&quot;props&quot;&gt; &lt;span class=&quot;order-title&quot;&gt;采购订单&lt;/span&gt;&lt;/template&gt; IOS日期转换问题12日期中不允许有-，需要replace(/-/g, &apos;/&apos;)才可以进行new Date()日期中不允许有.0，如(2018-09-06 00:00:00.0)，需要replace(/\\..*/g,&apos;&apos;)替换处理 滚动暂停问题121. 将滚动容器从body改为app，设置-webkit-overflow-scrolling:touch，该属性会造成scroll事件只会在滚动停止的时候执行一次2. 使用滚动插件(如better-scroll) IOS7伸缩盒兼容性问题 使用伸缩盒时加webkit前缀，使用box IOS9元素运行动画后不显示问题121. z-index没有设置或者太小2. 没有设置animation-fill-mode: forwards animation-play-state失效问题1234567添加父容器，在暂停的时候给父容器加transformlet container = this.$refs.musicContainerlet musicT = getComputedStyle(this.$refs.music).transformlet containerT = getComputedStyle(container).transformlet transform = containerT === &apos;none&apos; ? musicT : musicT.concat(&apos; &apos;, containerT)container.style.transform = transformcontainer.style.webkitTransform = transform 使用-webkit-overflow-scrolling:touch问题 如果触发了外层容器的弹性滚动，则该元素短时间内会无法滚动，可以使用better-scroll来实现滚动 Android打开view时界面会有空白问题 在mounted中使用setTimeout进行font-size的设置 Android4.3中设置background的大小不生效 通过background-size设置 4.3版本的svg无法使用transform 用div将svg包裹起来，设置div的transform 兼容低版本css 带webkit的css要放在后面 Android4系统touchmove问题 在touchmove的时候会执行touchcancel事件，导致touchmove只执行一次，需要使用e.preventDefault阻止默认事件才可以执行多次，但是会导致一些默认行为不触发，如scroll click事件失效问题 父元素的touch事件加了preventDefault导致子元素的click事件不触发，修改子元素的click事件为touch事件 动画由大变小闪动问题123给动画元素的父容器加position: relative;overflow: hidden; 插件new Swiper的问题 在元素隐藏的时候new Swiper，Swiper会有错位问题1234561. 设置obserVer和observParents为true new Swiper(this.$refs.swiperContainer, &#123; observer: true,//修改swiper自己或子元素时，自动初始化swiper observeParents: false,//修改swiper的父元素时，自动初始化swiper &#125;);2. 显示的时候手动调用update方法 better-scroll内的子元素无法通过overflow滚动 better-scroll的bug vue中同事使用keep-alive和better-scroll同时使用keep-alive和better-scroll时，better-scroll注册的事件不会自动销毁，需要手动调用bScroll.destroy()方法进行销毁。 svg使用animate时，animate动画不运行 121. 获取animate的DOM，调用beginElement方法执行动画2. animate的dur设置的时间太小(小于25ms)，动画不会执行 JScanvas绘制问题 绘制前需要设置canvas的宽高 工具使用webstorm时无法自动编译问题 取消webstorm的自动保存功能 http401状态码 登录token有问题 好车主APP某些机型打开健步行时白屏问题 绘制圆环canvas的时候没有获取到DOM导致webview奔溃，在$nextTick的时候绘制canvas，后面改成了SVG aopsId获取失败 连续调用了相同的客户端方法，导致前面的被覆盖 安卓手机音频无法自动播放 通过touch事件手动触发播放 监听APP前后台切换 通过postEvent方法监听webview的切换 因为手机设置字体大小导致样式错位问题 安卓客户端通过webview配置webview.getSettings().setTextZoom(100)就可以禁止缩放，按照百分百显示。 微信/企业微信微信端无法自动播放音频问题 方法一 使用微信提供的js-sdk，在ready中调用播放的API1234567891011121314151617//首先引用js: &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;//然后写方法: function autoPlayAudio1()&#123; wx.config(&#123; //配置信息, 即使不正确也能使用 wx.ready debug: false, appId: &apos;&apos;, timestamp: 1, nonceStr: &apos;&apos;, signature: &apos;&apos;, jsApiList: [] &#125;); wx.ready(function() &#123; document.getElementById(&apos;audio&apos;).play(); &#125;);&#125; 方法二1234var audio=document.querySelector(&quot;#audio&quot;); document.addEventListener(&quot;WeixinJSBridgeReady&quot;,function()&#123; audio.play();&#125;, false); 隐藏分享栏 1WeixinJSBridge.call(&apos;hideOptionMenu&apos;) 企业微信注册报invalid signture 在home界面调用注册方法会报错，修改调用的位置至需要使用新建表单页面 后台返回的时间戳单位需要为秒，注册的url需要encodeURIComponent再传给后台，由后台decode 项目用的是history模式，每个页面使用sdk都需要重新调用注册方法 url不调用encodeURIComponent的话链接上通过&amp;字符连接起来的参数会不被加入签名中 安卓手机无法预览图片12345调用接口时，urls必须传wx.previewImage(&#123; current: imgUrl, // 当前显示图片的http链接 urls: [imgUrl] // 需要预览的图片http链接列表&#125;);","categories":[],"tags":[]},{"title":"日常小记-JS","slug":"front-end/js/daily-notes","date":"2018-12-11T23:59:39.000Z","updated":"2018-12-24T15:40:55.856Z","comments":true,"path":"2018/12/12/front-end/js/daily-notes/","link":"","permalink":"https://tragiclife.github.io/2018/12/12/front-end/js/daily-notes/","excerpt":"","text":"$(“p”).empty与$(“p”).remove1234$(&quot;p&quot;).empty移除p标签中的文本及其子节点，留下p标签$(&quot;p&quot;).remove移除p标签及其文本内容还有其子节点 事件绑定12345678910111213DOM2级事件addEventListener(type, listener, useCapture/options);removeEventListener(type, listener, useCapture/options);useCapture: 默认为false，监听冒泡阶段options: &#123; capture: Boolean, // 是否在捕获阶段触发事件 passive: Boolean, // 使preventDefault调用无效，可优化界面滚动效果 once: Boolean, // 是否执行一次&#125;IEattachEvent(&apos;on&apos; + type, listener);detachEvent(&apos;on&apos; + type, listener); 消除事件处理器的影响 图解浏览器的工作原理 123456789101112131415161718让浏览器即监听相关事件，又让组合器线程在等等主线程响应前构建新的组合帧document.body.addEventListener(&apos;touchstart&apos;, event =&gt; &#123; if (event.target === area) &#123; event.preventDefault() &#125;&#125;, &#123;passive: true&#125;);垂直方向的滚动可能会先于event.preventDefault()发生，此时可以通过 event.cancelable 来防止这种情况document.body.addEventListener(&apos;pointermove&apos;, event =&gt; &#123; if (event.cancelable) &#123; event.preventDefault(); // block the native scroll &#125; &#125;, &#123;passive: true&#125;);也可以使用 css 属性 touch-action 来完全消除事件处理器的影响，如：#area &#123; touch-action: pan-x; &#125; 表示false的值 false, 0, 空字符串(‘’), null, undefined Number,Boolean,String,Undefined比较问题 会先将复合对象转换成基本类型（依次调用valueOf和toString方法）再进行比较，undefined被当成基本类型，undefined转换成数字是NaN，因此undefined与除null之外的其它类型值进行比较时始终返回false（注意NaN==NaN返回false）null被当成复合对象，由于null没有valueOf和toStribg方法，因此除了和undefined之外的其它类型值进行比较时始终返回false 设置prototype的值为对象时，首先要还原构造器1234let Person = function()&#123;&#125;Person.prototype = &#123; constructor: Person&#125; 复制内容到粘贴板(仅支持IE)12let text = document.querySelector(&apos;.text&apos;).innerText;window.clipboardData.setData(&apos;text&apos;, text); []和new Array[]的运行速度比new Array快，后者需要调用构造器 mouseout、mouseleave12mouseout: 无论鼠标离开被选元素(绑定事件的元素)还是其子元素都会触发mouseleave: 当鼠标离开被选元素时触发 获取选中select标签的文本12// value和选择文本不同时，sel为select标签的dom元素sel.options[sel.selectedIndex].text hover事件相当于mouseenter+mouseleave，不相当于mouseover+mouseout，mouseover(mouseout)鼠标进入(离开)某个元素或其子元素时触发。 javascript:void(0)javascript是伪协议，表示url的内容通过javascript执行。void(0)表示不做任何操作，这样会防止链接跳转到其他界面。这么做可以保存链接的样式，但不让链接执行实际操作，具体的操作交给链接的onclick事件处理 函数声明12函数声明：function fn()&#123;&#125;函数表达式：var fn = function()&#123;&#125; 将伪数组转换成数组Array.prototype.slice.call(arguments, 0); 操作class12345dom.classList.value 获取所有类名dom.classList.add() 添加类dom.classList.remove() 移除类dom.classList.contains() 查看是否存在某个类dom.classList.toggle() 切换是否显示某个类 获取对象类型12345678Object.prototype.toString.call(xx); // 结果为[object Type]// 判断是否为数组if(typeof Array.isArray===&apos;undefined&apos;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&apos;[object Array]&apos; &#125;; &#125; 判断是否为undefined12345let a;undefined = 1; // 这样判断就会出错a === undefined; // undefined不是保留字，能被赋值a === void 0; // void后面随便跟上一个组成表达式，返回就是undefined bind、call、apply的区别 bind只改变上下文环境，不执行 call第二个参数开始是参数列表 allpy第二个参数是数组 获取元素样式1getComputedStyle(dom, 伪类); // 可以获取伪类样式 判断图片是否加载完成1231. onload2. 通过img.complete属性判断3. onreadystatechange，img.readyState为complete或者loaded为加载完成 setTimeout(fn, time, param) fn: 回调函数 time: 延迟调用时间 param: 传入回调的参数 获取transform后元素的宽高1dom.getBoundingClientRect() 语法简写123456789101112131415161718192021222324252627//取整parseInt(a,10); //BeforeMath.floor(a); //Beforea&gt;&gt;0; //Before~~a; //Aftera|0; //After//四舍五入Math.round(a); //Beforea+.5|0; //After//内置值undefined; //Beforevoid 0; //After, 快0[0]; //After, 略慢//内置值Infinity;1/0;//布尔值短写法true; //Before!0; //After//布尔值短写法false; //Before!1; //After base64图片前缀data:image/png;base64, 拷贝12345对象拷贝let obj = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(copyObj))数组拷贝let arr = [].concat(copyArr); 第二次var定义变量如果不赋值，该值为原来定义的值123var a = 100;var a;console.log(a); // 100 函数声明会比变量声明先1234console.log(a); // functionvar a = &apos;123&apos;;function a ()&#123;&#125;;console.log(a); // 123 new的过程 创建一个新对象 将构造函数的作用域赋值给新对象 执行构造函数的代码 返回新的对象 原型链的顶层null 自定义事件12345let evt = document.createEvent(&quot;HTMLEvents&quot;);// 初始化evt.initEvent(&quot;alert&quot;, false, false);// 触发week.dispatchEvent(evt); 查看元素事件12window.getEventListeners(window); // 返回事件对象，如&#123;click:[], mousedown:[]&#125;window.getEventListeners(window).click[0].listener; // 获取第一个绑定的click事件函数 生成任意长度，且值为undefined的数组Array.apply(null, {length: 2}); // [undefined, undefined] 移动端将键盘回车变为搜索12345将input的type改为search在input外包一层form, form标签设置action属性, 设置autocomplete=&quot;off&quot;去掉弹出的下拉框设置input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123;display: none;&#125;将默认的X隐藏掉设置-webkit-appearance: none;去掉默认样式使用ajax提交时需要preventDefault阻止默认行为 监听APP返回键12345678910var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; : &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; : &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; : null;var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;);var onVisibilityChange = function()&#123; if (document[hiddenProperty]) &#123; console.log(&apos;页面非激活&apos;); &#125;else&#123; console.log(&apos;页面激活&apos;) &#125;&#125;document.addEventListener(visibilityChangeEvent, onVisibilityChange); parseInt1parseInt(&apos;12abc&apos;); // 12 触发鼠标右键事件1on(&quot;contextmenu&quot;) window.openwindow.open打开的子窗口可以使用opener访问父窗口的方法和变量 onInput谷歌控制台使用Ctrl+p可以输入要打开的文件；onInput 是 HTML5 的标准事件，对于检测 textarea, input(text), input(password) 和 input(search) 这几个元素通过用户界面发生的内容变化非常有用，在内容修改后立即被触发，不像 onchange 事件需要失去焦点才触发。oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的onpropertychange 事件替代。 try、catch、finallyJs如果在try中return则不会进入finally 改变当前链接1location.replace(url) IOS日期转换问题IOS的Safari在new Date()的时候不支持’2017-3-6’的格式，支持’2017/3/6’，也不支持date为2018/09/19 00.00.00.0，后缀带.0的 httpget请求默认会在浏览器中缓存，可以通过添加时间戳来避免缓存 NodeJS Event loop1234567891011121314151617181920212223242526272829console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&apos;Promise&apos;) resolve()&#125;).then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout微任务: process.nextTick, promise, Object.observe, MutationObserver宏任务: script, setTimeout, setInterval, setImmediate, I/O, UI rendering&gt; setImmediate会比setTimeout先执行Event loop执行顺序1. 执行同步代码，这属于宏任务2. 执行栈为空，查询是否有微任务需要执行3. 执行所有微任务4. 必要的话渲染 UI5. 然后开始下一轮 Event loop，执行宏任务中的异步代码 存储特性 | cookie | localStorage | sessionStorage | indexDB—|—|—|—|—数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在数据存储大小 | 4K | 5M | 5M | 无限与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 cookie安全性属性 | 作用—|—value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击secure | 只能在协议为 HTTPS 的请求中携带same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 1234567891011121314151617181920212223242526272829303132// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker.register(&apos;sw.js&apos;).then(registration =&gt; &#123; console.log(&apos;service worker 注册成功&apos;); &#125;).catch((err) =&gt; &#123; console.log(&apos;service worker 注册失败&apos;); &#125;);&#125;// sw.js// 监听install事件，回调缓存所需文件self.addEventListener(&apos;install&apos;, e =&gt; &#123; e.waitUntil( // 设置缓存的名称为my-cache caches.open(&apos;my-cache&apos;).then(cache =&gt; &#123; return cache.addAll([&apos;./index.html&apos;, &apos;./index.js&apos;]); &#125;); );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&apos;fetch&apos;, e =&gt; &#123; e.respondWith( caches.match(e.request).then(response =&gt; &#123; if (response) &#123; return response &#125; console.log(&apos;fetch source&apos;); &#125;); );&#125;) Load和DOMContentLoaded区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 生成新图层 3D变换: translate3d、translateZ will-change video、iframe标签 通过动画实现的opacity动画转换 position: fixed 对于频繁渲染的建议生成一个新的图层，提高性能。但不能生成过多图层，会引起反作用。 重绘(Repaint)和回流(Reflow) 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 并行、并发 并行：宏观和微观上都是同时进行 并发：宏观上同时，微观上不同时 工具库loadash、date-fns(日期格式化)、accounting.js(货币格式化) jsencrypt用于请求参数加密处理，加密方式为RSA vue框架核心方法defineProperty(defineProperties)123456789writable、value和set、get不能同时存在Object.defineProperty(obj, prop, &#123; configurable: false, //是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置 enumerable: false, //枚举性，表示是否可以通过for-in循环返回 writable: false, //可写性：是否可以修改属性的值 value: undefined, //包含属性的值，也就是对应的可读性。 set: undefined, get: undefined&#125;) 获取github用户信息https://api.github.com/users/{id} 复制功能 https://clipboardjs.com/ https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4 安装nvm后无法使用问题先nvm install node，然后再nvm use [version] nvm安装最新nodejs包nvm install latest 判断点击元素是否为某个元素的后代元素12345document.addEventListener(&apos;click&apos;, (e) =&gt; &#123; if (el.contains(e.target)) &#123; console.log(&apos;包含&apos;) &#125;&#125;)","categories":[],"tags":[]},{"title":"meta标签","slug":"front-end/html/tag-meta","date":"2018-12-11T00:43:10.000Z","updated":"2018-12-12T14:01:51.522Z","comments":true,"path":"2018/12/11/front-end/html/tag-meta/","link":"","permalink":"https://tragiclife.github.io/2018/12/11/front-end/html/tag-meta/","excerpt":"","text":"meta标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset=&apos;utf-8&apos;&gt;&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;&lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt;&lt;!-- 页面描述 --&gt;&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;&lt;!-- 网页作者 --&gt;&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;&lt;!-- 搜索引擎抓取 --&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;!-- 为移动设备添加 viewport --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;&lt;!-- iOS 设备 begin --&gt;&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;&lt;!-- iOS 图标 begin --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;!-- iOS 图标 end --&gt;&lt;!-- iOS 启动画面 begin --&gt;&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;&lt;!-- iPad 横屏 2048x1496（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;&lt;!-- iOS 启动画面 end --&gt;&lt;!-- iOS 设备 end --&gt;&lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;&lt;!-- Windows 8 磁贴图标 --&gt;&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;&lt;!-- 添加 RSS 订阅 --&gt;&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;&lt;!-- 添加 favicon icon --&gt;&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;&lt;!-- sns 社交标签 begin --&gt;&lt;!-- 参考微博API --&gt;&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;&lt;!-- sns 社交标签 end --&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://tragiclife.github.io/tags/html/"}]},{"title":"css实现居中","slug":"front-end/css/css-centered","date":"2018-12-11T00:03:53.000Z","updated":"2019-01-01T16:04:51.475Z","comments":true,"path":"2018/12/11/front-end/css/css-centered/","link":"","permalink":"https://tragiclife.github.io/2018/12/11/front-end/css/css-centered/","excerpt":"","text":"定位1234position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); 伸缩盒123display: flex;justify-content: center;align-items: center;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"css揭秘","slug":"front-end/css/css-reveal-secrets","date":"2018-12-10T00:04:00.000Z","updated":"2019-01-01T16:02:49.676Z","comments":true,"path":"2018/12/10/front-end/css/css-reveal-secrets/","link":"","permalink":"https://tragiclife.github.io/2018/12/10/front-end/css/css-reveal-secrets/","excerpt":"","text":"边框使用box-shadow制作假边框，第四个值为增大或者减小投影面积(box-shadow范围内不会触发事件)box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道 5px 的外框，那就需要指定扩张半径的值为15px （ 10px+5px ），会随着border-radius贴合border .box-shadow{display: inline-block;margin: 20px;width: 10px;height: 10px;-webkit-box-shadow: 0 0 0 10px red, 0 0 0 15px blue;box-shadow: 0 0 0 10px red, 0 0 0 15px blue;font-size: 12px;} 1234567&lt;div class=&quot;box-shadow&quot;&gt;&lt;/div&gt;.box-shadow&#123; width: 10px; height: 10px; box-shadow: 0 0 0 10px red, 0 0 0 15px blue;&#125; outline不触发事件，不随border-radius而贴合border .outline {margin: 10px;width: 10px;height: 10px;border: 5px solid red;outline: 5px solid blue;box-sizing: content-box;} 12345678&lt;div class=&quot;outline&quot;&gt;&lt;/div&gt;.outline &#123; width: 10px; height: 10px; border: 5px solid red; outline: 5px solid blue;&#125; background-origin通过backgroun-origin改变background-position的基准位置 reapting-linear-gradientlinear-gradient的扩展 利用linear-gradient实现网格 .linear-gradient {margin: 10px;width: 100px;height: 100px;background: white;background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%,transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0);background-size: 30px 30px;} 123456789&lt;div class=&quot;linear-gradient&quot;&gt;&lt;/div&gt;.linear-gradient &#123; width: 100px; height: 100px; background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px;&#125; 形状自适应的椭圆(元素为正方形时展示圆形)border-radius: 50% / 50%;可简写为border-radius: 50%; .circle {display: inline-block;margin: 10px;width: 50px;height: 50px;border-radius: 50%;background: blue;}.circle2 {width: 100px;} 123456789101112&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;&lt;div class=&quot;circle circle2&quot;&gt;&lt;/div&gt;.circle &#123; width: 50px; height: 50px; border-radius: 50%; background: blue;&#125;.circle2 &#123; width: 100px;&#125; 切角效果 .corner-cutting{display: inline-block;margin: 10px;width:100px; height: 100px;line-height: 100px;background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,linear-gradient(45deg, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;text-align: center;}.clip-path{clip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px);} background clip-path 12345678910111213.corner-cutting &#123; width: 100px; height: 100px; background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125;// 或者使用clip-pathclip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px); 制作单边倾斜的梯形 .trapezoid {margin: 10px;width: 50px;height: 50px;background: blue;transform: perspective(.5em) rotateX(5deg);transform-origin: bottom left;} 123456789&lt;div class=&quot;trapezoid&quot;&gt;&lt;/div&gt;.trapezoid &#123; width: 50px; height: 50px; background: blue; transform: perspective(.5em) rotateX(5deg); transform-origin: bottom left;&#125; 投影 .box-shadow {width: 50px;height: 50px;line-height: 50px;}.box-shadow1 {box-shadow: 0 5px 4px -4px black;}.box-shadow2 {box-shadow: 3px 3px 6px -3px black;}.box-shadow3 {box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black;} 单边投影邻边投影两侧投影 1234567891011121314151617181920&lt;div class=&quot;box-shadow box-shadow1&quot;&gt;单边投影&lt;/div&gt;&lt;div class=&quot;box-shadow box-shadow2&quot;&gt;邻边投影&lt;/div&gt;&lt;div class=&quot;box-shadow box-shadow3&quot;&gt;两侧投影&lt;/div&gt;.box-shadow &#123; width: 50px; height: 50px;&#125;// 单边投影.box-shadow1 &#123; box-shadow: 0 5px 4px -4px black;&#125;// 邻边投影.box-shadow2 &#123; box-shadow: 3px 3px 6px -3px black;&#125;// 两侧投影.box-shadow3 &#123; box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black;&#125; 滤镜 .filter {display: inline-block;margin: 10px;width: 50px;height: 50px;background: blue;}.filter-blur {filter: blur(5px);}.filter-grayscale {filter: grayscale();}.filter-drop-shadow {filter: drop-shadow(3px 3px 6px black)} 12345678910111213141516171819&lt;div class=&quot;filter&quot;&gt;&lt;/div&gt;.filter-blur &#123; width: 50px; height: 50px; background: blue;&#125;.filter-blur &#123; filter: blur(5px);&#125;.filter-grayscale &#123; filter: grayscale();&#125;.filter-drop-shadow &#123; filter: drop-shadow(3px 3px 6px black)&#125;filter: blur(5px) grayscale() drop-shadow(3px 3px 6px black)blur 元素模糊drop-shadow 类似于box-shadow 设置缩进1tab-size: 2; 空心字效果 .hollow-text {display: inline-block;margin-right: 10px;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black;}.hollow-text2 {text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black;} 空心字空心字 123456789&lt;div class=&quot;hollow-text&quot;&gt;空心字&lt;/div&gt;&lt;div class=&quot;hollow-text hollow-text2&quot;&gt;空心字&lt;/div&gt;.hollow-text &#123; text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black;&#125;.hollow-text2 &#123; text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black;&#125; 使用text-shadow实现文字模糊效果 .filter-text {color: black;text-shadow: 0 0 .1em black, 0 0 .3em black;} 文字模糊 123456&lt;div class=&quot;filter-text&quot;&gt;文字模糊&lt;/div&gt;.filter-text &#123; color: black; text-shadow: 0 0 .1em black, 0 0 .3em black;&#125; 利用svg实现环形文字效果 .circular{width: 50px;} circular reasoning works because 12345678&lt;div class=&quot;circular&quot;&gt; &lt;svg viewBox=&quot;0 0 100 100&quot;&gt; &lt;path d=&quot;M 0,50 a 50,50 0 1,1 0,1 z&quot; id=&quot;circle&quot; /&gt; &lt;text&gt; &lt;textPath xlink:href=&quot;#circle&quot;&gt;circular reasoning works because&lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/div&gt; 用户体验 使用合适的cursor 增大可点击范围123border: 10px solid transparent;background-clip: padding-box;需要边框时增加box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset; 水平居中行内元素：对其父元素设置text-align:center;块级元素：对其自身设置margin:0 auto; 实现水平垂直居中 通过position定位.position-container {position: relative;margin: 10px;width: 50px;height: 50px;background: red;}.position {position: absolute;top: 50%;left: 50%;width: 30px;height: 30px;background: blue;-webkit-transform: translate(-50%, -50%);transform: translate(-50%, -50%);} 123456789101112131415161718192021&lt;div class=&quot;position-container&quot;&gt; &lt;div class=&quot;position&quot;&gt;&lt;/div&gt;&lt;/div&gt;.position-container &#123; position: relative; width: 50px; height: 50px; background: red;&#125;.position &#123; position: absolute; top: 50%; left: 50%; width: 30px; height: 30px; background: blue; transform: translate(-50%, -50%);&#125;margin: 50% auto 0;transform: translateY(-50%);(只适用于全屏居中) 使用flex.flex-container {display: flex;margin: 10px;width: 50px;height: 50px;background: red;}.margin-item {margin: auto;width: 30px;height: 30px;background: blue;}.flex-container2 {justify-content: center;align-items: center;}.flex-item {width: 30px;height: 30px;background: blue;}marginflex 12345678910111213141516171819202122232425262728// 使用margin&lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;margin-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;.flex-container &#123; display: flex; width: 50px; height: 50px; background: red;&#125;.margin-item &#123; margin: auto; width: 30px; height: 30px; background: blue;&#125;// 使用伸缩盒属性.flex-container2 &#123; justify-content: center; align-items: center;&#125;.flex-item &#123; width: 30px; height: 30px; background: blue;&#125; 小球回弹动画@keyframes bounce {60%, 80%, to {transform: translateX(400px);animation-timing-function: ease;}70% { transform: translateX(300px); }90% { transform: translateX(360px); }}.ball {margin: 10px;width: 50px;height: 50px;background: blue;animation: bounce 3s cubic-bezier(.1,.25,1,.25) infinite;animation-direction: alternate;} 1234567891011121314151617&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateX(400px); animation-timing-function: ease; &#125; 70% &#123; transform: translateX(300px); &#125; 90% &#123; transform: translateX(360px); &#125;&#125;.ball &#123; width: 50px; height: 50px; background: blue; animation: bounce 3s cubic-bezier(.1,.25,1,.25) infinite; animation-direction: alternate;&#125; 利用steps对png背景做切换12animation: loader 1s infinite steps(8);@keyframes loader &#123;to &#123; background-position: -800px 0; &#125;&#125; 实现闪烁效果@keyframes twinkle {0% {backgroud: blue;}100% {background: transparent;}}.twinkle {margin: 10px;width: 50px;height: 50px;background: blue;animation: twinkle .5s linear infinite alternate;} 12345678910111213141516&lt;div class=&quot;twinkle&quot;&gt;&lt;/div&gt;@keyframes twinkle &#123; 0% &#123; backgroud: blue; &#125; 100% &#123; background: transparent; &#125;&#125;.twinkle &#123; width: 50px; height: 50px; background: blue; animation: twinkle .5s linear infinite alternate;&#125; 背景图片来回播放1234567891011@keyframes panoramic &#123;to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url(&quot;img/naxos-greece.jpg&quot;); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123; animation-play-state: running;&#125; 利用translate实现transform-origin的效果 .transform-container {margin: 50px;}.transform {width: 50px;height: 50px;background: blue;transform: rotate(30deg);transform-origin: 50px 100px;}.transform2 {transform: translate(50px, 100px) rotate(30deg) translate(-50px, -100px);transform-origin: 0 0;} 1234567891011121314151617181920&lt;div class=&quot;transform-container&quot;&gt; &lt;div class=&quot;transform&quot;&gt;&lt;/div&gt; &lt;div class=&quot;transform2&quot;&gt;&lt;/div&gt;&lt;/div&gt;.transform-container &#123; margin: 50px;&#125;.transform &#123; width: 50px; height: 50px; background: blue; transform: rotate(30deg); transform-origin: 50px 100px;&#125;// 效果同上.transform2 &#123; transform: translate(50px, 100px) rotate(30deg) translate(-50px, -100px); transform-origin: 0 0;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"日常小记-样式","slug":"front-end/css/daily-notes","date":"2018-12-09T00:12:08.000Z","updated":"2019-01-01T16:01:43.807Z","comments":true,"path":"2018/12/09/front-end/css/daily-notes/","link":"","permalink":"https://tragiclife.github.io/2018/12/09/front-end/css/daily-notes/","excerpt":"","text":"命名规范BEM(block element modifier) 常用的屏幕大小手机屏：&lt;768pad屏：≥768显示器：≥992大屏显示器：≥1200 禁止文本选中1user-select:none 链接的伪类 :link // 初始 :visited // 访问后 :hover // 鼠标悬停时 :active // 点击时 浮动问题子元素都为float，则父元素需要设置float才能被撑开 background属性的设置顺序bsckground:url() repeat attachment position/size origin clip 制作梯形1transform: perspective(20px) rotateX(-1deg ) rotateY(-2deg) translateZ(0) 实现模糊效果(支持IOS)1backdrop-filter:blur(10px); matrix(a,b,c,d,e,f) e和f相当于translate a和d相当于scale b和c相当于rotate 使滚动变流畅1-webkit-overflow-scrolling: touch; -webkit-overflow-scrolling产生的问题 滚动中scrollTop不会变化、不触发scroll事件，只在停下来的时候触发 手势可穿过其它元素触发元素滚动 滚动时暂停其它transition 有时会卡住不动，浏览器容器回弹停止后才可滑动 文本渐变123456789101112h2[data-text] &#123; position: relative;&#125;h2[data-text]::after &#123; content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));&#125; 黑白图片123img &#123; filter: grayscale(100%);&#125; 优化文本显示12345.text &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 文本模糊123.text&#123; text-shadow: 0 0 5px rgba(0, 0, 0, .5)&#125; 表格单元格等宽123.table &#123; table-layout: fixed;&#125; 多行省略号12345display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; 伸缩盒子元素的宽度没有超过父元素宽度或没有设置flex-wrap: wrap时，align-content不生效 GPU硬件加速1、设置will-change:transform进行硬件加速，还需要设置trsnsform:translateZ(0)进行hack2、transform: translate3d(0, 0, 0) 避免隐式合成保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。 动画优化 减少浏览器的重排和重绘的发生。 不要使用table布局。 css动画中尽量只使用transform和opacity，这不会发生重排和重绘。 尽可能地只使用css做动画。 避免浏览器的隐式合成。 改变复合层的尺寸。(使用小图片，通过scale放大) 使用锚点切换时平滑滚动1scroll-behavior: smooth 实现左右300px，中间自适应布局1、float(优：兼容性好；缺：需要清除浮动)2、position:absolute(优：布局快；缺：兄弟元素都需要脱离文档流处理，可使用性差)3、flex(比较完美)4、table、table-cell(易处理；其中一个单元格高度增长时，其余也会跟着增长)5、grid background的设置顺序background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; :last-child匹配父元素的最后一个元素 position:fixed宽高受父级元素影响问题如果父级元素使用了transform，则其position为fixed的子元素设置的宽高受父元素影响 touch-action 开发者文档 张鑫旭的博客 移动端设置cursor: pointer时，点击元素会有背景色123* &#123; -webkit-tap-highlight-color: transparent;&#125; 图片上下排列3px间隔的消除方法 给居上的图片加vertical-align: top 给居上的图片加display: block 设置font-size: 0 position static不拖出文档流 relative不拖出文档流 absolute拖出文档流 fixed拖出文档流 display和visibility12display: none; // 隐藏DOM，不占据空间visibility: hidden; // 隐藏DOM，占据空间 GPU硬件加速121. 设置will-change: transform，还需要设置transform: translateZ(0)进行hack2. transform: traslate3d(0, 0, 0) 硬件加速优化 设置动画元素的z-index高于其他元素 使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显 元素容器宽度固定，当元素超出容器时整个元素换行处理1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt;&lt;/div&gt;方法一.item &#123; display: inline-block;&#125;方法二.container &#123; display: flex;&#125; 其他 浏览器html默认字体大小为16px，设置font-size为62.5%后可换算为10px 只有块级元素或者行内块元素transform属性才回生效 display:inline-block的元素可以通过vertical-align:middle实现居中 50vh表示50%的设备高度，50vw表示50%的设备宽度 word-break：break-all;设置后火狐下的文字会比较对齐 文字要超过一行text-align:justify才会生效 resize属性可以设置文本框的拖动，其overflow需要设置为overflow/auto/scroll ie浏览器的option标签不可改变样式、不触发事件(由select触发) 伪对象after和before相当于内联元素 使用inline-block边距会多出4个像素，可通过font-size:0去除","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"屏幕适配","slug":"front-end/css/screen-adaptation","date":"2018-12-08T00:34:18.000Z","updated":"2019-01-01T15:43:41.458Z","comments":true,"path":"2018/12/08/front-end/css/screen-adaptation/","link":"","permalink":"https://tragiclife.github.io/2018/12/08/front-end/css/screen-adaptation/","excerpt":"","text":"常见移动web适配方法PC 960px/1000px居中 盒子模型，定高，定宽 display:inline-block 移动web: 定高，宽度百分比 flex Media Query(媒体查询) Media Query1234@media 媒体类型 and (媒体特性)如: @media screen and (max-width:320px)可在标签上引用&lt;link href=&quot;&quot; media=&quot;screen and (max-width:320px)&quot;/&gt; rem原理和简介 字体单位 值根据html根元素大小而定，同样可以作为宽度、高度等单位 适配原理将px替换成rem，动态修改html的font-size适配 兼容性IOS6以上、Android2.1以上 js动态修改font-size12345678910(function computedWidth()&#123; let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; let $html = document.querySelector(&apos;html&apos;); $html.style.fontSize = htmWidth / 3.75 + &apos;px&apos;; // iPhone6的手机尺寸 //屏幕宽度变化时 window.addEventListener(&apos;resize&apos;, computedWidth); //横竖屏切换时 window.addEventListener(&apos;orientationchange&apos;, computedWidth);&#125;)();","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"},{"name":"rem","slug":"rem","permalink":"https://tragiclife.github.io/tags/rem/"}]},{"title":"深入overflow","slug":"front-end/css/deep-into-overflow","date":"2018-12-07T22:28:51.000Z","updated":"2019-01-01T15:35:27.772Z","comments":true,"path":"2018/12/08/front-end/css/deep-into-overflow/","link":"","permalink":"https://tragiclife.github.io/2018/12/08/front-end/css/deep-into-overflow/","excerpt":"","text":"相关问题 overfloe-x、overflow-y(IE8+)如果overflow-x与overflow-y相同，则等同于overflow；如果两个设置不同，切其中一个设置为visible则visible会被重置为auto 表格元素无效，需要先设置table-layout:fixed overflow:auto时，chrome下能显示padding-bottom，而其他浏览器都不显示padding-bottom 作用 清除浮动影响overflow:hidden;_zoom:1; 避免margin穿透问题 两栏自适应布局 BFC属性12345678910111213// 自适应，但溢出不可见，限制了应用场景overflow:hidden// 包裹性+破坏性，无法自适应，块状浮动布局float+floatposition:absolute // 包裹性，无法自适应，IE6、7不识别display:inline-block// 包裹性，无溢出特性，绝对宽度也能自适应display:table-cell 文字溢出出省略号123456789101112// 单行省略width:100px;white-space:nowrap;text-overflow:ellipisis;overflow:hidden;// 多行省略号display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; 其他 无论什么浏览器，默认滚动条都来自html标签，而不是body标签 滚动条的宽度等于外部容器减去内部元素的clientWidth 获取滚动高度12chrome:document.body.scrollTop其他浏览器:document.documentElement.scrollTop 出现滚动条时，修复水平居中的元素跳动问题 设置html{overflow-y:scroll} container{padding-left:calc(100vw - 100%)}，既设置滚动条的宽度，适用于IE9+及其他浏览器 块级格式化上下文1overflow:auto/scroll/hidden 元素包裹问题元素的父元素没有设置position:absolute/relative/fixed时，父元素的overflow无法包裹住position:absolute的子元素1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;.container &#123; position: relative; overflow: hidden;&#125;.item &#123; position: absolute;&#125; overflow失效妙用123456// 父元素height:0;overflow:hidden;text-align:right;// 子元素position:absolute 锚点定位 锚点定位的触发 url地址中的锚链与锚点元素 可focus的锚点元素处于focus态","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入float","slug":"front-end/css/deep-into-float","date":"2018-12-06T21:39:30.000Z","updated":"2019-01-01T14:57:31.188Z","comments":true,"path":"2018/12/07/front-end/css/deep-into-float/","link":"","permalink":"https://tragiclife.github.io/2018/12/07/front-end/css/deep-into-float/","excerpt":"","text":"设置初衷为了文字的环绕float元素会产生BFC(块级格式化上下文，block formatting context) 特性包裹具有包裹性的相关属性123display:inline-block/table-cellposition:absolute/fixed/stickyoverflow:hidden/scroll 破坏(父元素塌陷)具有破坏性的相关属性12display:noneposition:absolute/fixed/sticky 能形成BFC的样式12345float:left/rightposition:absolute/fixedoverflow:hidden/scroll(IE7+)display:inline-block/table-cell(IE8+)width/height/zoom:1...(IE6/IE7) 清除浮动(较佳使用)123456789.clearfix:after&#123; content:&apos;&apos;; display:table; clear:both;&#125;.clesrfix&#123; *zoom:1; //IE6、7&#125;应用于包含浮动元素的父元素上 浮动与两侧皆适应的流体布局1234display:table-cell;*display:inline-block;width:2000px;*width:auto","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入border","slug":"front-end/css/deep-into-border","date":"2018-12-05T23:16:00.000Z","updated":"2019-01-01T15:28:48.172Z","comments":true,"path":"2018/12/06/front-end/css/deep-into-border/","link":"","permalink":"https://tragiclife.github.io/2018/12/06/front-end/css/deep-into-border/","excerpt":"","text":"特性 border-style为dashed时，不同浏览器下实线和空白区域的比例不同 border-style为dotted时，形状不同 当border-color没有指定颜色时，默认使用color作为边框颜色，类似的还有box-shadow,text-shadow,outline 应用场景让背景图固定距离右侧50px12border-right:50px solid transparent;background-position:100% 40px ; 实现三角形.triangle {margin-bottom: 10px;width: 0;height: 0;border: 25px solid transparent;border-bottom-color: blue;} 12345678&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;.triangle &#123; width: 50px; height: 50px; border: 25px solid transparent; border-bottom-color: blue;&#125; 实现梯形.trapezoid {margin-bottom: 10px;width: 70px;height: 0;border: 25px solid transparent;border-bottom-color: blue;} 12345678&lt;div class=&quot;trapezoid&quot;&gt;&lt;/div&gt;.trapezoid &#123; width: 50px; height: 50px; border: 25px solid transparent; border-bottom-color: blue;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入padding","slug":"front-end/css/deep-into-padding","date":"2018-12-04T21:37:28.000Z","updated":"2019-01-01T15:26:48.635Z","comments":true,"path":"2018/12/05/front-end/css/deep-into-padding/","link":"","permalink":"https://tragiclife.github.io/2018/12/05/front-end/css/deep-into-padding/","excerpt":"","text":"padding是否生效对于block水平元素 padding值过大，一定会影响尺寸 width非auto，padding一定影响尺寸 width为auto或box-sizing为border-box，同时padding值没有过大，不影响尺寸 对于inline水平元素水平padding影响尺寸，垂直padding不影响尺寸，但是会影响背景色(占据空间) 支持的属性值 不支持负值 百分比根据宽度计算(如果设置50%则为一个正方形) inline元素的padding：同样相对于宽度计算，默认的宽度高度细节有差异，padding会断行 应用场景实现border与内容区域之间空白的效果.clip-container {margin: 10px;padding: 10px;width: 50px;height: 50px;border: 10px solid red;background-color: blue;background-clip: content-box;} 1234567891011&lt;div class=&quot;clip-container&quot;&gt;&lt;/div&gt;// 利用background-clip实现.clip-container &#123; padding: 10px; width: 50px; height: 50px; border: 10px solid red; background-color: blue; background-clip: content-box;&#125; 如何得到一个正方形.square-container{margin: 10px;width: 50px;height: 50px;}.square {width: 100%;padding-top: 100%;background-color: blue;} 12345678910111213&lt;div class=&quot;square-container&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;&lt;/div&gt;.square-container&#123; width: 50px; height: 50px;&#125;.square &#123; width: 100%; padding-top: 100%; background-color: blue;&#125; 其他 inline元素的垂直padding会让让空白节点显现，既规范中的strut，可以通过font-size:0去除 ol/ul标签内置padding-left是以px为单位的，如果字号很小，间距就会很开；如果字号很大，就会跑到容器外面 在firefox下设置button的padding为0时依然有padding值，通过设置button::-moz-focus-inner{padding:0}。 IE7下文字越多，button的padding值越大，通过设置button{overflow:visiable;}去除。 可访问性隐藏：将元素设置absolute，定位到看不见的地方，或者设置z-index:-1隐藏在背景之下。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入margin","slug":"front-end/css/deep-into-margin","date":"2018-12-03T22:42:01.000Z","updated":"2019-01-01T15:09:01.337Z","comments":true,"path":"2018/12/04/front-end/css/deep-into-margin/","link":"","permalink":"https://tragiclife.github.io/2018/12/04/front-end/css/deep-into-margin/","excerpt":"","text":"什么是margin设置元素的外边距，允许使用负值，适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 设置方式1234567891011// 设置一个值，相当于四个方向的外边距都为10pxmargin: 10px;// 设置两个值，相当于设置上下、左右的外边距，即上下为10px，左右为5pxmargin: 10px 5px;// 设置三个值，相当于设置上、左右、下的外边距，即上为10px，左右为5px，下为1pxmargin: 10px 5px 1px;// 设置四个值，相当于设置上、右、下、左的外边距，即上为10px，右为5px，下为2px，左为1pxmargin: 10px 5px 2px 1px; 特性 可以改变元素尺寸 适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 如何计算普通元素的百分比margin都是相对于容器的宽度计算的绝对定位元素的百分比margin是相对于第一个定位祖先元素（relative、absolute、fixed）的宽度计算的。 margin重叠margin重叠特性只对block元素(除float和absolute)起作用，只发生在垂直方向上(writing-mode设置可变为水平方向) 重叠的三种情景 相邻的兄弟元素 父级元素和第一个或最后一个子元素 空的block元素正正取大值，正负值相加，负负最负值 实现水平垂直居中12345678// 元素宽高固定position:absolute;top: 50%;left: 50%;margin-top: -50px;margin-left: -100px;width: 100px;height: 200px; 负值的应用场景1234567891011121314// margin负值下的两端对齐ul &#123; margin-right:-20px;&#125;li &#123; margin-right:20px;&#125;// margin负值下的等高布局div &#123; margin-bottom:-600px; padding-bottom:600px;&#125;// margin负值下的两栏自适应布局 margin失效情形 inline水平元素的垂直margin无效 margin重叠 display:table-cell等 position:absolute;当其父元素设置为relative时会生效 前一个元素float以后，后一个元素的margin-left要大于前一个元素的宽度时才会生效 内联特性导致无效 新属性值123456789101112// (一开始相当于margin-left):文档流开始的方向leftmargin-start// 相当于margin-topmargin-before// 相当于margin-bottommargin-after// 重叠效果margin-collapse可选值：collapse(默认重叠) | discard(取消margin效果) | separate(不重叠)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]}]}