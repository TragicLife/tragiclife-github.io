{"meta":{"title":"薛鸿杰的博客","subtitle":null,"description":null,"author":"薛鸿杰","url":"https://tragiclife.github.io"},"pages":[{"title":"","date":"2018-12-05T14:13:25.229Z","updated":"2018-12-05T14:13:25.229Z","comments":false,"path":"categories/index.html","permalink":"https://tragiclife.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-02T07:00:58.836Z","updated":"2018-12-02T07:00:58.836Z","comments":false,"path":"tags/index.html","permalink":"https://tragiclife.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"移动端屏幕像素","slug":"front-end/other/mobile-screen-pixels","date":"2018-12-13T23:12:06.000Z","updated":"2018-12-13T16:12:22.022Z","comments":true,"path":"2018/12/14/front-end/other/mobile-screen-pixels/","link":"","permalink":"https://tragiclife.github.io/2018/12/14/front-end/other/mobile-screen-pixels/","excerpt":"","text":"Pixel 移动开发像素知识px: css pixels 逻辑像素，浏览器使用的抽象单位dp,pt: device independent pixels 设备无关像素dpr: devicePixelRatio 设备像素缩放比 计算公式：1px = (dpr)² * dp DPI: 打印机每英寸可以喷的墨汁点(印刷行业)PPI: 屏幕每英寸的像素数量，即单位英寸内的像素密度 计算公式：以iPhone5为例子ppi = √ (1136² + 640²) / 4 = 326ppi (视网膜Retina屏) ldpi mdpi hdpi xhdpi ppi 120 160 240 320 默认缩放比 0.75 1.0 1.5 2.0 Retina屏(高清屏): dpr都是大于等于2 PPI越高，像素数越高，图像越清晰但可视度越低(小)，系统默认设置缩放比越大 Viewport手机浏览器默认为我们做两件事页面渲染在980px(ios)的viewport(为了排版正确)缩放(排版正确后，再缩放到手机屏幕大小) //这就是网页在手机上，会全屏显示的原因 visual viewport：度量/视口viewport宽高visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。// 无法改变，通过缩放scale控制layout viewport: 布局viewport 如图，ios的默认layout viewport为980px// 可以理解为就是body的宽度，在此之上渲染页面 为什么不适用默认的980px的布局viewport(layout viewport)宽度不可控制，不同系统不同设备的默认值都可能不同页面先在layout viewport全屏渲染css,再通过缩放由visual viewport展示，交互不友好链接不可点有缩放，缩放后又有滚动font-size:40px=PC的12px,不规范，字体设置是另外一门学问了。 meta标签 width: 设置布局viewport的特定值(device-width)initial-scale: 设置页面的初始缩放minimum-scale: 最小缩放maximum-scale: 最大缩放user-scalable: 用户能否缩放最常用写法 方案一：根据设备的实际宽度来设计(常用)手机宽320px，拿320px设计方案二：1px=1dp缩放0.5。根据设备的物理像素dp等于抽象像素px来设计。1像素边框和高清图片都不需要额外处理。 响应式设计媒体类型：screen(屏幕)print(打印机)handheld(手持设备)all(通用)常用媒体查询参数：width(视口宽度)height(视口高度)device-width(设备宽度)device-height(设备高度)orientation(检查设备处于横向(landscape)还是竖屏(portrait)) 移动web页面上的click事件响应都要慢上300ms使用tap事件代替click事件 自定义tap事件原理：在touchstart、touchend时记录时间、手指位置，在touchend时进行比较，如果手指位置为同一位置(或允许移动一个非常小的位移值)且时间间隔较短(一般认为是200ms)，且过程中未曾触发过touchmove，即可认为出发了手持设备上的”click”，一般称它为”tap” tap透传的解决方案使用缓动动画，过渡300ms的延迟中间层dom元素的加入，让中间层接受这个“穿透”事件，稍后隐藏“上下”都使用tap事件，原理上解决tap透传事件(但不可避免原生标签的click事件)改用Fastclick的库 触摸事件touchstart: 手指触摸屏幕触发(已经有手指放屏幕上不会触发)touchmove: 手指在屏幕华东，连续触发touchend: 手指离开屏幕时触发touchcancel: 系统取消touch时候触发(不常用) 触摸属性touches: 跟踪触摸操作的touch对象数组targetTouches: 特定事件目标的touch对象数组changeTouches: 上次触摸改变的touch对象数组 每个touch对象包含属性:clientX: 触摸目标在视口中的x坐标clientY: 触摸目标在视口中的y坐标identifier: 标识触摸的唯一IDpageX: 触摸目标在页面中的x坐标(包含滚动)pageY: 触摸目标在页面中的y坐标(包含滚动)screenX: 触摸目标在屏幕中的x坐标screenY: 触摸目标在屏幕中的y坐标target: 触摸目标的DOM节点 弹性滚动body层滚动(系统特殊化处理):自带弹性滚动，overflow: hidden失效，GIF和定时器暂停局部滚动:没有弹性滚动，没有惯性滚动，不流畅局部滚动开启弹性滚动(仅支持IOS)-webkit-overflow-scrolling: touch;上拉加载使用scroll事件，而不是touch事件(因为android中会有bug) -webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug在使用该属性的元素上不设置定位或者手动设置定位为static在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。 -webkit-overflow-scrolling:touch还会导致的bug滚动中 scrollTop 属性不会变化手势可穿过其他元素触发元素滚动滚动时暂停其他 transition","categories":[],"tags":[]},{"title":"面试记录","slug":"front-end/other/interview-record","date":"2018-12-12T22:23:55.000Z","updated":"2018-12-13T15:12:52.774Z","comments":true,"path":"2018/12/13/front-end/other/interview-record/","link":"","permalink":"https://tragiclife.github.io/2018/12/13/front-end/other/interview-record/","excerpt":"","text":"记录一个页面上两个div左右铺满整个浏览器，要保证左边的div一直为100px，右边的div跟随浏览器大小变化（比如浏览器为500，右边div为400，浏览器为900，右边div为800），请写出大概的css代码。 使用flex 12345678910111213141516171819202122//html&lt;div class=&apos;box&apos;&gt;&lt;div class=&apos;left&apos;&gt;&lt;/div&gt; &lt;div class=&apos;right&apos;&gt;&lt;/div&gt;&lt;/div&gt;//css.box &#123; width: 400px; height: 100px; display: flex; flex-direction: row; align-items: center; border: 1px solid #c3c3c3;&#125;.left &#123; flex-basis：100px; -webkit-flex-basis: 100px; /* Safari 6.1+ */ background-color: red; height: 100%;&#125;.right &#123; background-color: blue; flex-grow: 1;&#125; 浮动布局 123456789101112131415161718&lt;div id=&quot;left&quot;&gt;Left sidebar&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;Main Content&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;#left &#123; float: left; width: 220px; background-color: green;&#125;#content &#123; background-color: orange; margin-left: 220px; /*==等于左边栏宽度==*/&#125;&lt;/style&gt; 请写出一些前端性能优化的方式，越多越好 减少dom操作 部署前，图片压缩，代码压缩 优化js代码结构，减少冗余代码 减少http请求，合理设置 HTTP缓存 使用内容分发cdn加速 静态资源缓存 图片延迟加载 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器查找域名的 IP 地址 这一步包括 DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从http://example.com到http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求 请大概描述下页面访问cookie的限制条件 跨域问题 设置了HttpOnly 描述浏览器重绘和回流，哪些方法能够改善由于dom操作产生的回流 直接改变className，如果动态改变样式，则使用cssText 1234567891011// 不好的写法var left = 1;var top = 1;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;; // 比较好的写法el.className += &quot; className1&quot;;// 比较好的写法el.style.cssText += &quot;;left: &quot; + left + &quot;px;top: &quot; + top + &quot;px;&quot;; 让要操作的元素进行”离线处理”，处理完后一起更新 123a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；b) 使用display:none技术，只引发两次回流和重绘；c) 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘 vue生命周期钩子 beforcreate created beformount mounted beforeUpdate updated actived deatived beforeDestroy destroyed js跨域请求的方式，能写几种是几种 通过jsonp跨域 通过修改document.domain来跨子域 使用window.name来进行跨域 使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持） CORS 需要服务器设置header ：Access-Control-Allow-Origin。 nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求 对前端工程化的理解 开发规范 模块化开发 组件化开发 组件仓库 性能优化 项目部署 开发流程 开发工具 js深度复制的方式 使用jq的$.extend(true, target, obj) newobj = Object.create(sourceObj)，// 但是这个是有个问题就是newobj的更改不会影响到 sourceobj但是 sourceobj的更改会影响到newObj newobj = JSON.parse(JSON.stringify(sourceObj)) js设计模式: 总体来说设计模式分为三大类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式 图片预览123456789101112&lt;input type=&quot;file&quot; name=&quot;file&quot; onchange=&quot;showPreview(this)&quot; /&gt;&lt;img id=&quot;portrait&quot; src=&quot;&quot; width=&quot;70&quot; height=&quot;75&quot;&gt;function showPreview(source) &#123; var file = source.files[0]; if(window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function(e) &#123; document.getElementById(&quot;portrait&quot;).src = e.target.result; &#125;; fr.readAsDataURL(file); &#125;&#125; 扁平化多维数组 老方法 123456789101112var result = []function unfold(arr)&#123; for(var i=0;i&lt; arr.length;i++)&#123; if(typeof arr[i]==&quot;object&quot; &amp;&amp; arr[i].length&gt;1) &#123; unfold(arr[i]); &#125; else &#123; result.push(arr[i]); &#125; &#125;&#125;var arr = [1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];unfold(arr) 使用tostring 12var c=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];var b = c.toString().split(&apos;,&apos;) 使用es6的reduce函数 123var arr=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];const flatten = arr =&gt; arr.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);var result = flatten(arr) iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 数组乱序 方法一 123456789function shuffle(a) &#123; var len = a.length; for (var i = 0; i &lt; len - 1; i++) &#123; var index = parseInt(Math.random() * (len - i)); var temp = a[index]; a[index] = a[len - i - 1]; a[len - i - 1] = temp; &#125;&#125; 方法二 12345function shuffle(arr)&#123; return arr.sort(() =&gt; &#123; return Math.random() &gt; 0.5 ? -1:1 &#125;)&#125; new Function的写法1var message = new Function(&apos;msg&apos;,&apos;alert(msg)&apos;); 原型链顶层 Object.prototype 代码题12345678910var test = (function(a)&#123; this.a = a * 2; // 立即执行函数的this指向window return function(b)&#123; return this.a + b; &#125;&#125;)((function(a)&#123; return a&#125;)(1,2))console.log(test(4)) // 6 明源云状态码及其表达的意思 200 请求成功 204 请求成功，但没有返回响应实体 401 当前请求需要用户验证 403 禁止访问 404 资源未找到 408 请求超时 500 后台程序错误 防止代码提交冲突的方案 axios发起请求会有两个的原理，axios跨域处理OPTIONS是预请求，判断其是否能支持跨域 vuex原理 svn和git的区别 使用ES5或者ES6实现单例模式 ES5 1234567891011121314var Single = function(name)&#123; this.name = name; // 一个标记，用来判断是否已经创建了该类的实例 this.instance = null;&#125;// 提供了一个静态方法，用户可以直接在类上调用Single.getInstance = function(name)&#123; // 没有实例化的时候创建一个该类的实例 if (!this.instance) &#123; this.instance = new Single(name) &#125; // 已经实例化了，返回第一次实例化对象的引用 return this.instance;&#125; ES6 12345678910111213class Single &#123; constructor(name) &#123; this.name = name; this.instance = null; &#125; // 构造一个广为人知的接口，供用户对该类进行实例化 static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Single(name); &#125; return this.instance; &#125;&#125; 代码题1234567891011var test = function(a, b)&#123; alert(b); return &#123; test: function(c)&#123; return test(c, a) &#125; &#125;&#125;var a = test(100);a.test(201);a.test(301); // undefined 100 100var a = test(101).test(201).test(301); // undefined 101 201var a = test(103).test(203);a.test(303); // undefined 103 203 Promise链式调用其中一个报错，如何让其继续运行在catch中捕获错误 AMD和CMD的异同 相同点 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 不同点 定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。 遵循的规范不同。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。 推广理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。 对开发调试的支持有差异。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。 插件机制不同。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。 1234567891011121314CMD 推崇依赖就近，AMD 推崇依赖前置。//CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() &#125;)// AMD 默认推荐的是define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;// 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething()&#125;) 如何使脱离文档流的元素回到文档流 旺合盛世rem和百分比的优缺点 iframe的优缺点优点 iframe能够原封不动的把嵌入的网页展现出来 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。5.重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度) 缺点 页面样式调试麻烦，出现多个滚动条； 浏览器的后退按钮失效； 过多会增加服务器的HTTP请求； 小型的移动设备无法完全显示框架； 产生多个页面，不易管理； 不容易打印； 代码复杂，无法被一些搜索引擎解读。 星斯达什么是MVC，MVC的框架又哪些 如何通过正则匹配协议12location.href.match(/(\\w*):\\/\\//)[&quot;https://&quot;, &quot;https&quot;, index: 0, input: &quot;https://www.bilibili.com/video/av11314749/&quot;,length: 2] js实现二分树 智游人vue-router中history和hash模式有什么区别hash模式的话路由地址会带上#，但是浏览器发送给服务端的却实#之前的URL，hash模式的好处是，虽然你是个单页面应用，但你可以刷新当前页。history的话需要服务端配合，如果服务端配置仅仅是找不到路由，就重定向到index.html，那么刷新会跳首页，如果服务端对于匹配不到URL不做配置，那么一般返回404页面 样式优先级important &gt; 内联样式 &gt; id选择器 &gt; 类选择器、伪类选择器(:hover)、属性选择器 &gt; 伪元素选择器(::before)、标签选择器 冒泡排序123456789101112function arrSort (arr) &#123; var i, j, tmp, len = arr.length - 1; for(i = 0; i&lt; len; i++) &#123; for(j = 0; j &lt; len - i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; // 升序 tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125;&#125; 仙人掌原型和原型链 开拍网DOM操作方法parent.appendChild(child) 增加子元素parent.removeChild(child) 删除子元素parent.replaceChild(new, old) 替换子元素parent.insertBefore(new, existsDOM) 向已有子节点添加元素element.nextSibling 返回元素相邻的下一个元素element.previousSibling 返回元素相邻的上一个元素","categories":[],"tags":[]},{"title":"项目中遇到的问题","slug":"front-end/other/problems-encountered-in-the-project","date":"2018-12-12T22:03:31.000Z","updated":"2018-12-13T15:12:52.774Z","comments":true,"path":"2018/12/13/front-end/other/problems-encountered-in-the-project/","link":"","permalink":"https://tragiclife.github.io/2018/12/13/front-end/other/problems-encountered-in-the-project/","excerpt":"","text":"vue界面渲染时出现花括号{}123456在挂载vue的标签上使用v-cloak，设置v-cloak属性的样式，vue渲染完后会自动移除该属性&lt;div class=&quot;app&quot; v-cloak&gt;&lt;/div&gt;[v-cloak]&#123; display: none;&#125; 使用:style或:class绑定时，key名带中划线(-)问题1用引号将该key包裹起来，:style=&#123;&apos;background-color&apos;: &apos;#fff&apos;&#125; 错误捕获 2.2.0+可用, 2.4.0+支持自定义事件的捕获123456789101112Vue.config.errorHandler捕获钩子函数的报错信息，只能捕获钩子函数的错Vue.config.errorHandler = (err, vm, info) =&gt; &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // info 是 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 使用ref绑定问题 如果绑定的元素为遍历元素，则生成的refs为数组 vue-router在history模式下使用子路由刷新报错问题 修改assetsPublicPath路径，使用绝对路径 style标签使用scoped的时候无法覆盖子组件样式1234解决方法:1. 去掉scoped2. 混用本地和全局样式，即增加一个style标签，不写scoped，进行样式覆3. 使用深度选择器 /deep/或者&gt;&gt;&gt;，如.a /dep/ .b&#123;&#125; 进入详情页要缓存，从首页进入时要刷新的处理方法1234567891011121314151617181920212223242526使用keep-alive，在router中定义keeyAlive，在App.vue中&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;js代码：watch: &#123; $route: &#123; handler(to, from) &#123; if (to.name === &apos;Home&apos;) &#123; this.$refs.customerList.clearStatus(); from.meta.reload = true; &#125; &#125; &#125;&#125;,created() &#123; this.loadData();&#125;,activated() &#123; if (this.$route.meta.reload) &#123; this.loadData(); this.$route.meta.reload = false; &#125;&#125; style标签使用scss的@import相对路径问题1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;], alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;src&apos;), &#125;&#125;引用时，@import &apos;~@/scss/icon.scss&apos;; Duplicate presence of slot “titleName” found in the same render tree1234使用具名插槽slot-scope&lt;template slot=&quot;titleName&quot; slot-scope=&quot;props&quot;&gt; &lt;span class=&quot;order-title&quot;&gt;采购订单&lt;/span&gt;&lt;/template&gt; IOS日期转换问题12日期中不允许有-，需要replace(/-/g, &apos;/&apos;)才可以进行new Date()日期中不允许有.0，如(2018-09-06 00:00:00.0)，需要replace(/\\..*/g,&apos;&apos;)替换处理 滚动暂停问题121. 将滚动容器从body改为app，设置-webkit-overflow-scrolling:touch，该属性会造成scroll事件只会在滚动停止的时候执行一次2. 使用滚动插件(如better-scroll) IOS7伸缩盒兼容性问题 使用伸缩盒时加webkit前缀，使用box IOS9元素运行动画后不显示问题121. z-index没有设置或者太小2. 没有设置animation-fill-mode: forwards animation-play-state失效问题1234567添加父容器，在暂停的时候给父容器加transformlet container = this.$refs.musicContainerlet musicT = getComputedStyle(this.$refs.music).transformlet containerT = getComputedStyle(container).transformlet transform = containerT === &apos;none&apos; ? musicT : musicT.concat(&apos; &apos;, containerT)container.style.transform = transformcontainer.style.webkitTransform = transform 使用-webkit-overflow-scrolling:touch问题 如果触发了外层容器的弹性滚动，则该元素短时间内会无法滚动，可以使用better-scroll来实现滚动 Android打开view时界面会有空白问题 在mounted中使用setTimeout进行font-size的设置 Android4.3中设置background的大小不生效 通过background-size设置 4.3版本的svg无法使用transform 用div将svg包裹起来，设置div的transform 兼容低版本css 带webkit的css要放在后面 Android4系统touchmove问题 在touchmove的时候会执行touchcancel事件，导致touchmove只执行一次，需要使用e.preventDefault阻止默认事件才可以执行多次，但是会导致一些默认行为不触发，如scroll click事件失效问题 父元素的touch事件加了preventDefault导致子元素的click事件不触发，修改子元素的click事件为touch事件 动画由大变小闪动问题123给动画元素的父容器加position: relative;overflow: hidden; 插件new Swiper的问题 在元素隐藏的时候new Swiper，Swiper会有错位问题1234561. 设置obserVer和observParents为true new Swiper(this.$refs.swiperContainer, &#123; observer: true,//修改swiper自己或子元素时，自动初始化swiper observeParents: false,//修改swiper的父元素时，自动初始化swiper &#125;);2. 显示的时候手动调用update方法 better-scroll内的子元素无法通过overflow滚动 better-scroll的bug svg使用animate时，animate动画不运行 121. 获取animate的DOM，调用beginElement方法执行动画2. animate的dur设置的时间太小(小于25ms)，动画不会执行 JScanvas绘制问题 绘制前需要设置canvas的宽高 工具使用webstorm时无法自动编译问题 取消webstorm的自动保存功能 http401状态码 登录token有问题 好车主APP某些机型打开健步行时白屏问题 绘制圆环canvas的时候没有获取到DOM导致webview奔溃，在$nextTick的时候绘制canvas，后面改成了SVG aopsId获取失败 连续调用了相同的客户端方法，导致前面的被覆盖 安卓手机音频无法自动播放 通过touch事件手动触发播放 监听APP前后台切换 通过postEvent方法监听webview的切换 因为手机设置字体大小导致样式错位问题 安卓客户端通过webview配置webview.getSettings().setTextZoom(100)就可以禁止缩放，按照百分百显示。 微信/企业微信微信端无法自动播放音频问题 方法一 使用微信提供的js-sdk，在ready中调用播放的API1234567891011121314151617//首先引用js: &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt;//然后写方法: function autoPlayAudio1()&#123; wx.config(&#123; //配置信息, 即使不正确也能使用 wx.ready debug: false, appId: &apos;&apos;, timestamp: 1, nonceStr: &apos;&apos;, signature: &apos;&apos;, jsApiList: [] &#125;); wx.ready(function() &#123; document.getElementById(&apos;audio&apos;).play(); &#125;);&#125; 方法二1234var audio=document.querySelector(&quot;#audio&quot;); document.addEventListener(&quot;WeixinJSBridgeReady&quot;,function()&#123; audio.play();&#125;, false); 隐藏分享栏 1WeixinJSBridge.call(&apos;hideOptionMenu&apos;) 企业微信注册报invalid signture 在home界面调用注册方法会报错，修改调用的位置至需要使用新建表单页面 后台返回的时间戳单位需要为秒，注册的url需要encodeURIComponent再传给后台，由后台decode 项目用的是history模式，每个页面使用sdk都需要重新调用注册方法 url不调用encodeURIComponent的话链接上通过&amp;字符连接起来的参数会不被加入签名中 安卓手机无法预览图片12345调用接口时，urls必须传wx.previewImage(&#123; current: imgUrl, // 当前显示图片的http链接 urls: [imgUrl] // 需要预览的图片http链接列表&#125;);","categories":[],"tags":[]},{"title":"日常小记-JS","slug":"front-end/js/daily-notes","date":"2018-12-11T23:59:39.000Z","updated":"2018-12-11T16:00:21.562Z","comments":true,"path":"2018/12/12/front-end/js/daily-notes/","link":"","permalink":"https://tragiclife.github.io/2018/12/12/front-end/js/daily-notes/","excerpt":"","text":"HTML生成语法 emmet 渲染机制 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 视频播放自动全屏问题 设置playsinline=”true”、webkit-playsinline=”true”、x5-playsinline=”true”、x-webkit-airplay=”allow” 修改浏览器页签图标 dns获取1&lt;link href=&quot;https://a.alipayobjects.com&quot; rel=&quot;dns-prefetch&quot;/&gt; CSSposition static不拖出文档流 relative不拖出文档流 absolute拖出文档流 fixed拖出文档流 伪对象after和before相当于内联元素 display和visibility12display: none; // 隐藏DOM，不占据空间visibility: hidden; // 隐藏DOM，占据空间 GPU硬件加速121. 设置will-change: transform，还需要设置transform: translateZ(0)进行hack2. transform: traslate3d(0, 0, 0) 硬件加速优化 设置动画元素的z-index高于其他元素 使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显 元素容器宽度固定，当元素超出容器时整个元素换行处理1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt;&lt;/div&gt;方法一.item &#123; display: inline-block;&#125;方法二.container &#123; display: flex;&#125; JS$(“p”).empty与$(“p”).remove1234$(&quot;p&quot;).empty移除p标签中的文本及其子节点，留下p标签$(&quot;p&quot;).remove移除p标签及其文本内容还有其子节点 事件绑定12345678910111213DOM2级事件addEventListener(type, listener, useCapture/options);removeEventListener(type, listener, useCapture/options);useCapture: 默认为false，监听冒泡阶段options: &#123; capture: Boolean, // 是否在捕获阶段触发事件 passive: Boolean, // 使preventDefault调用无效，可优化界面滚动效果 once: Boolean, // 是否执行一次&#125;IEattachEvent(&apos;on&apos; + type, listener);detachEvent(&apos;on&apos; + type, listener); 消除事件处理器的影响 图解浏览器的工作原理 123456789101112131415161718让浏览器即监听相关事件，又让组合器线程在等等主线程响应前构建新的组合帧document.body.addEventListener(&apos;touchstart&apos;, event =&gt; &#123; if (event.target === area) &#123; event.preventDefault() &#125;&#125;, &#123;passive: true&#125;);垂直方向的滚动可能会先于event.preventDefault()发生，此时可以通过 event.cancelable 来防止这种情况document.body.addEventListener(&apos;pointermove&apos;, event =&gt; &#123; if (event.cancelable) &#123; event.preventDefault(); // block the native scroll &#125; &#125;, &#123;passive: true&#125;);也可以使用 css 属性 touch-action 来完全消除事件处理器的影响，如：#area &#123; touch-action: pan-x; &#125; 表示false的值 false, 0, 空字符串(‘’), null, undefined Number,Boolean,String,Undefined比较问题 会先将复合对象转换成基本类型（依次调用valueOf和toString方法）再进行比较，undefined被当成基本类型，undefined转换成数字是NaN，因此undefined与除null之外的其它类型值进行比较时始终返回false（注意NaN==NaN返回false）null被当成复合对象，由于null没有valueOf和toStribg方法，因此除了和undefined之外的其它类型值进行比较时始终返回false 设置prototype的值为对象时，首先要还原构造器1234let Person = function()&#123;&#125;Person.prototype = &#123; constructor: Person&#125; 复制内容到粘贴板(仅支持IE)12let text = document.querySelector(&apos;.text&apos;).innerText;window.clipboardData.setData(&apos;text&apos;, text); []和new Array []的运行速度比new Array快，后者需要调用构造器 mouseout、mouseleave12mouseout: 无论鼠标离开被选元素(绑定事件的元素)还是其子元素都会触发mouseleave: 当鼠标离开被选元素时触发 获取选中select标签的文本12// value和选择文本不同时，sel为select标签的dom元素sel.options[sel.selectedIndex].text hover事件 相当于mouseenter+mouseleave，不相当于mouseover+mouseout，mouseover(mouseout)鼠标进入(离开)某个元素或其子元素时触发。 javascript:void(0) javascript是伪协议，表示url的内容通过javascript执行。void(0)表示不做任何操作，这样会防止链接跳转到其他界面。这么做可以保存链接的样式，但不让链接执行实际操作，具体的操作交给链接的onclick事件处理 函数声明12函数声明：function fn()&#123;&#125;函数表达式：var fn = function()&#123;&#125; 将伪数组转换成数组 Array.prototype.slice.call(arguments, 0); 操作class12345classList.value 获取所有类名classList.add() 添加类classList.remove() 移除类classList.contains() 查看是否存在某个类classList.toggle() 切换是否显示某个类 获取对象类型12345678Object.prototype.toString.call(xx); // 结果为[object Type]// 判断是否为数组if(typeof Array.isArray===&apos;undefined&apos;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&apos;[object Array]&apos; &#125;; &#125; 判断是否为undefined12345let a;undefined = 1; // 这样判断就会出错a === undefined; // undefined不是保留字，能被赋值a === void 0; // void后面随便跟上一个组成表达式，返回就是undefined bind、call、apply的区别 bind只改变上下文环境，不执行 call第二个参数开始是参数列表 allpy第二个参数是数组 获取元素样式1getComputedStyle(dom, 伪类); // 可以获取伪类样式 判断图片是否加载完成1231. onload2. 通过img.complete属性判断3. onreadystatechange，img.readyState为complete或者loaded为加载完成 setTimeout(fn, time, param) fn: 回调函数 time: 延迟调用时间 param: 传入回调的参数 获取transform后元素的宽高1dom.getBoundingClientRect() 语法简写123456789101112131415161718192021222324252627//取整parseInt(a,10); //BeforeMath.floor(a); //Beforea&gt;&gt;0; //Before~~a; //Aftera|0; //After//四舍五入Math.round(a); //Beforea+.5|0; //After//内置值undefined; //Beforevoid 0; //After, 快0[0]; //After, 略慢//内置值Infinity;1/0;//布尔值短写法true; //Before!0; //After//布尔值短写法false; //Before!1; //After base64图片前缀 data:image/png;base64, 拷贝12345对象拷贝let obj = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(copyObj))数组拷贝let arr = [].concat(copyArr); 第二次var定义变量如果不赋值，该值为原来定义的值123var a = 100;var a;console.log(a); // 100 函数声明会比变量声明先1234console.log(a); // functionvar a = &apos;123&apos;;function a ()&#123;&#125;;console.log(a); // 123 new的过程 创建一个新对象 将构造函数的作用域赋值给新对象 执行构造函数的代码 返回新的对象 原型链的顶层 null 自定义事件12345let evt = document.createEvent(&quot;HTMLEvents&quot;);// 初始化evt.initEvent(&quot;alert&quot;, false, false);// 触发week.dispatchEvent(evt); 查看元素事件12window.getEventListeners(window); // 返回事件对象，如&#123;click:[], mousedown:[]&#125;window.getEventListeners(window).click[0].listener; // 获取第一个绑定的click事件函数 生成任意长度，且值为undefined的数组 Array.apply(null, {length: 2}); // [undefined, undefined] 移动端将键盘回车变为搜索12345将input的type改为search在input外包一层form, form标签设置action属性, 设置autocomplete=&quot;off&quot;去掉弹出的下拉框设置input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123;display: none;&#125;将默认的X隐藏掉设置-webkit-appearance: none;去掉默认样式使用ajax提交时需要preventDefault阻止默认行为 监听APP返回键12345678910var hiddenProperty = &apos;hidden&apos; in document ? &apos;hidden&apos; : &apos;webkitHidden&apos; in document ? &apos;webkitHidden&apos; : &apos;mozHidden&apos; in document ? &apos;mozHidden&apos; : null;var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &apos;visibilitychange&apos;);var onVisibilityChange = function()&#123; if (document[hiddenProperty]) &#123; console.log(&apos;页面非激活&apos;); &#125;else&#123; console.log(&apos;页面激活&apos;) &#125;&#125;document.addEventListener(visibilityChangeEvent, onVisibilityChange); parseInt1parseInt(&apos;12abc&apos;); // 12 触发鼠标右键事件1on(&quot;contextmenu&quot;) window.open window.open打开的子窗口可以使用opener访问父窗口的方法和变量 onInput 谷歌控制台使用Ctrl+p可以输入要打开的文件；onInput 是 HTML5 的标准事件，对于检测 textarea, input(text), input(password) 和 input(search) 这几个元素通过用户界面发生的内容变化非常有用，在内容修改后立即被触发，不像 onchange 事件需要失去焦点才触发。oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的onpropertychange 事件替代。 try、catch、finally Js如果在try中return则不会进入finally 调用颜色盘 设置input的type为color 改变当前链接1location.replace(url) IOS日期转换问题 IOS的Safari在new Date()的时候不支持’2017-3-6’的格式，支持’2017/3/6’，也不支持date为2018/09/19 00.00.00.0，后缀带.0的 http get请求默认会在浏览器中缓存，可以通过添加时间戳来避免缓存 NodeJS Event loop1234567891011121314151617181920212223242526272829console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&apos;Promise&apos;) resolve()&#125;).then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout微任务: process.nextTick, promise, Object.observe, MutationObserver宏任务: script, setTimeout, setInterval, setImmediate, I/O, UI rendering&gt; setImmediate会比setTimeout先执行Event loop执行顺序1. 执行同步代码，这属于宏任务2. 执行栈为空，查询是否有微任务需要执行3. 执行所有微任务4. 必要的话渲染 UI5. 然后开始下一轮 Event loop，执行宏任务中的异步代码 存储特性 | cookie | localStorage | sessionStorage | indexDB—|—|—|—|—数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在数据存储大小 | 4K | 5M | 5M | 无限与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 cookie安全性属性 | 作用—|—value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击secure | 只能在协议为 HTTPS 的请求中携带same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 1234567891011121314151617181920212223242526272829303132// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker.register(&apos;sw.js&apos;).then(registration =&gt; &#123; console.log(&apos;service worker 注册成功&apos;); &#125;).catch((err) =&gt; &#123; console.log(&apos;service worker 注册失败&apos;); &#125;);&#125;// sw.js// 监听install事件，回调缓存所需文件self.addEventListener(&apos;install&apos;, e =&gt; &#123; e.waitUntil( // 设置缓存的名称为my-cache caches.open(&apos;my-cache&apos;).then(cache =&gt; &#123; return cache.addAll([&apos;./index.html&apos;, &apos;./index.js&apos;]); &#125;); );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&apos;fetch&apos;, e =&gt; &#123; e.respondWith( caches.match(e.request).then(response =&gt; &#123; if (response) &#123; return response &#125; console.log(&apos;fetch source&apos;); &#125;); );&#125;) Load和DOMContentLoaded区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 生成新图层 3D变换: translate3d、translateZ will-change video、iframe标签 通过动画实现的opacity动画转换 position: fixed 对于频繁渲染的建议生成一个新的图层，提高性能。但不能生成过多图层，会引起反作用。 重绘(Repaint)和回流(Reflow) 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 其他并行、并发 并行：宏观和微观上都是同时进行 并发：宏观上同时，微观上不同时 工具库 loadash、date-fns(日期格式化)、accounting.js(货币格式化) jsencrypt 用于请求参数加密处理，加密方式为RSA vue框架核心方法defineProperty(defineProperties)123456789writable、value和set、get不能同时存在Object.defineProperty(obj, prop, &#123; configurable: false, //是否可以通过delete删除，能否修改属性的特性。直白点：是否可配置 enumerable: false, //枚举性，表示是否可以通过for-in循环返回 writable: false, //可写性：是否可以修改属性的值 value: undefined, //包含属性的值，也就是对应的可读性。 set: undefined, get: undefined&#125;) 获取github用户信息 https://api.github.com/users/{id} 复制功能 https://clipboardjs.com/ https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4 安装nvm后无法使用问题 先nvm install node，然后再nvm use [version] nvm安装最新nodejs包 nvm install latest 判断点击元素是否为某个元素的后代元素12345document.addEventListener(&apos;click&apos;, (e) =&gt; &#123; if (el.contains(e.target)) &#123; console.log(&apos;包含&apos;) &#125;&#125;)","categories":[],"tags":[]},{"title":"meta标签","slug":"front-end/html/tag-meta","date":"2018-12-11T00:43:10.000Z","updated":"2018-12-12T14:01:51.522Z","comments":true,"path":"2018/12/11/front-end/html/tag-meta/","link":"","permalink":"https://tragiclife.github.io/2018/12/11/front-end/html/tag-meta/","excerpt":"","text":"meta标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset=&apos;utf-8&apos;&gt;&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;&lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt;&lt;!-- 页面描述 --&gt;&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;&lt;!-- 网页作者 --&gt;&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;&lt;!-- 搜索引擎抓取 --&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;!-- 为移动设备添加 viewport --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;&lt;!-- iOS 设备 begin --&gt;&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;&lt;!-- iOS 图标 begin --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;!-- iOS 图标 end --&gt;&lt;!-- iOS 启动画面 begin --&gt;&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;&lt;!-- iPad 横屏 2048x1496（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;&lt;!-- iOS 启动画面 end --&gt;&lt;!-- iOS 设备 end --&gt;&lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;&lt;!-- Windows 8 磁贴图标 --&gt;&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;&lt;!-- 添加 RSS 订阅 --&gt;&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;&lt;!-- 添加 favicon icon --&gt;&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;&lt;!-- sns 社交标签 begin --&gt;&lt;!-- 参考微博API --&gt;&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;&lt;!-- sns 社交标签 end --&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://tragiclife.github.io/tags/html/"}]},{"title":"css实现居中","slug":"front-end/css/css-centered","date":"2018-12-11T00:03:53.000Z","updated":"2018-12-10T16:44:17.671Z","comments":true,"path":"2018/12/11/front-end/css/css-centered/","link":"","permalink":"https://tragiclife.github.io/2018/12/11/front-end/css/css-centered/","excerpt":"","text":"","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"css揭秘","slug":"front-end/css/css-reveal-secrets","date":"2018-12-10T00:04:00.000Z","updated":"2018-12-13T16:35:44.164Z","comments":true,"path":"2018/12/10/front-end/css/css-reveal-secrets/","link":"","permalink":"https://tragiclife.github.io/2018/12/10/front-end/css/css-reveal-secrets/","excerpt":"","text":"边框使用box-shadow制作假边框，第四个值为增大或者减小投影面积(box-shadow范围内不会触发事件)box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道 5px 的外框，那就需要指定扩张半径的值为15px （ 10px+5px ），会随着border-radius贴合border .box-shadow{margin: 20px;width: 10px;height: 10px;-webkit-box-shadow: 0 0 0 10px red, 0 0 0 15px blue;box-shadow: 0 0 0 10px red, 0 0 0 15px blue;} 1234567&lt;div class=&quot;box-shadow&quot;&gt;&lt;/div&gt;.box-shadow&#123; width: 10px; height: 10px; -webkit-box-shadow: 0 0 0 10px red, 0 0 0 15px blue; box-shadow: 0 0 0 10px red, 0 0 0 15px blue;&#125; outline不触发事件，不随border-radius而贴合border .outline {margin: 10px;width: 10px;height: 10px;border: 5px solid red;outline: 5px solid blue;box-sizing: content-box;} 1234567&lt;div class=&quot;outline&quot;&gt;&lt;/div&gt;.outline &#123; width: 10px; height: 10px; border: 5px solid red; outline: 5px solid blue;&#125; background-origin通过backgroun-origin改变background-position的基准位置 reapting-linear-gradientlinear-gradient的扩展 利用linear-gradient实现网格 .linear-gradient {margin: 10px;width: 100px;height: 100px;background: white;background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%,transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0);background-size: 30px 30px;} 1234567.linear-gradient &#123; width: 100px; height: 100px; background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px;&#125; 形状自适应的椭圆(元素为正方形时展示圆形)border-radius: 50% / 50%;可简写为border-radius: 50%; 切角效果 .corner-cutting{display: inline-block;width:100px; height: 100px;line-height: 100px;background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,linear-gradient(45deg, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;text-align: center;}.clip-path{clip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px);} background clip-path12345678910111213.corner-cutting &#123; width: 100px; height: 100px; background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125;// 或者使用clip-pathclip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px);制作单边倾斜的梯形12transform: perspective(.5em) rotateX(5deg);transform-origin: bottom left;投影单边投影box-shadow: 0 5px 4px -4px black;邻边投影box-shadow: 3px 3px 6px -3px black;两侧投影box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black;滤镜filter: bulr(1px) grayscale() drop-shadow(3px 3px 6px black;)blur 元素模糊drop-shadow 类似于box-shadow设置缩进tab-size: 2;空心字效果text-shadow: 1px 1px black, -1px -1px black, 1px -1px black, -1px 1px black;或text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black;使用text-shadow实现文字模糊效果color: transparent;text-shadow: 0 0 .1em white, 0 0 .3em white;利用svg实现环形文字效果circular reasoning works because 用户体验使用合适的cursor增大可点击范围border: 10px solid transparent;background-clip: padding-box;需要边框时增加box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset; 水平居中行内元素：对其父元素设置text-align:center;块级元素：对其自身设置margin:0 auto; 实现水平垂直居中position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);margin: 50% auto 0;transform: translateY(-50%);(只适用于全屏居中)父元素设置display:flex;min-height:100vh;margin:0;子元素设置margin:auto; 小球回弹动画@keyframes bounce { 60%, 80%, to { transform: translateY(400px); animation-timing-function: ease; } 70% { transform: translateY(300px); } 90% { transform: translateY(360px); }}.ball {animation: bounce 3s cubic-bezier(.1,.25,1,.25);} 利用steps对png背景做切换animation: loader 1s infinite steps(8);@keyframes loader {to { background-position: -800px 0; }} 实现闪烁效果.highlight {animation: .5s blink-smooth 6 alternate;}@keyframes blink-smooth { to { color: transparent } } 背景图片来回播放@keyframes panoramic {to { background-position: 100% 0; }}.panoramic { width: 150px; height: 150px; background: url(“img/naxos-greece.jpg”); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;}.panoramic:hover, .panoramic:focus { animation-play-state: running;} 利用translate实现transform-origin的效果transform: rotate(30deg);transform-origin: 200px 300px;上面两行等同于下面两行transform: translate(200px, 300px) rotate(30deg) translate(-200px, -300px);transform-origin: 0 0;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"日常小记-样式","slug":"front-end/css/daily-notes","date":"2018-12-09T00:12:08.000Z","updated":"2018-12-08T16:28:27.303Z","comments":true,"path":"2018/12/09/front-end/css/daily-notes/","link":"","permalink":"https://tragiclife.github.io/2018/12/09/front-end/css/daily-notes/","excerpt":"","text":"命名规范BEM(block element modifier) 记录的知识点浏览器html默认字体大小为16px，设置font-size为62.5%后可换算为10px 常用的屏幕大小手机屏：&lt;768pad屏：≥768显示器：≥992大屏显示器：≥1200 word-break：break-all设置后火狐下的文字会比较对齐 50vh表示50%的设备高度，50vw表示50%的设备宽度 禁止文本选中user-select:none 链接的伪类:link :visited :hover :active(点击时) ie浏览器的option标签不可改变样式、不触发事件(由select触发) 子元素都为float，则父元素需要设置float才能被撑开 bsckground:url() repeat attachment position/size origin clip 使用inline-block边距会多出4个像素，可通过font-size:0去除 文字要超过一行text-align:justify才会生效 textarea添加spellcheck＝”false”去除检查 display:inline-block的元素可以通过vertical-align:middle实现居中 resize属性可以设置文本框的拖动，其overflow需要设置为overflow/auto/scroll 制作梯形transform: perspective(20px) rotateX(-1deg ) rotateY(-2deg) translateZ(0) 实现模糊效果(支持IOS)backdrop-filter:blur(10px); matrix(a,b,c,d,e,f)e和f相当于translatea和d相当于scaleb和c相当于rotate 使滚动变流畅-webkit-overflow-scrolling: touch; -webkit-overflow-scrolling产生的问题滚动中scrollTop不会变化、不触发scroll事件，只在停下来的时候触发手势可穿过其它元素触发元素滚动滚动时暂停其它transition有时会卡住不动，浏览器容器回弹停止后才可滑动 文本渐变h2[data-text] { position: relative;}h2[data-text]::after { content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));} 黑白图片img { filter: grayscale(100%);} 优化文本显示.text { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;} 文本模糊.text{ text-shadow: 0 0 5px rgba(0, 0, 0, .5)} 表格单元格等宽.table { table-layout: fixed;} 多行省略号display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; 伸缩盒子元素的宽度没有超过父元素宽度或没有设置flex-wrap: wrap时，align-content不生效 GPU硬件加速1、设置will-change:transform进行硬件加速，还需要设置trsnsform:translateZ(0)进行hack2、transform: translate3d(0, 0, 0) 避免隐式合成保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。 动画优化减少浏览器的重排和重绘的发生。不要使用table布局。css动画中尽量只使用transform和opacity，这不会发生重排和重绘。尽可能地只使用css做动画。避免浏览器的隐式合成。改变复合层的尺寸。(使用小图片，通过scale放大) 只有块级元素或者行内块元素transform属性才回生效 scroll-behavior: smooth使用锚点切换时平滑滚动 实现左右300px，中间自适应布局1、float(优：兼容性好；缺：需要清除浮动)2、position:absolute(优：布局快；缺：兄弟元素都需要脱离文档流处理，可使用性差)3、flex(比较完美)4、table、table-cell(易处理；其中一个单元格高度增长时，其余也会跟着增长)5、grid background的设置顺序background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; :last-child匹配父元素的最后一个元素 position:fixed宽高受父级元素影响问题如果父级元素使用了transform，则其position为fixed的子元素设置的宽高受父元素影响 touch-actionhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-actionhttps://www.zhangxinxu.com/wordpress/2018/07/chrome-safari-touchmove-preventdefault-treated-as-passive/ 移动端设置cursor: pointer时，点击元素会有背景色设置元素*{-webkit-tap-highlight-color: transparent; } 图片上下排列3px间隔的消除方法给居上的图片加vertical-align: top给居上的图片加display: block设置font-size: 0","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"屏幕适配","slug":"front-end/css/screen-adaptation","date":"2018-12-08T00:34:18.000Z","updated":"2018-12-07T17:12:18.000Z","comments":true,"path":"2018/12/08/front-end/css/screen-adaptation/","link":"","permalink":"https://tragiclife.github.io/2018/12/08/front-end/css/screen-adaptation/","excerpt":"","text":"常见移动web适配方法PC960px/1000px居中盒子模型，定高，定宽display:inline-block 移动web:定高，宽度百分比flexMedia Query(媒体查询) Media Query1234@media 媒体类型 and (媒体特性)如: @media screen and (max-width:320px)可在标签上引用&lt;link href=&quot;&quot; media=&quot;screen and (max-width:320px)&quot;/&gt; rem原理和简介字体单位值根据html根元素大小而定，同样可以作为宽度、高度等单位适配原理将px替换成rem，动态修改html的font-size适配兼容性IOS6以上、Android2.1以上 js动态修改font-sizelet htmlWidth = document.docElement.clientWidth || document.body.clientWidthlet $html = document.querySelector(‘html’)$html.style.fontSize = htmWidth / 3.75 + ‘px’","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"},{"name":"rem","slug":"rem","permalink":"https://tragiclife.github.io/tags/rem/"}]},{"title":"深入overflow","slug":"front-end/css/deep-into-overflow","date":"2018-12-07T22:28:51.000Z","updated":"2018-12-07T17:15:17.841Z","comments":true,"path":"2018/12/08/front-end/css/deep-into-overflow/","link":"","permalink":"https://tragiclife.github.io/2018/12/08/front-end/css/deep-into-overflow/","excerpt":"","text":"相关问题 overfloe-x、overflow-y(IE8+)如果overflow-x与overflow-y相同，则等同于overflow；如果两个设置不同，切其中一个设置为visible则visible会被重置为auto 表格元素无效，需要先设置table-layout:fixed overflow:auto时，chrome下能显示padding-bottom，而其他浏览器都不显示padding-bottom 无论什么浏览器，默认滚动条都来自html标签，而不是body标签 获取滚动高度12chrome:document.body.scrollTop其他浏览器:document.documentElement.scrollTop 滚动条的宽度等于外部容器减去内部元素的clientWidth 出现滚动条时，修复水平居中的元素跳动问题 设置html{overflow-y:scroll} container{padding-left:calc(100vw - 100%)}，既设置滚动条的宽度，适用于IE9+及其他浏览器 格式化上下文1overflow:auto/scroll/hidden 作用 清除浮动影响overflow:hidden;_zoom:1; 避免margin穿透问题 两栏自适应布局 BFC属性12345678910111213// 自适应，但溢出不可见，限制了应用场景overflow:hidden// 包裹性+破坏性，无法自适应，块状浮动布局float+floatposition:absolute // 包裹性，无法自适应，IE6、7不识别display:inline-block// 包裹性，无溢出特性，绝对宽度也能自适应display:table-cell 两栏自适应布局display:table-cell;width:2000px;//IE8+ BFC特性display:inline-block;width:auto;//IE7- 伪BFC特性 元素的父元素没有设置position:absolute/relative/fixed时，父元素的overflow无法包裹住position:absolute的子元素12345678910111213让overflow起作用例子：// 父元素设置overflow:hidden;position:relative// 子元素设置position:absolutediv overflow:hidden div display:relative div position:absolutediv overflow:hidden div transform:translate(0) overflow失效妙用123456// 父元素height:0;overflow:hidden;text-align:right;// 子元素position:absolute resize拉伸(horizontal、vertical、both)元素的overflow不能是visible 文字溢出出省略号123456789101112// 单行省略width:100px;white-space:nowrap;text-overflow:ellipisis;overflow:hidden;// 多行省略号display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 显示的行数overflow: hidden;text-overflow: ellipsis; IE7下，当宽度或高度设置为100%时，会出现滚动条IE7解决文字越多，padding越大问题，设置overflow:visible 锚点定位锚点定位的触发url地址中的锚链与锚点元素可focus的锚点元素处于focus态 作用快速定位选项卡技术 应用场景单页应用","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入float","slug":"front-end/css/deep-into-float","date":"2018-12-06T21:39:30.000Z","updated":"2018-12-06T14:59:32.900Z","comments":true,"path":"2018/12/07/front-end/css/deep-into-float/","link":"","permalink":"https://tragiclife.github.io/2018/12/07/front-end/css/deep-into-float/","excerpt":"","text":"设置初衷为了文字的环绕float元素会产生BFC(块级格式化上下文，block formatting context) 特性 包裹具有包裹性的相关属性 123display:inline-block/table-cellposition:absolute/fixed/stickyoverflow:hidden/scroll 破坏(父元素塌陷)具有破坏性的相关属性 12display:noneposition:absolute/fixed/sticky 能形成BFC的样式12345float:left/rightposition:absolute/fixedoverflow:hidden/scroll(IE7+)display:inline-block/table-cell(IE8+)width/height/zoom:1...(IE6/IE7) 清除浮动(较佳使用)123.clearfix:after&#123;content:&apos;&apos;;display:table;clear:both;&#125;.clesrfix&#123;*zoom:1;&#125; //IE6、7应用于包含浮动元素的父元素上 浮动与两侧皆适应的流体布局display:table-cell;display:inline-block;width:2000px;width:auto","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入border","slug":"front-end/css/deep-into-border","date":"2018-12-05T23:16:00.000Z","updated":"2018-12-06T13:13:36.670Z","comments":true,"path":"2018/12/06/front-end/css/deep-into-border/","link":"","permalink":"https://tragiclife.github.io/2018/12/06/front-end/css/deep-into-border/","excerpt":"","text":"border-style为dashed时，不同浏览器下实线和空白区域的比例不同 dotted形状不同 当border-color没有指定颜色时，默认使用color作为边框颜色，类似的还有box-shadow,text-shadow ，outline 让背景图固定距离右侧50pxborder-right:50px solid transparentbackground-position:100% 40px 投影(元素不可见时该属性也是不可见的)filter:drop-shadow(20px 0 #ff8040)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入padding","slug":"front-end/css/deep-into-padding","date":"2018-12-04T21:37:28.000Z","updated":"2018-12-05T16:28:53.637Z","comments":true,"path":"2018/12/05/front-end/css/deep-into-padding/","link":"","permalink":"https://tragiclife.github.io/2018/12/05/front-end/css/deep-into-padding/","excerpt":"","text":"padding是否生效对于block水平元素 padding值过大，一定会影响尺寸 width非auto，padding一定影响尺寸 width为auto或box-sizing为border-box，同时padding值没有过大，不影响尺寸 对于inline水平元素水平padding影响尺寸，垂直padding不影响尺寸，但是会影响背景色(占据空间) 支持的属性值 不支持负值 百分比根据宽度计算(如果设置50%则为一个正方形) inline元素的padding：同样相对于宽度计算，默认的宽度高度细节有差异，padding会断行 inline元素的垂直padding会让让空白节点显现，既规范中的strut，可以通过font-size:0去除 ol/ul标签内置padding-left是以px为单位的，如果字号很小，间距就会很开；如果字号很大，就会跑到容器外面input、textarea、button都有内置padding在firefox下设置button的padding为0时依然有padding值，通过设置button::-moz-focus-inner{padding:0}。IE7下文字越多，button的padding值越大，通过设置button{overflow:visiable;}去除。可访问性隐藏：将元素设置absolute，定位到看不见的地方，或者设置z-index为-1隐藏在背景之下。可通过使用label来代替button12&lt;button id＝&quot;btn&quot;&gt;&lt;/button&gt;&lt;label for＝&quot;btn&quot;&gt;&lt;/label&gt; 通过background-clip:content-box与padding结合，实现border与内容区域之间空白的效果 如何得到一个正方形.square-container{width: 50px;height: 50px;}.square {width: 100%;padding-top: 100%;background-color: blue;} 123456789101112.square-container&#123; width: 50px; height: 50px;&#125;.square &#123; width: 100%; padding-top: 100%; background-color: blue;&#125;&lt;div class=&quot;square-container&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]},{"title":"深入margin","slug":"front-end/css/deep-into-margin","date":"2018-12-03T22:42:01.000Z","updated":"2018-12-05T15:14:35.578Z","comments":true,"path":"2018/12/04/front-end/css/deep-into-margin/","link":"","permalink":"https://tragiclife.github.io/2018/12/04/front-end/css/deep-into-margin/","excerpt":"","text":"设置元素的外边距，允许使用负值，适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 设置方式1234567891011// 设置一个值，相当于四个方向的外边距都为10pxmargin: 10px;// 设置两个值，相当于设置上下、左右的外边距，即上下为10px，左右为5pxmargin: 10px 5px;// 设置三个值，相当于设置上、左右、下的外边距，即上为10px，左右为5px，下为1pxmargin: 10px 5px 1px;// 设置四个值，相当于设置上、右、下、左的外边距，即上为10px，右为5px，下为2px，左为1pxmargin: 10px 5px 2px 1px; 特性 可以改变元素尺寸 适用于没有设置宽高的普通block元素，既非float、absolute/fixed、inline、table-cell元素。 如何计算普通元素的百分比margin都是相对于容器的宽度计算的绝对定位元素的百分比margin是相对于第一个定位祖先元素（relative、absolute、fixed）的宽度计算的。 margin重叠margin重叠特性只对block元素(除float和absolute)起作用，只发生在垂直方向上(writing-mode设置可变为水平方向) 重叠的三种情境 相邻的兄弟元素 父级元素和第一个或最后一个子元素 空的block元素正正取大值，正负值相加，负负最负值 实现水平垂直居中12345678// 元素宽高固定position:absolute;top: 50%;left: 50%;margin-top: -50px;margin-left: -100px;width: 100px;height: 200px; 负值的应用场景1234567891011121314// margin负值下的两端对齐ul &#123; margin-right:-20px;&#125;li &#123; margin-right:20px;&#125;// margin负值下的等高布局div &#123; margin-bottom:-600px; padding-bottom:600px;&#125;// margin负值下的两栏自适应布局 margin失效情形 inline水平元素的垂直margin无效 margin重叠 display:table-cell等 position:absolute;当其父元素设置为relative时会生效 前一个元素float以后，后一个元素的margin-left要大于前一个元素的宽度时才会生效 内联特性导致无效 新属性值123456789101112// (一开始相当于margin-left):文档流开始的方向leftmargin-start// 相当于margin-topmargin-before// 相当于margin-bottommargin-after// 重叠效果margin-collapse可选值：collapse(默认重叠) | discard(取消margin效果) | separate(不重叠)","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tragiclife.github.io/tags/css/"}]}]}